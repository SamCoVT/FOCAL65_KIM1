; FOCAL-65 (V3D) 26-AUG-77 FOR KIM-1, by Wayne Wall (c) 1977

; First disassembly by Paul R. Santa-Maria (2004)
; Initial comments added by Hans Otten, 2022
;
; New listing and comments from Wayne Wall's FOCAL-65 v3 (6502-TIM monitor ROM)
; and v4 (Apple II-specific) painstakingly typed in by Dave Hassler and
; Nils Anders, 2023. (WAYNE'S COMMENTS, my/Nils's comments - dhh)
; v3d TIM source provided by Paul Bikle, v4 by Wayne Wall, both in 2023.
; Proofreading and corrections by
;

; Zero page - *must* be loaded before main program executes

;0000  53 53 4C E0 2C 4C DF 2C-00 00 00 00 00 00 00 00
;0010  00 62 7B 66 EB 6B 3A 7B-6A 6B 6B 7B FB 7B 6B 6B
;0020  00 00 00 00 00 00 FF 00-00 01 00 00 00 00 00 E0
;0030  36 FE 36 00 00 00 00 00-00 00 00 00 00 00 FF 36
;0040  FF 36 FF 36 00 00 00 00-00 00 00 00 00 00 00 00
;0050  00 00 00 00 5F 00 00 00-00 00 00 00 00 00 4C 00
;0060  00 6C 00 00 48 00 00 00-00 00 00 00 00 00 00 C0
;0070  10 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00
;0080  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 05
;0090  05 83 50 00 00 00 7F 40-00 00 00 80 40 00 00 00
;00A0  00 00 00 00 00 FF 1C 3C-7C 5F 7F 7C 3E 7F 3E FF
;00B0  94 DD 84 D4 85 D4 95 04-DD 94 95 DF 8C 15 1D 94
;00C0  00 D3 E0 C1 80 90 D3 C0-C2 A3 00 C0 81 82 C3 80
;00D0  62 6A FB 6B 6A 6A 02 FF-5A 4B E3 10 EB 62 62 4B
;00E0  7F 6C 7F 7D 3F 7F 2E 7F-7F 7E 7F 36 5F 7E 3E 7F
;00F0  94 00 FF FF 84 A7 19 83-00 00 DF 10 A9 FF C7 01

; ZERO PAGE USE:

; 00	= unused
; 02	= JMP INTSRV	- on IRQ
; 05	= JMP NMISRV	- on NMI
;    -- I have *no* idea what's going on with $10-$1F... dhh)

DEBGSW	= $20		; TRACE FLAG
DMPSW	= $21		; 'DUMP SWITCH'
ATSW	= $22		; ASK-TYPE CMDS FLAG
IFONSW	= $23		; IF-ON CMDS FLAG
INSW	= $24		; INPUT INDICATOR
MSCHAR	= $25		; 'MODIFY' SEARCH CHAR

		; *** FOLLOWING MUST BE CONTIGUOUS ***
PC	= $26		; PROG COUNTER
TXTADR	= $28		; CHAR ADDR
TEXTP	= $2A		; TEXT POINTER
CHAR	= $2B		; CURRENT CHARACTER
GRPNO	= $2C		; GROUP NUMBER
LINENO	= $2D		; LINE (STEP) NUMBER
PRILVL	= $2E		; CURRENT S/W INTERUPT PRIORITY
		; *** END OF MUST BE CONTIGUOUS ***

TXTBEG	= $2F		; POINTER TO BEGINNING OF STORED PROGRAM
PBADR	= $31		; ADDR OF START OF USER PROGRAM
TXTAD2	= $33
TEXTP2	= $35		; COUNTERPART TO 'CHAR,' ABOVE

		; POINTERS TO VARIABLE LIST - *** MUST BE CONTIGUOUS ***

VARADR	= $37		; POINTER TO CURRENT VAR IN LIST
VSUB	= $39		; LOCATION TO HOLD SUBSCRIPT DURING VAR SEARCH
STRSWT 	= $3B		; FLAG IF CURR VAR IS $ (also label FSWIT)
VSIZE	= $3C		; SIZE OF CURR STRING VAR (GETVAR)
VCHAR	= $3D		; PLACE TO HOLD VAR NAME DURING SEARCH (also TCHAR)
VARBEG	= $3E		; POINTER BEGINNING VAR LIST
VARST	= $40		; POINTS TO END OF VARS ON 'E ALL' COMMAND
VAREND	= $42		; POINTS TO END OF VAR LIST

		; POINTERS FOR STRING I/O

STIADR	= $44		; HOLDS ADDR POINTER TO INPUT STRING
STIPNT	= $46		; OFFSET POINTER
STIMAX	= $47		; HOLDS SIZE OF INPUT STRING
STOADR	= $48		; HOLDS ADDR POINTER TO OUTPUT STRING
STOPNT	= $4A		; OFFSET POINTER
STOMAX	= $4B		; HOLDS SIZE OF OUTPUT STRING

		; SOFTWARE PUSHDOWN LIST

PDPADR	= $4C		; ADDR TO LIST (software stack)
PDP	= $4E		; OFFSET POINTER TO LIST
PDPTMP	= $4F		; TEMP LOC. FOR 'ROOMCK'
TGRP	= $51		; HOLDS TEMPORARY GROUP NUMBER FOR SOME
TLINE	= $51		;   OPERATIONS. TEMP LINE # HERE

PDLIST	= $53		; STARTING ADDR OF SOFTWARE PDL
			; ** effectively, the last page of FOCAL's user RAM.
			;    Change to what suits your system. - dhh
ITMP1L	= $55		; TEMP1 LOW BYTE
ITMP1H	= $56		; TEMP1 HIGH BYTE (this is also STRCNT)
SBEG1	= $57		; START POS. OF STRING 1
SEND1	= $58		; END POS. STRING 1
ITMP2L	= $59		; TEMP2 LOW BYTE
ITMP2H	= $5A		; TEMP2 HIGH BYTE (this is also STRMAX)
SBEG2	= $5B		; START POS. OF STRING 2
SEND2	= $5C		; END POS. STRING 2
STBSAV	= $5D		; PLACE TO SAVE BEGINNING SUBSCRIPT
JSRIND	= $5E		; JSR OPCODE ($4C) FOR 'JSRIND' - *MUST* BE PLACED
			;   JUST BEFORE 'TEMP1'.
TEMP1	= $5F		;   *** VERY TEMPORARY STORAGE! NOT NECESSARILY
			;   PRESERVED ACROSS SUBROUTINE CALLS!
JMPIND	= $61		; OPCODE FOR 'JMP INDIRECT' ($6C)
PJMPL	= $62		; LOW ORDER ADDR FOR 'JMPIND'
PJMPH	= $63		; HIGH ORDER BYTE

STRSIZ	= $64		; HOLDS DEFAULT STRING SIZE ($48)
ETEMP1	= $65		; TEMP USED BY 'EVAL'
IDEV	= $66		; SPECIFIES INPUT DEVICE
ODEV	= $67		; SPECIFIES OUTPUT DEVICE
IDVSAV	= $68		; SAVE INP DEV #
ODVSAV	= $69		; SAVE OUTPUT DEV #
CONDEV	= $6A		; SPECIFIES DEVICE # OF CONSOLE
ECHFLG	= $6B		; ECHO FLAG
DELSPL	= $6C		; SPECIAL DELETE FOR CRT
ACTMSK	= $6D		; MASK TO INDICATE WHICH S/W INTERRUPT CH ARE ACTIVE
EVMASK	= $6E		; HOLDS EVENT BITS SET BY EXTERNAL ROUTINES
			;   WHEN THEY WANT FOCAL'S ATTENTION
BITV1	= $6F		; USED TO SET V=1, N=1 (#$C0)
MSKBRK	= $70		; BIT TEST MASK FOR BREAK (#$10)
ACSAV	= $71		; PLACE WHERE ACC IS SAVED ON INTERRUPT
STATUS	= $72		; PLACE WHERE PROC STATUS IS SAVED ON INTERRUPT
ITEMP1	= $73		; PLACE WHERE RET ADDR IS KEPT ON INTERRUPT

LASTOP	= $75		; USED BY 'EVAL'
HASH	= $76		; LOADED WITH A RANDOM HASH VALUE
			;   *** NOTE: SOME ROUTINE IN YOUR SPECIFIC
			;             COMPUTER SYSTEM SHOULD LOAD THIS
			;	      LOC. WITH A PSEUDO-RANDOM 8-BIT VALUE.
SEED	= $77		; 3 BYTES. HOLDS A 23-BIT RANDOM # SEED - SEE 'FRAN'

		; FLOATING POINT ROUTINES Z PG USE

SIGN	= $7A		; (also X2M1)

X2	= $7B		; FAC2 EXPONENT (also the *beginning of 'FAC2'*)
M2	= $7C		; FAC2 MANTISSA (3 bytes)
X1M1	= $7F

X1	= $80		; FAC1 EXPONENT (also the *beginning of 'FAC1'*)
M1	= $81		; FAC1 MANTISSA (3 bytes, also 'FLCSGN')
EM1	= $84
E	= $85		; SCRATCH AREA
EP4	= $89		; add'l scratch RAM alluded to elsewhere

		; FLOATING POINT I/O ROUTINES

SIGNP	= $8A		; TEMPORARY SIGN
DPFLG	= $8B		; SAW DECIMAL POINT
GOTFLG	= $8C		; IF NON ZERO, WE ACTUALLY INPUT A NUMBER
K	= $8D		; MISC COUNTER
L	= $8E		; TEMP
M	= $8F		; # OF PLACES BEFORE DECIMAL POINT
N	= $90		; # OF PLACES AFTER DECIMAL POINT

FTEN	= $91		; CONSTANT 10.00
FHALF	= $96		; CONSTANT 2.50
FONE	= $9B		; CONSTANT 1.00
T	= $A0		; TEMP

		; FLAG END OF OUR PAGE ZERO USAGE
		; FOR ANYONE WHO NEEDS TO KNOW

;	$A5 = SAVYR  save for Y register (was $7F in v3 - RUBOUT)

		; MORE DEFINITIONS

NUMBF	= 5		; # BYTES IN A F.P. #
VARSIZ	= 3+NUMBF	; 1 BYTE FOR NAME, 2 BYTES SUBSCRIPT, THEN VALUE
LINEL	= 127		; MAX LENGTH FOCAL LINE +1; MUST NOT >127 (SEE 'PACKC')
EOV	= $FF		; END OF VAR MARKER
EOP	= $FE		; END OF PROG MARKER
UMARK	= $FD		; ANOTHER UNIQUE MARKER
STRMRK	= $FC		; MARKS A STRING VAR IN VAR LIST
STRLEN	= 72		; DEF STRING LENGTH

; RUBECH	= $5C	'\' ECHOED FOR RUBOUT (unused here for modern tty emu)
; LINCHR	= $5F	'_' ECHOED FOR LINE DELETE
; ALTCHR	= $1B	'ESC' CHAR USED FOR 'ALTMODE' - MAY REQUIRE CHANGE

DIRLIN	= $FF
STRLIN	= $FE
RETCMD	= $FD

STACK	= $0100

; self modifying code locations: (P.R.S-M)
;                H2350   EQU $2350
;                H2351   EQU $2351
;                H282F   EQU $282F
;                H2830   EQU $2830
;                H340A   EQU $340A
;                H340C   EQU $340C

					* = $2000

2000   78         FOCAL	SEI		; start of interpreter
2001   D8                   CLD
2002   A2 FF                LDX #$FF	; INIT STACK POINTER
2004   9A                   TXS
2005   20 0D 20             JSR SETUP
2008   20 27 20             JSR INIDEV	; INIT CONSOLE DEVICE
200B   00                   BRK		; ENTER FOCAL VIA TRAP
200C   EF                   .BYTE $EF	; A DATA BYTE - INDICATE 'RESET' PRESSED
200D   A2 FF      SETUP     LDX #$FF	; INIT SOFTWARE PUSHDOWN LIST
200F   20 1C 20             JSR PDPINI	
2012   E8                   INX		; FORM A ZERO IN X
2013   86 6B                STX ECHFLG	; TURNS ECHOING ON
2015   A5 6A      CLRDEV    LDA CONDEV	; SET CONSOLE AS BOTH IN AND OUT DEVICES
2017   85 66                STA IDEV
2019   85 67                STA ODEV
201B   60                   RTS
            ; 
            ; ROUTINE TO INIT SOFTWARE PUSHDOWN LIST POINTER
            ; 
201C   86 4E      PDPINI    STX PDP	; ASSUMED TO CONTAIN '$FF' IN X REGISTER
201E   A5 53                LDA PDLIST	; RESET ADDR POINTER
2020   85 4C                STA PDPADR
2022   A5 54                LDA PDLIST+1
2024   85 4D                STA PDPADR+1
2026   60                   RTS
            ; 
            ; ROUTINE TO INIT I/O DEVICES
            ; 
2027   A5 66      INIDEV    LDA IDEV	; INIT INPUT DEVICE
2029   20 8D 2E             JSR INI	
202C   A5 67                LDA ODEV	; INIT OUTPUT DEVICE
202E   4C A2 2E             JMP INO	; * PJMP * AND RETURN
            ; 
2031   A2 FF      START     LDX #$FF	; warm entry point. FOCAL comes here
2033   9A                   TXS		; on an internal restart. INIT STACK
2034   86 21                STX DMPSW	; FLAG THE TRACE OFF
2036   86 26                STX PC	; INDICATE PROC. A DIRECT COMMAND
2038   E8                   INX		; GET A ZERO
2039   86 20                STX DEBGSW	; ALLOW TRACE TO BE ENABLED
203B   86 28                STX TXTADR	; INIT TEXT POINTERS TO CMD BUFFER
203D   86 2A                STX TEXTP	; RESET OFFSET POINTER TO TEXT LINE
203F   86 6D                STX ACTMSK	; INDICATE ALL S/W INTER. CHNLS INACTIVE
2041   86 6E                STX EVMASK	; CLEAR ANY EXT. EVENT FLAGS
2043   86 2E		    STX PRILVL	; SET TO LOWEST PRIORITY LEVEL
2045   E8                   INX		; GET A 1
2046   86 29                STX TXTADR+1   ; CMD BUFFER IS IN STACK AREA
2048   A9 2A                LDA #$2A	; LOAD PROMPT CHARACTER '*'
204A   20 02 29             JSR PRINTC	;   AND ANNOUNCE OUR PRESENCE
204D   20 C0 28   NEXTIC    JSR READC	; GO INPUT A CHAR FROM INPUT DEVICE
2050   C9 0A                CMP #$0A	; LF?
2052   F0 F9                BEQ NEXTIC	; YES, IGNORE LF ON COMMAND INPUT
2054   20 2D 29             JSR PACKC1	; NO, STORE CHAR IN CMD BUFFER
2057   C9 0D                CMP #$0D	; CR?
2059   D0 F2                BNE NEXTIC	; IF NOT, GET ANOTHER
            ; 
            ; COMMAND/INPUT PROCESSOR
            ; 
205B   A2 00      IRETN     LDX #$00	; RESET TEXT POINTER
205D   86 2A                STX TEXTP
205F   86 24                STX INSW	; FLAG TEXT CHAR TO COME FROM MEMORY
2061   CA                   DEX		; SET TO $FF
2062   20 1C 20             JSR PDPINI	; INIT SOFTWARE PDL POINTER
2065   20 B1 29             JSR GSPNOR	; IGNORE LEADING BLANKS
2068   20 C0 29             JSR TESTN1	; HAVE A NUMBER?
206B   90 06                BCC GOTNUM	; YES, BRANCH
206D   C9 2E                CMP #$2E	; NO, TEST '.'
206F   D0 13                BNE INPX1	; NOT # OR '.', MUST BE DIRECT CMD
2071   00                   BRK		; TRAP
2072   FE 			.BYTE	; CODE FOR ILL. GROUP 0 USEAGE
2073   E6 20      GOTNUM    INC DEBGSW	; A DIGIT; DISABLE TRACE FOR PACKING
2075   20 B6 25             JSR GETLNC	; GET THE LINE # FROM COMBUF
2078   70 08                BVS IBADL	; 00.00 IS A BAD LINE NUMBER
207A   F0 06                BEQ IBADL	; GG.00 IS A BAD LINE NUMBER
207C   20 84 27   REPLIN    JSR INSERT	; GO INSERT THIS LINE IN THE TEXT AREA
207F   4C 31 20   RSTART    JMP START	; AND START OVER FOR NEXT DIR. CMD
2082   00         IBADL     BRK		; TRAP
2083   EC 		    .BYTE $EC	; ?BAD LINE # ON INPUT

2084   20 1C 28   INPX1     JSR PUSHJ	; PROCESS COMMAND
2087   02 23			.WORD PROC
2089   A5 26                LDA PC	; GET PROGRAM LINE NUMBER
208B   30 A4                BMI START	; START OVER IF DIRECT CMD
208D   20 D7 26             JSR EATCR1	; EAT TO END OF LINE
2090   20 32 27             JSR NXTLIN	; GO SET UP POINTERS TO NEXT LINE
2093   B0 EF                BCS INPX1	; BRANCH IF MORE TO DO
2095   90 9A                BCC START	; BRANCH IF END OF PROGRAM
            ; 
            ; ROUTINE TO 'DO' CODE STORED IN A STRING
            ; 
            ; THIS ROUTINE ALLOWS THE EXECUTION OF CODE STORED IN A
            ; STRING VARIABLE.  IF ONE PLACES CHARACTERS INTO A STRING
            ; VARIABLE, AND ENDS THEM WITH A CARRIAGE RETURN, THEN A
            ; 'DO' COMMAND CAN BE USED TO PERFORM THE LINE STORED IN THE
            ; STRING VARIABLE.
            ; 
2097   20 B9 20   DOSTR     JSR PUSHDO	; SAVE CURRENT GOODIES ON STACK
209A   A5 37                LDA VARADR	; POINT TO SPEC. CHAR IN STRING
209C   85 28                STA TXTADR	;   WITH TEXT POINTERS
209E   A5 38                LDA VARADR+1
20A0   85 29                STA TXTADR+1
20A2   A5 3A                LDA VSUB+1	; GET CHAR POSITION IN STRING
20A4   85 2A                STA TEXTP	
20A6   A9 FE                LDA #STRLIN	; FLAG THIS SO 'FNDLIN' WILL ALWAYS LOOK
20A8   85 26                STA PC	;   FROM BEGINNING OF PROGRAM TEXT
20AA   A5 3D                LDA VCHAR	; STORE THE STRING VARIABLE'S NAME FOR
20AC   85 27                STA PC+1	;   ERROR MSG PRINT ROUTINE (BERROR)
20AE   20 1C 28             JSR PUSHJ	; NOW 'DO' THE STRING (SHUD HAVE CR!)
20B1   FF 22                  	.WORD PROCES
20B3   20 C0 20             JSR POPDO	; RESTORE CURRENT GOODIES
20B6   20 4B 28             JSR POPJ	;   AND RETURN FROM 'DO'
            ; 
            ; ROUTINE TO SAVE NEEDED INFO ON STACK.  USED BY 'DO'
            ; 
20B9   A2 26      PUSHDO    LDX #$26	; GET ADDR OF START OF SAVE AREA
20BB   A0 09                LDY #$09	;   AND # OF BYTES TO SAVE
20BD   4C 6B 28             JMP PUSHB0	; * PJMP * PUSH THEM ON STACK & RET.
            ; 
            ; ROUTINE TO RESTORE NEEDED INFO AFTER THE 'DO'
            ; 
20C0   A2 2E      POPDO     LDX #$2E	; GET BASE ADDR TO PUT INFO BACK INTO
20C2   A0 09                LDY #$09	;   AND # OF BYTES TO RESTORE
20C4   4C 5B 28             JMP POPB0	; * PJMP * POP THEM OFF AND RETURN
            ; 
            ; 'IF' COMMAND PROCESSOR (CONDITIONAL GOTO)
            ; THROW IN THE 'QUIT' COMMAND HERE ALSO
            ; 
                  QUIT	= START
            ; 
            ; in WW source of '77, JSR PUSHA is here; not in Aresco binary --dhh
            ; 
20C7   85 23                STA $23	; not in Aresco code
20C9   20 B1 29             JSR GSPNOR	; MOVE TO NEXT NON-BLANK
20CC   C9 28                CMP #$28	; '('
20CE   F0 02                BEQ IFCNT1	; YES, BRANCH
20D0   00                   BRK		; NO, TRAP
20D1   E7                   .BYTE IFSYN	; SYNTAX ERROR IN 'IF' OR 'ON' CMD
20D2   20 1C 28   IFCNT1    JSR PUSHJ	; NOW EVALUATE WHAT'S IN PARENS
20D5   03 2A                .WORD EVALM1
20D7   A5 2B                LDA CHAR	; GET TERMINATOR
20D9   C9 29                CMP #$29	; ')'
20DB   F0 02                BEQ IFCNT2	; YES, CONTINUE
20DD   00                   BRK		;NO, TRAP
20DE   FA                   .BYTE PMATCH	; ?PARENTHESIS MISMATCH
20DF   20 92 29   IFCNT2    JSR GETC	; MOVE PAST RIGHT PAREN
20E2   A5 81                LDA FLCSGN	; GET THE SIGN OF THE EXPRESSION
20E4   30 2B                BMI IFXCT	; IF NEGATIVE, GO DO IT NOW
20E6   10 03                BPL IF3	; OTHERWISE, LOOK FOR COMMA
20E8   20 92 29   IFCOM     JSR GETC	; GET A CHAR
20EB   A5 2B      IF3       LDA CHAR
20ED   C9 2C                CMP #$2C	; ','
20EF   F0 0B                BEQ IF1	; BRANCH IF YES
20F1   C9 3B                CMP #$3B	; ';'
20F3   F0 31                BEQ IFNOP	; YES, CONTINUE WITH NEXT CMD ON THIS LINE
20F5   C9 0D                CMP #$0D	; CR?
20F7   D0 EF                BNE IFCOM	; NO, KEEP LOOKING ('JSR POPA' in betw. orig)
20F9   20 4B 28             JSR POPJ	; YES, THEN EXIT 'PROCESS'
20FC   20 92 29   IF1       JSR GETC	; MOVE PAST THE COMMA
20FF   A9 00                LDA #$00	;   from here, the Aresco code is wildy
2101   A2 03                LDX #$03	; different from the original Program Exchange.  ...
2103   15 81      L2103     ORA $81,X
2105   CA                   DEX		; (this whole section is just 'JSR ZRFAC1', so
2106   10 FB                BPL L2103	;  leaving the generic label alone)
2108   09 00                ORA #$00	; ... to here.  --dhh
210A   F0 05                BEQ IFXCT	; BRANCH IF FAC1=0
210C   20 CB 2C             JSR L2CCB	; SET IT TO ZERO, THIS TIME FOR SURE
210F   30 DA                BMI IF3	; UNCONDITIONAL BRANCH
2111   20 BC 25   IFXCT     JSR GETLNS	; GO GET THE LINE NUMBER
2114   08                   PHP		; SAVE PROCESSOR FLAGS
2115   20 FE 26             JSR EATECM	; NOW EAT UNTIL THE END OF A COMMAND
2118   28                   PLP		; GET FLAGS BACK
2119   70 0B                BVS IFNOP	; BRANCH IF NO LINE NUMBER GIVEN
211B   08                   PHP		; SAVE THEM AGAIN
211C   A5 23                LDA IFONSW	;   is 'JSR POPA' in orig.
211E   C9 4F                CMP #$4F	; 'O'
2120   F0 07                BEQ IFDO1	; YES, GO 'DO' THE LINE
2122   28                   PLP		; ADJUST STACK
2123   4C F5 22             JMP GOTO1	; NO, 'IF' CMD, THEN 'GOTO' LINE
2126   4C 02 23   IFNOP     JMP PROC	; ADJUST STACK (then 'JMP PROC' in orig...)
2129   68         IFDO1     PLA		; GET STATUS SAVED AFTER 'GETLN' CALL
212A   AA                   TAX		; SAVE IN THE X REGISTER
212B   20 1C 28             JSR PUSHJ	; NOW PERFORM THE 'DO' OF THE LINE OR GROUP
212E   B6 21                .WORD DO1
2130   4C 02 23             JMP PROC	; AND THEN CONTINUE PROCESSING ON THIS LINE

                  IF	= ON		; BOTH COMMANDS HAVE COMMON ENTRY POINT

            ; MODIFY CMD PROCESSOR: 'MODIFY' A LINE OF THE USER'S PROGRAM

2133   20 BC 25   MODIFY    JSR GETLNS	; GET THE LINE NUMBER SPECIFIED
2136   70 02                BVS BADMOD	; BRANCH IF 00.00
2138   D0 02                BNE MODNOK	; BRANCH IF GG.LL
213A   00         BADMOD    BRK		; TRAP
213B   E4		    .BYTE MNEXL	; ?MODIFY OF NON-EXISTANT LINE 
213C   20 80 26   MODNOK    JSR FINDLN	; TRY TO FIND THE LINE
213F   90 F9 	  	    BCC BADMOD	; BRANCH IF COULD NOT FIND
2141   20 99 2D 	    JSR CRLF	; OUTPUT A BLANK LINE
2144   20 31 26 	    JSR PRNTLN	; PRINT THE LINE NUMBER
2147   A0 02                LDY #$02	; SET OFFSET TO FIRST CHAR ON LINE
2149   84 35                STY TEXTP2
214B   A9 00                LDA #$00
214D   85 28                STA TXTADR	; INIT POINTERS TO COMBUF
214F   85 2A                STA TEXTP	; 
2151   A9 01                LDA #$01
2153   85 29                STA TXTADR+1
2155   20 B0 28   MNXTC     JSR RNOECH	; GO WAIT FOR THE GUY TO TYPE A CHAR
2158   C9 0A                CMP #$0A	; LINE FEED?
215A   F0 25                BEQ MLOOK1	; YES, THEN GO FEED TO END OF LINE
215C   C9 1B                CMP ALTCHR	; ALTMODE?
215E   F0 1E                BEQ MLOOK	; YES, THEN PICK UP SEARCH CHAR
2160   C9 7F                CMP RUBCHR	; RUBOUT
2162   F0 07                BEQ MNOECH	; YES, THEN DON'T ECHO
2164   C9 5F                CMP LINCHR	; WAS CHAR THE 'LINE-DELETE' CHAR?
2166   F0 03                BEQ MNOECH	; BRANCH IF IT IS, DO NOT ECHO
2168   20 02 29             JSR PRINTC	; ECHO THE CHARACTER
216B   20 2D 29   MNOECH    JSR PACKC1	; PACK CHAR INTO COMBUF
216E   C9 0D                CMP #$0D	; WAS CHAR A CARRIAGE RETURN?
2170   D0 E3                BNE MNXTC	; NO, THEN PICK UP NEXT CNE
2172   20 9E 2D   MENDL     JSR OUTLF	; FOLLOW WITH A LINE FEED
2175   A9 01                LDA #$01	; SET COMBUF OFFSET
2177   85 2A                STA TEXTP	; FOR 'INSERT'
2179   E6 20                INC DEBGSW	; DISABLE TRACE FOR INSERT
217B   4C 7C 20             JMP REPLIN	; AND GO REPLACE OLD LINE WITH EDITED LINE

217E   20 B0 28   MLOOK     JSR RNOECH	; SILENTLY GET THE SEARCH CHAR
2181   85 25      MLOOK1    STA MSCHAR	; STORE SEARCH CHAR
2183   A4 35      MLOOK2    LDY TEXTP2	; GET POINTER TO TEXT IN MEMORY
2185   B1 33                LDA (TXTAD2),Y	; GET CHAR
2187   C8                   INY		; POINT TO NEXT
2188   84 35                STY TEXTP2	; 
218A   20 2D 29             JSR PACKC1	; PACK THE CHAR
218D   20 02 29             JSR PRINTC	; ECHO IT
2190   C5 25                CMP MSCHAR	; WAS IT THE SEARCH CHAR?
2192   F0 C1                BEQ MNXTC	; BRANCH IF YES
2194   C9 0D                CMP #$0D	; CR?
2196   F0 DA                BEQ MENDL	; YES, THEN THAT'S IT
2198   D0 E9                BNE MLOOK2	; NO, THEN KEEP LOOKING
;
;        'DO' RECURSIVE OPERATE, EXECUTE, OR CALL
;
219A   20 1C 28   DO        JSR PUSHJ	; CALL THE 'DO' SUBROUTINE
219D   A2 21                .WORD DOX
219F   4C 02 23             JMP PROC	; AND CONTINUE PROCESSING
21A2   A9 00      DOX       LDA #$00	; ZERO OUT THE STRING VARIABLE SWITCH
21A4   85 3B                STA STRSWT
21A6   20 BC 25             JSR GETLNS	; GO GET THE LINE NUMBER TO 'DO'
21A9   08                   PHP		; SAVE FLAGS FROM 'GETLNS'
21AA   A5 3B                LDA STRSWT	; WAS EXPRESSION A STRING VARIABLE?
21AC   F0 04                BEQ DOX1	; BRANCH IF NOT, PRESS ON
21AE   28                   PLP		; YES, THEN ADJUST STACK
21AF   4C 97 20             JMP DOSTR	; * PJMP * DO CODE STORED IN STRING, RET
21B2   28         DOX1      PLP		; RESTORE FLAGS FROM 'GETLNS'
21B3   4C B9 21             JMP DO2	;   AND ENTER ROUTINE
21B6   8A         D01       TXA		; ENTER HERE WITH STATUS FROM 'GETLN' IN X
21B7   48                   PHA		; SAVE ON STACK
21B8   28                   PLP		; MAKE CURRENT PROCESSOR STATUS
21B9   08         DO2       PHP		; SAVE PROCESSOR STATUS ACROSS THE SAVE
21BA   20 B9 20             JSR PUSHDO	; SAVE IMPORTANT STUFF ON STACK FOR LATER
21BD   28                   PLP		; GET THE FLAGS BACK
21BE   70 17                BVS DOGRP	; BRANCH IF "DO ALL"
21C0   F0 15                BEQ DOGRP	; OR "DO" IS A GROUP
21C2   20 80 26   DOONE     JSR FINDLN	; TRY TO FIND THE LINE TO "DO"
21C5   B0 02                BCS DOCNT1	; BRANCH IF WE FOUND IT
21C7   00                   BRK		; TRAP
21C8   E6 		    .BYTE DONEXL	; ? "DO" OF NON-EXISTANT LINE
21C9   20 25 27   DOCNT1    JSR NEWLIN	; SET UP THE NEW LINE
21CC   20 1C 28             JSR PUSHJ	; AND EXECUTE IT
21CF   FF 22                .WORD PROCES
21D1   20 C0 20   DOCONT    JSR POPDO	; NOW RESTORE IMPORTANT STUFF AS IT WAS
21D4   20 4B 28             JSR POPJ	; AND RETURN
;
;        'DO' COMMAND PROCESSOR
;
21D7   20 80 26   DOGRP     JSR FINDLN	; TRY TO LOCATE SMALLEST LINE OF THE GRP
21DA   A5 51                LDA TGRP	; IS IT THE SAME GRP WE'RE LOOKING FOR?
21DC   C5 2C                CMP GRPNO	
21DE   F0 02                BEQ DOGRP1	; BRANCH IF YES
21E0   00                   BRK		; TRAP
21E1   E5 		    .BYTE DONEXG	: ?"DO" OF NON-EXISTANT GROUP
21E2   A5 51	  DOGRP1    LDA TGRP	; GET THE GROUP NUMBER WE ARE 'DO'ING
21E4   20 31 28             JSR	PUSHA	; SAVE ON STACK
21E7   20 32 27   DOGRPC    JSR NXTLIN	; SET UP POINTERS FOR NEXT LINE
21EA   90 1C                BCC ENDGRP	; BRANCH IF END OF PROGRAM
21EC   20 3F 28             JSR POPA	; GET GROUP NUMBER WE ARE 'DO'ING
21EF   20 31 28             JSR PUSHA	; SAVE IT AGAIN
21F2   09 00                ORA #$00	; ARE WE DOING GROUP ZERO (ALL)?
21F4   F0 04                BEQ DONEXT	; YES, THEN ANY LINE IS OK
21F6   C5 26                CMP PC	; IS THIS LINE OF THE SAME GROUP?
21F8   D0 0E                BNE ENDGRP	; BRANCH IF NOT
21FA   20 1C 28   DONEXT    JSR PUSHJ	; YES, THEN PROCESS THIS LINE
21FD   FF 22                .WORD PROCES
21FF   20 D7 26             JSR EATCR1	; EAT UNTIL A CARRIAGE RETURN
2202   A5 26                LDA PC	; GET THE CURRENT LINE NUMBER
2204   C9 FD                CMP RETCMD	; 'RETURN' COMMAND SEEN?
2206   D0 DF                BNE DOGRPC	; BRANCH IF NOT, CONTINUE
2208   20 3F 28   ENDGRP    JSR POPA	; ADJUST STACK
220B   4C D1 21             JMP DOCONT	; AND RETURN FROM "DO"

            ; "RETURN" AND "RESTORE" COMMANDS

220E   20 B4 29   RETURN    JSR SPNOR	; GET NEXT NON-BLANK
2211   C9 49                CMP #$49	; 'I' IS THIS A 'RESTORE INPUT' (R I)?
2213   F0 0B                BEQ RESINP	; BRANCH IF YES
2215   C9 4F                CMP #$4F	; 'O' IS THIS A 'RESTORE OUTPUT' (R O)?
2217   F0 0E                BEQ RESOUT	; BRANCH IF YES
2219   A9 FD                LDA #RETCMD	; NO, THEN IT MUST BE A "RETURN"
221B   85 26                STA PC	; SET PC TO SPECIAL VALUE
221D   20 4B 28             JSR POPJ	; AND EXIT "PROCESS"

2220   A5 68      RESINP    LDA IDVSAV	; RESTORE INPUT DEVICE # TO WHAT IT WAS
2222   85 66                STA IDEV	;   BEFORE LAST STRING INPUT
2224   4C FF 22             JMP PROCES	;   AND CONTINUE EXECUTING ON THIS LINE
2227   A5 69      RESOUT    LDA ODVSAV	; RESTORE OUTPUT DEVICE # TO WHAT IT WAS
2229   85 67                STA ODEV	;   BEFORE LAST STRING OUTPUT
222B   4C FF 22             JMP PROCES	;   AND CONTINUE EXECUTING ON THIS LINE

            ; "ERASE" COMMAND PROCESSOR

222E   20 B4 29   ERASE     JSR SPNOR	; GO GET NEXT NON-BLANK
2231   A0 00                LDY #$00	; this is not in the 6502 Group/ProgExch
2233   C9 41                CMP #$41	; 'A'   source code of 13-Oct-77   --dhh
2235   F0 23                BEQ EALL	; 	occurs later at $225A
2237   20 BF 25             JSR GETLN	; NO, GO GET THE LINE NUMBER TO ERASE
223A   08                   PHP		; SAVE FLAGS
223B   20 0A 27             JSR PUSHTP	; SAVE TEXT POINTERS
223E   28                   PLP		; GET FLAGS BACK
223F   70 0F                BVS EVAR	; BRANCH IF JUST 'ERASE' WITH NO LINE NO.
2241   F0 2C                BEQ EGRP	; BRANCH IF WE ERASE A GROUP
2243   20 80 26             JSR FINDLN	; NOW TRY AND LOCATE THE SPECIFIED LINE
2246   B0 02                BCS ERCONT	; BRANCH IF WE FOUND IT
2248   00                   BRK		; TRAP
2249   E8  		    .BYTE ENEXL	; ?ERASE OF NON-EXISTANT LINE
224A   20 4B 27   ERCONT    JSR DELETE	; GO ZAP THE LINE
224D   4C 31 20   ERDON     JMP START	; AND GO TO DIRECT COMMAND MODE
2250   A9 FF      EVAR      LDA #EOV	; ERASE ALL THE VARIABLES
2252   91 3E                STA (VARBEG),Y	; BY FLAGGING LIST AS EMPTY
2254   20 11 27             JSR POPTP	; RESTORE TEXT POINTERS
2257   4C 02 23             JMP PROC	; AND CONTINUE PROCESSING THIS LINE
225A   A9 FE      EALL      LDA #EOP	; ERASE PROGRAM TEXT
225C   91 31                STA (PBADR),Y	; EXCEPT GROUP ZERO
225E   A5 40                LDA VARST	; UPDATE VARBEG
2260   85 3E                STA VARBEG
2262   A5 41                LDA VARST+1
2264   85 3F                STA VARBEG+1
2266   A9 FF                LDA #EOV
2268   91 3E                STA (VARBEG),Y	; FLAG VARIABLE LIST AS EMPTY
226A   D0 E1                BNE ERDON	; AND START OVER
226C   20 4B 27   ELINE     JSR DELETE	; DELETE THE LINE
226F   20 18 27   EGRP      JSR TXTINI	; RESET TEXT POINTER TO START OF PROGRAM
2272   20 80 26             JSR FINDLN	; TRY TO FIND THE GROUP
2275   A5 51                LDA TGRP	; GET GROUP NUMBER OF LINE FOUND
2277   C5 2C                CMP GRPNO	; IS IT OF THE GROUP WE ARE DELETING?
2279   F0 F1                BEQ ELINE	; BRANCH IF YES, GO DELETE IT
227B   D0 D0                BNE ERDON	; AND RETURN IF ALL LINES IN GRP DELETED

            ; WRITE CMD PROCESSOR: 'WRITE' OUT PARTS OF THE PROGRAM TEXT

227D   20 BC 25   WRITE     JSR GETLNS	; GO GET THE GROUP TO WRITE
2280   08                   PHP		; SAVE CONDITION CODES
2281   20 0A 27             JSR PUSHTP	; SAVE POSITION ON THIS LINE
2284   E6 20                INC DEBGSW	; DISABLE TRACE
2286   28                   PLP		; GET CONDITION CODES AFTER 'GETLN'
2287   70 2B                BVS WALL	; BRANCH IF 'WRITE ALL'
2289   D0 19                BNE WLINE	; BRANCH IF WE WRITE A SINGLE LINE
228B   20 80 26   WGRP      JSR FINDLN	; TRY TO FIND THE GROUP
228E   A5 51                LDA TGRP	; GET THE GROUP LOCATED IN MEMORY
2290   C5 2C                CMP GRPNO	; IS IT THE ONE WE ARE LOOKING FOR?
2292   F0 02                BEQ WGRP1	; BRANCH IF YES	
2294   00                   BRK		; TRAP
2295   E1		    .BYTE WNEXG	; ?'WRITE' OF NON-EXISTANT GROUP
2296   20 C0 22   WGRP1     JSR WGRPO   ; OUTPUT THE GROUP
2299   20 EB 22   WEXIT     JSR WCRLF	; BLANK LINE
229C   C6 20                DEC DEBGSW	; ENABLE TRACE AGAIN
229E   20 11 27             JSR POPTP	; RESTORE TEXT POINTERS
22A1   4C 02 23             JMP PROC	;   AND CONTINUE PROCESSING ON THIS LINE
22A4   20 80 26   WLINE     JSR FINDLN	; TRY TO FIND THE LINE
22A7   B0 02                BCS WLINE1	; BRANCH IF WE FOUND IT
22A9   00                   BRK		; TRAP
22AA   EA                   NOP		; ?'WRITE' OF NON-EXISTANT LINE (code $EA)
22AB   20 EB 22   WLINE1    JSR WCRLF	; OUTPUT BLANK LINE
22AE   20 CD 22             JSR WONE	; OUTPUT THE SINGLE LINE
22B1   4C 99 22             JMP WEXIT	;   THEN EXIT 'WRITE' 
22B4   20 80 26   WALL      JSR FINDLN	; GO FIND GROUP ZERO (ALWAYS WINS)
22B7   20 C0 22   WALL1     JSR WGRPO	; OUTPUT THIS GROUP
22BA   F0 DD                BEQ WEXIT	; BRANCH IF END OF PROGRAM
22BC   85 51                STA TGRP	; MAKE EXIT GROUP THE GROUP TO OUTPUT
22BE   D0 F7                BNE WALL1	;    AND GO OUTPUT IT
22C0   20 EB 22   WGRPO     JSR WCRLF	; OUTPUT BLANK LINE
22C3   20 CD 22   WGRPO1    JSR WONE	; OUTPUT THIS LINE
22C6   F0 04                BEQ WEXGRP	; BRANCH IF END OF PROGRAM
22C8   C5 51                CMP TGRP	; IS GROUP OF NEXT LINE THE SAME?
22CA   F0 F7                BEQ WGRPO1	; BRANCH IF YES
22CC   60         WEXGRP    RTS		; OTHERWISE RETURN
            ;
22CD   20 31 26   WONE      JSR PRNTLN	; OUTPUT THE LINE NUMBER
22D0   20 92 29   WONEC     JSR GETC	; GET NEXT CHAR
22D3   20 02 29             JSR PRINTC	; OUTPUT IT
22D6   C9 0D                CMP #$0D	; WAS IT THE END OF THE LINE?
22D8   D0 F6                BNE WONEC	; LOOP IF NOT
22DA   A5 67                LDA ODEV	; YES, ARE WE OUTPUTTING TO A STRING?
22DC   30 03                BMI WEOL	; BRANCH IF WE ARE, DON'T FOLLOW WITH $0A
22DE   20 9E 2D             JSR OUTLF	; NO, THEN FOLLOW WITH A LINEFEED
22E1   20 D7 26   WEOL      JSR EATCR1	; YES, POINT TO NEXT LINE
22E4   A4 2A                LDY TEXTP	; LOAD Y WITH OFFSET
22E6   B1 28                LDA (TXTADR),Y	; PICK OF GRP NUMBER OF NEXT LINE
22E8   C9 FE                CMP #EOP	; COMPARE TO END-OF-PROGRAM FLAG
22EA   60         WRET      RTS		; RETURN WITH Z=1 IF END OF PROGRAM
					; RETURN WITH Z=0 IF NOT END OF PROGRAM
22EB   A5 67      WCRLF     LDA ODEV	; ARE WE OUTPUTTING TO A STRING?
22ED   30 FB                BMI WRET	; BRANCH IF WE ARE, DON'T ADVANCE
22EF   4C 99 2D             JMP CRLF	; * PJMP * ELSE OUTPUT A CRLF AND RETURN

            ; MAIN CONTROL AND TRANSFER: 'GOTO' COMMAND

22F2   20 BC 25             JSR GETLNS	; GO GET THE LINE NUMBER
22F5   20 80 26   GOTO1     JSR FINDLN	; NOW GO TRY TO FIND IT
22F8   B0 02                BCS GCONT	; BRANCH IF WE FOUND IT
22FA   00                   BRK		; TRAP
22FB   EB                   .BYTE $EB	; ?GOTO NON-EXISTANT LINE
22FC   20 25 27   GCONT     JSR NEWLIN	; GO SET UP THE NEW LINE
            ;				  * PFALL * INTO PROCESS
22FF   20 92 29   PROCES    JSR GETC	; GET NEXT CHARACTER
2302   A5 2B      PROC      LDA CHAR	; JUST IN CASE CALLED FROM ELSEWHERE
2304   C9 0D                CMP #$0D	; 'CR' END OF LINE?
2306   F0 5B                BEQ PC1	; IF SO, THEN RETURN
2308   20 52 23             JSR GLTEST	; IS CHAR A TERMINATOR?
230B   F0 F2                BEQ PROCES	; IF SO, IGNORE IT
230D   A6 2E                LDX PRILVL	; GET CURRENT SOFTWARE INTERRUPT PRIO LVL
230F   A5 6D                LDA ACTMSK	; GET BYTE THAT INDICATES WHICH CHAN ACTIVE
2311   F0 13                BEQ PROC1	; NONE ALLOWED TO HAPPEN, PRESS ON
2313   3D 9D 35             AND $359D,X	; MASK OUT ANY NOT ALLOWED TO HAPPEN
2316   F0 0E                BEQ PROC1	; BRANCH IF NONE PENDING, PRESS ON
2318   25 6E                AND EVMASK	; NOW SEE IF ANY EVENT PENDING ON CHANNEL
231A   F0 0A                BEQ PROC1	; BRANCH IF NONE PENDING, PRESS ON
231C   A2 08                LDX #$08	; WE HAVE AN EVENT TO SERVICE (AT LEAST 1)
231E   DD A6 35   PRILOP    CMP $35A6,X	; FIND HIGHEST PRIORITY ONE TO SERVICE
2321   B0 43                BCS EVNTDO	; BRANCH WHEN WE HAVE IT
2323   CA                   DEX		; NOT THIS LEVEL, TRY LOWER
2324   D0 F8                BNE PRILOP	;   AND LOOP UNTIL WE FIND IT
            ;				  *** SHOULD NEVER FALL OUT THIS END! ***
2326   A5 2B      PROC1     LDA CHAR	; GET CHARACTER WHICH STARTED COMMAND
            ;				  handwritten note here in ProgExch code:
            ;				    " --* JMP EXIT"  --dhh
2328   48                   PHA		; TEMPORARILY SAVE COMMAND CHARACTER
2329   20 52 23   PTERM1    JSR GLTEST	; TERMINATOR?
232C   F0 05                BEQ PTERM2	; BRANCH IF YES
232E   20 92 29             JSR GETC	; OTHERWISE, SKIP OVER REST OF COMMAND NAME
2331   10 F6                BPL PTERM1	; UNCONDITIONAL BRANCH
2333   68         PTERM2    PLA		; GET 1ST CHAR OF CMD NAME BACK AGAIN
2334   A2 00                LDX #$00	; INIT TABLE OFFSET TO ZERO
2336   BC 49 35   NXTCOM    LDY $3549,X	; GET THE COMMAND CHARACTER
2339   F0 26                BEQ ILLCOM	; ZERO ENDS THE TABLE
233B   DD 49 35             CMP $3549,X	; IS THIS CHARACTER THE COMMAND WE WANT?
233E   F0 03                BEQ GOTCOM	; BRANCH IF YES
2340   E8                   INX		; NO, POINT TO NEXT ONE
2341   D0 F3                BNE NXTCOM	; UNCONDITIONAL LOOP FOR NEXT ONE
2343   BC 6F 35   GOTCOM    LDY $356F,X	; GET LOW ORDER ADDR OF ROUTINE
2346   8C 50 23             STY $2350	; SAVE IN DUMMY JUMP
2349   BC 5D 35             LDY $355D,X	; GET HIGH ORDER ADDR OF ROUTINE
234C   8C 51 23             STY $2351	; SAVE IN DUMMY JUMP
234F   4C 00 00             JMP $0000	; DISPATCH TO COMMAND ROUTINE

            ; GLTEST EXITS WITH Z SET IF CHARACTER IN THE ACCUMULATOR
            ; IS A TERMINATOR (SPACE, COMMA, OR SEMI-COLON).

2352   C9 20      GLTEST    CMP #$20	; SPACE?
2354   F0 0A                BEQ RTS2	; RETURN IF YES
2356   C9 2C                CMP #$2C	; COMMA?
2358   F0 06                BEQ RTS2	; RETURN IF YES
235A   C9 3B      TSTEOC    CMP #$3B	; SEMI-COLON?
235C   F0 02                BEQ RTS2	; RETURN IF YES
235E   C9 0D                CMP #$0D	; CARRIAGE RETURN?
2360   60         RTS2      RTS		; RETURN WITH Z=1 IF ANY OF THESE
2361   00         ILLCOM    BRK		; TRAP
2362   FD 		    .BYTE $FD	; ?UNRECOGNIZABLE COMMAND
2363   20 4B 28	  PC1	    JSR POPJ	; EXIT 'PROCESS'

            ; ROUTINE TO PERFORM A 'DO' OF A SPECIFIED LINE OR GROUP
            ; WHEN AN EXTERNAL EVENT HAPPENS ON A SOFTWARE INTERRUPT CHANNEL.

2366   8A         EVNTDO    TXA		; SAVE X AS IT HAS LVL OF INTERUPT
2367   48                   PHA		;   THEN SET UP RETURN ADDR ON STACK
2368   A9 0C                LDA #$0C	; label EVRET, def. as =PROCX-1
236A   20 31 28             JSR PUSHA	; ALA 'PUSHJ'
236D   A9 23                LDA #$23	; MSB of EVRET address
236F   20 31 28             JSR PUSHA
2372   20 B9 20             JSR PUSHDO	; SAVE IMPORTANT STUFF AT THIS LEVEL
2375   68                   PLA		; GET NEW PRIO LEVEL OF GRP OR LN TO 'DO'
2376   AA                   TAX
2377   86 2E                STX PRILVL	; SET IT AS OUT NEW PRIO LEVEL
2379   BD A6 35             LDA $35A6,X	; GET BIT MASK FOR THIS NEW LEVEL
237C   49 FF                EOR #$FF	; COMPLIMENT TO MAKE 'AND' MASK
237E   08                   PHP		; SAVE STATE OF 'I' BIT IN CASE IRQS ARE ON
237F   78                   SEI		; DISABLE IRQ GRANTING
2380   25 6E                AND EVMASK	;   WHILE WE UPDATE EVENT MASK
2382   85 6E                STA EVMASK
2384   28                   PLP		; WE CAN ALLOW IRQS AGAIN (IF ON)
2385   BD 8B 35             LDA $358B,X	; GET THE GROUP NUMBER TO 'DO'
2388   85 2C                STA GRPNO
238A   BD 94 35             LDA $3594,X	;   AND THE LINE NUMBER
238D   85 2D                STA LINENO
238F   20 05 26             JSR GOTLNO	; NOW SET FLAGS TO DETERMINE WHAT TO 'DO'
2392   70 05                BVS EVDALL	; BRANCH IF WE ARE 'DO'ING ALL
2394   F0 03                BEQ EVDALL	;   OR 'DO' OF A GROUP
2396   4C C2 21             JMP DOONE	; *PJMP * 'DO' 1 LINE, RETURN TO 'EVRET'
2399   4C D7 21   EVDALL    JMP DOGRP	; *PJMP * 'DO' A GROUP, RETURN TO 'EVRET'
;
            ; 'TYPE - ASK COMMAND PROCESSOR'
;
239C   20 76 2C   TDUMP     JSR VARINI	; INIT POINTER TO START OF VARIABLE LIST
239F   20 99 2D   TDNEXT    JSR CRLF	; START ON NEW LINE
23A2   A0 00                LDY #$00	; POINT TO VARIABLE NAME
23A4   84 3B                STY STRSWT	; MAKE SURE STRING SWITCH IS OFF
23A6   B1 37                LDA (VARADR),Y	; PICK UP THE VARIABLE NAME
23A8   C9 FF                CMP #EOV	; END OF VARIABLE LIST?
23AA   F0 52                BEQ JTASK4	; BRANCH IF END OF VARIABLE LIST
23AC   C9 FC                CMP #STRMRK	; STRING VARIABLE?
23AE   D0 05                BNE TDCONT	; BRANCH IF NOT, PRESS ON
23B0   85 3B                STA STRSWT	; YES, THEN FLAG IT
23B2   C8                   INY		;   AND MOVE PAST MARKER, POINT TO NAME
23B3   B1 37                LDA (VARADR),Y	; AND PICK UP THE NAME
23B5   20 E7 23   TDCONT    JSR PRTVNM	; PRINT THE VARIABLE'S NAME
23B8   A5 3B                LDA STRSWT	; IS THIS VARIABLE A STRING VARIABLE?
23BA   D0 45                BNE TPSTR	; BRANCH IF YES, DO SPECIAL OUTPUT
23BC   A9 28                LDA #$28	; '(' AND THEN START OF SUBSCRIPT
23BE   20 02 29             JSR PRINTC
23C1   A0 01                LDY #$01	; POINT TO SUBSCRIPT
23C3   B1 37                LDA (VARADR),Y	; GET HIGH ORDER SUBSCRIPT
23C5   85 81                STA M1	; SAVE IN FAC1
23C7   C8                   INY		; POINT TO LOW ORDER SUBSCRIPT
23C8   B1 37                LDA (VARADR),Y	; GET IT
23CA   85 82                STA M1+1
23CC   20 4D 32             JSR FLT16	; FORM A FLOATING POINT NUMBER
23CF   20 5E 26             JSR OUTLN0	;   AND OUTPUT IT
23D2   A9 29                LDA #$29	; ')' CLOSING PAREN
23D4   20 02 29             JSR PRINTC
23D7   A9 3D                LDA #$3D	; '=' PUT IN AN EQUALS FOR FORM
23D9   20 02 29             JSR PRINTC
23DC   20 AE 2C             JSR FETVAR	; GET THE VARIABLE'S VALUE INTO FLAC
23DF   20 1F 33             JSR FPRNT	; PRINT IT
23E2   20 7F 2C             JSR NXTVAR	; POINT TO NEXT VARIABLE IN THE LIST
23E5   D0 B8                BNE TDNEXT	; UNCONDITIONALLY LOOP FOR MORE
;
            ; ROUTINE TO PRINT OUT A VARIABLE'S NAME
;
23E7   48         PRTVNM    PHA		; SAVE COMPOSITE FORM
23E8   4A                   LSR A	; EXTRACT ALPHA PART
23E9   4A                   LSR A
23EA   4A                   LSR A
23EB   09 40                ORA #$40	; FORM ASCII
23ED   C9 46                CMP #$46	; 'F', ACTUALLY '&', SINCE 'F' IS ILLEGAL
23EF   D0 02                BNE TPNAM	; NOT SPECIAL, SO PRINT IT
23F1   A9 26                LDA #$26	; '&' PRINT A '&' AS SPECIAL VARIB NAME
23F3   20 02 29   TPNAM     JSR PRINTC	;   AND PRINT IT
23F6   68                   PLA		; GET BACK HASH
23F7   29 07                AND #$07	; EXTRACT NUMBER
23F9   09 30                ORA #$30	; FORM ASCII
23FB   4C 02 29             JMP PRINTC	; * PJMP * PRINT THE VARIB # THEN RETURN
23FE   4C D3 24   JTASK4    JMP TASK4	; BRANCH AID
;
            ; HERE TO TYPE OUT A STRING VARIABLE
;
2401   A9 24      TPSTR     LDA #$24	; '$' INDICATE IT'S A STRING VARIABLE
2403   20 02 29             JSR PRINTC
2406   A9 3D                LDA #$3D	; '=' DONT PRINT A SUBSCRIPT ON A $ VARIB
2408   20 02 29             JSR PRINTC
240B   A9 22                LDA #$22	; '"' DELIMIT STRING WITH QUOTES
240D   20 02 29             JSR PRINTC
2410   A0 02                LDY #$02	; POINT TO STRING LENGTH
2412   B1 37                LDA (VARADR),Y	; PICK UP THE STRING LENGTH
2414   85 3C                STA VSIZE	; SAVE IT
2416   C8                   INY		; POINT TO FIRST BYTE OF STRING
2417   98                   TYA		; NOW UPDATE 'VARADR' TO BASE ADDR OF $
2418   20 81 2C             JSR UPDVAR
241B   A0 00                LDY #$00	; POINT TO FIRST BYTE OF STRING
241D   98         TPNXTC    TYA		; SAVE OFFSET
241E   48                   PHA
241F   B1 37                LDA (VARADR),Y	; GET BYTE FROM STRING
2421   20 02 29             JSR PRINTC	; PRINT THE BYTE
2424   68                   PLA		; RESTORE POINTER
2425   A8                   TAY
2426   C8                   INY		; POINT TO NEXT BYTE
2427   C4 3C                CPY VSIZE	; PRINTED ALL OF STRING YET?
2429   D0 F2                BNE TPNXTC	; BRANCH IF MORE TO PRINT
242B   98                   TYA		; YES, THEN SKIP OVER STRING BY
242C   20 81 2C             JSR UPDVAR	;   UPDATING 'VARADR'
242F   A9 22                LDA #$22	; '"' CLOSE OFF STRING WITH CLOSING QUOTE
2431   20 02 29             JSR PRINTC
2434   4C 9F 23             JMP TDNEXT	; AND DUMP NEXT VARIABLE
2437   4C 9C 23   JTDUMP    JMP TDUMP	; BRANCH AID
;
            ; 'TYPE - ASK COMMAND PROCESSOR'
            ; 
243A   20 1C 28   TASK1     JSR PUSHJ	; GO GET THE VARIABLE
243D   51 2B                .BYTE $51,$2B	; labeled 'GETVAR' in orig source
243F   20 9B 2C             JSR BOMSTV	; BOMB OUT IF A $ VARIABLE IS USED IN 'ASK'
2442   A5 2B                LDA CHAR	; SAVE DELIMITER
2444   48                   PHA		;   ON HARDWARE STACK
2445   E6 24                INC INSW	; FLAG INPUT FROM KEYBOARD
2447   A2 37      ASKAGN    LDX #VARADR	; SAVE THE VARIABLE'S ADDRESS
2449   20 69 28             JSR PUSHB2
244C   20 1C 28             JSR PUSHJ	; NOW GO GET USER SUPPLIED DATA
244F   03 2A                .WORD $032A	; labeled 'EVALM1' in original source
            ; 
            ; original source has LDA #$41 / STA ATSW
            ; with the comment: RESTORE 'ATSW' (SINCE WE MUST BE RECURSIVE!)
            ; the Aresco version of V3D omits this
            ; 
2451   A2 38                LDX #VARADR+1  ; RESTORE VARIABLE'S ADDRESS
2453   20 59 28             JSR POPB2
2456   A5 2B                LDA CHAR	; GET DELIMITER FROM EVAL
2458   C9 5F                CMP #LINCHR	; WAS IT 'LINE-DELETE' CHARACTER?
245A   D0 0B                BNE STODAT	; BRANCH IF NOT, STORE VALUE AWAY
245C   A5 66                LDA IDEV	; YES, IS THE INPUT DEVICE
245E   C5 6A                CMP CONDEV	;   THE CONSOLE?
2460   D0 E5                BNE ASKAGN	; BRANCH IF NOT, ASK AGAIN
2462   20 99 2D             JSR CRLF	; YES, ADVANCE A LINE
2465   10 E0                BPL ASKAGN	;   AND ASK AGAIN
2467   20 A1 2C   STODAT    JSR PUTVAR	; PLACE DATA IN VARIABLE
246A   C6 24                DEC INSW	; FLAG INPUT FROM CORE AGAIN
246C   68                   PLA		; GET DELIMITER BACK AGAIN
246D   85 2B                STA CHAR
246F   10 13                BPL TASK	; UNCONDITIONALLY CONTINUE PROCESSING
            ; 
2471   20 92 29   TFORM     JSR GETC	; MOVE PAST '%'
2474   20 BC 25             JSR GETLNS	; GET GG.SS
2477   A5 2C                LDA GRPNO	; GET GG
2479   85 8F                STA M	; SAVE AS NUMBER BEFORE DECIMAL POINT
247B   A5 2D                LDA LINENO	; GET SS
247D   85 90                STA N	; SAVE AS NUMBER AFTER DECIMAL POINT
247F   4C 84 24             JMP TASK	;   AND CONTINUE PROCESSING
            ; 
2482   85 22      TYPE      STA ATSW	; FLAG WHICH ONE IT IS
2484   A9 00      TASK      LDA #$00	; ENABLE THE TRACE
2486   85 20                STA DEBGSW
2488   20 B4 29             JSR SPNOR	; LOOK FOR NEXT NON-BLANK
248B   C9 24                CMP #$24	; '$'
248D   F0 A8                BEQ JTDUMP	; DUMP OUT THE VARIABLE LIST
248F   C9 25                CMP #$25	; '%' FORMAT CONTROL?
2491   F0 DE                BEQ TFORM	; BRANCH IF YES
2493   C9 21                CMP #$21	; '!' SEE IF SPECIAL
2495   F0 32                BEQ TCRLF	; GIVE OUT A CARRIAGE RETURN-LINE FEED
2497   C9 23                CMP #$23	; '#'
2499   F0 33                BEQ TCR	; CARRIAGE RETURN ONLY
249B   C9 22                CMP #$22	; '"'
249D   F0 39                BEQ TQUOT	; TYPE OUT A QUOTED STRING
249F   C9 2C                CMP #$2C	; ','
24A1   F0 30                BEQ TASK4	; IGNORE IN CASE USER WANTS IT TO LOOK PRETTY
24A3   C9 3B                CMP #$3B	; ';' END OF COMMAND?
24A5   F0 4A                BEQ TPROC	; YES, THEN BRANCH
24A7   C9 0D                CMP #$0D	; 'CR' END OF LINE?
24A9   F0 3F                BEQ TPC1	; YES, THEN GO HANDLE IT
24AB   A5 22                LDA ATSW	; NOT SPECIAL CHAR, GET COMMAND SWITCH
24AD   C9 41                CMP #$41	; 'A' WHICH COMMAND ARE WE DOING?
24AF   F0 89                BEQ TASK1	; BRANCH IF 'ASK', AS IT DIFFERS
24B1   20 1C 28             JSR PUSHJ	; CALL 'EVAL' TO EVALUATE THE EXPRESSION
24B4   06 2A                ASL TEXTP	; this is likely data, point to 'EVAL'

            ; original source has LDA #$54 / STA ATSW here,
            ; with the comment: RESTORE 'ATSW' (SINCE WE MUST BE RECURSIVE!)
            ; the Aresco version of V3D omits this

24B6   20 1F 33             JSR FPRNT	; GO OUTPUT IT
24B9   A5 2B                LDA CHAR	; GET TERMINATOR FROM 'EVAL'
24BB   C9 29                CMP #$29	; ')' SO "TYPE 3)" DOESN'T DIE!
24BD   F0 14                BEQ TASK4	; FLUSH IF WE DON'T LIKE IT
24BF   C9 3D                CMP #$3D	; '=' ALSO FLUSH OTHER NASTIES
24C1   F0 10                BEQ TASK4
24C3   C9 2E                CMP #$2E	; '.'
24C5   F0 0C                BEQ TASK4
24C7   D0 BB                BNE TASK	; OTHERWISE, CONTINUE PROCESSING
            ; 
24C9   20 99 2D   TCRLF     JSR CRLF	; OUTPUT A CR FOLLOWED BY A LF
24CC   10 05                BPL TASK4	; UNCONDITIONAL BRANCH
24CE   A9 0D      TCR       LDA #$0D	; 'CR' OUTPUT A CARRIAGE RETURN
24D0   20 02 29             JSR PRINTC
24D3   20 92 29   TASK4     JSR GETC	; SKIP OVER THIS CHARACTER
24D6   10 AC                BPL TASK	; UNCONDITIONALLY CONTINUE PROCESSING
            ;
24D8   E6 20      TQUOT     INC DEBGSW	; DISABLE TRACE SO LITERAL ONLY PRINTS ONCE
24DA   20 92 29   TQUOT1    JSR GETC	; GET NEXT CHAR
24DD   C9 22                CMP #$22	; '"' CLOSING QUOTE?
24DF   F0 F2                BEQ TASK4	; BRANCH IF YES
24E1   C9 0D                CMP #$0D	; 'CR' END OF LINE?
24E3   F0 05                BEQ TPC1	; BRANCH IF YES (IT TERMINATES STRING)
24E5   20 02 29             JSR PRINTC	; OTHERWISE, PRINT THE CHARACTER
24E8   10 F0                BPL TQUOT1	; UNCONDITIONALLY LOOP UNTIL DONE
24EA   A9 00      TPC1      LDA #$00	; ENABLE TRACE JUST IN CASE
24EC   85 20                STA DEBGSW
24EE   4C 63 23   FPC1      JMP PC1	; EXIT 'PROCESS'
24F1   4C FF 22   TPROC     JMP PROCES	; CONTINUE PROCESSING ON THIS LINE
;
            ; 'FOR' LOOP ITERATION COMMAND
;
24F4   20 1C 28             JSR PUSHJ	; GO GET THE VARIABLE
24F7   51 2B                .BYTE $51, $2B	; 'GETVAR'
24F9   A5 2B                LDA CHAR	; GET TERMINATOR
24FB   C9 3D                CMP #$3D	; '='
24FD   F0 02                BEQ FOR2	; BRANCH IF YES
24FF   00                   BRK		; NO, TRAP
2500   F3                   .BYTE $F3	; ?NO '=' IN 'FOR' OR 'SET'
2501   A2 37      FOR2      LDX #VARADR	; SAVE THE ADDRERSS OF THE VARIABLE
2503   A0 05                LDY #$05	;   AND ITS PROPERTIES
2505   20 6B 28             JSR PUSHB0	;   ON STACK
2508   20 1C 28             JSR PUSHJ	; CALL 'EVAL' TO EVALUATE RIGHT HAND
250B   03 2A                .BYTE $03, $2A	; (EVALM1)       SIDE OF '='
250D   A2 3B                LDX #VARADR+4	; GET ADDR OF VARIB BACK AGAIN
250F   A0 05                LDY #$05
2511   20 5B 28             JSR POPB0
2514   20 9B 2C             JSR BOMSTV	; BOMB OUT IF LOOP COUNTER IS STR. VARIB.
2517   20 A1 2C             JSR PUTVAR	; NOT A STRING, SO STORE INITIAL VALUE
251A   A5 2B                LDA CHAR	; GET THE EXPRESSION TERMINATOR
251C   C9 2C                CMP #$2C	; ',' COMMA?
251E   F0 10                BEQ FINCR	; BRANCH IF IT'S A 'FOR' COMMAND
2520   00         BTFOR     BRK		; TRAP
2521   F2                   .BYTE $F2	; ?BAD TERMINATOR IN 'FOR'
;
            ; 'SET' COMMAND
;
            ; ProgExch version has 20 84 19   SET1   JSR GETC   ;SKIP OVER COMMA
            ; as first line of this section
;
2522   20 1C 28   SET       JSR PUSHJ	; CALL 'EVAL' TO EVALUATE EXPRESSION
2525   03 2A                .BYTE $03,$2A	; 'EVAL'
2527   A5 2B                LDA CHAR	; GET TERMINATOR
2529   C9 2C                CMP #$2C	; ',' COMMA?
252B   F0 F5                BEQ SET	; BRANCH IF YES, LOOP FOR ANOTHER EXPRESS.
252D   4C 02 23             JMP PROC	; NO. ALL DONE, CONTINUE ON THIS LINE
;
            ; there is a handwritten note here: 'Best cmmd exit points $1304'
            ; ($2302 in this Aresco version code)
;
;
            ; 'FOR' COMMAND PROCESSING
;

2530   A2 37      FINCR     LDX #VARADR	; SAVE THE ADDR OF THE LOOP VARIB ON STACK
2532   20 69 28             JSR PUSHB2
2535   20 1C 28             JSR PUSHJ	; GO GET THE INCREMENT
2538   03 2A                .BYTE $03,$2A	; 'EVALM1'
253A   A5 2B                LDA CHAR	; GET TERMINATOR
253C   C9 2C                CMP #$2C	; ',' DID WE GET AN INCREMENT?
253E   F0 16                BEQ FLIMIT	; YES, GO GET THE UPPER LIMIT OF LOOP
2540   C9 3B                CMP #$3B	; ';' WAS NO INCREMENT SPECIFIED?
2542   F0 06                BEQ FINCR1	; BRANCH IF NO INCREMENT GIVEN
2544   C9 0D                CMP #$0D	; 'CR' CARRIAGE RETURN?
2546   D0 D8                BNE BTFOR	; NO, THEN BAD TERMINATOR
2548   00                   BRK		; YES, TRAP
2549   F1 		    .BYTE $F1	; ?USELESS 'FOR' LOOP
254A   A2 FB      FINCR1    LDX #$FB	; GET NEGATIVE OF NUMBER OF BYTES
254C   B5 A0      FI1C      LDA $A0,X	; GET NEXT BYTE
254E   20 31 28             JSR PUSHA	; PUSH IT ON STACK
2551   E8                   INX		; POINT TO NEXT ONE
2552   30 F8                BMI FI1C	;   AND LOOP UNTIL ALL PUSHED
2554   10 08                BPL FSHORT	; UNCONDITIONAL BRANCH
2556   20 79 28   FLIMIT    JSR PHFAC1	; SAVE INCREMENT ON STACK
2559   20 1C 28             JSR PUSHJ	; NOW EVALUATE THE UPPER LIMIT
255C   03 2A                .BYTE $03,$2A	; 'EVALM1'
255E   20 79 28   FSHORT    JSR PHFAC1	; SAVE UPPER LIMIT ON STACK AND ENTER LOOP
            ; 
            ; 'LOOP PROCESSOR FOR "FOR" COMMAND'
            ; 
2561   20 0A 27   FCONT     JSR PUSHTP	; NOW SAVE THE TEXT POINTERS ON STACK
2564   A5 26                LDA PC	; SAVE PC ACROSS CALL
2566   20 31 28             JSR PUSHA
2569   20 1C 28             JSR PUSHJ	; NOW EXECUTE THE REST OF THE LINE
256C   FF 22                .BYTE $FF,$22	; 'PROCES'
256E   20 3F 28             JSR POPA	; SET PC BACK
2571   85 73                STA ITEMP1	; SAVE IT IN TEMPORARY
2573   20 11 27             JSR POPTP	; SAVE POINTERS FOR POSSIBLE RE-ENTRY
2576   20 A5 28             JSR PLTMP	; RESTORE UPPER LOOP LIMIT INTO TEMPORARY
2579   20 C3 2C             JSR POPIV	; RESTORE INCREMENT AND VARIABLE ADDR
257C   A5 26                LDA PC	; GET PC
257E   C9 FD                CMP #RETCMD	; WAS A 'RETURN' COMMAND JUST EXECUTED?
2580   F0 22                BEQ FORXIT	; BRANCH IF YES, THEN EXIT THE LOOP NOW!
2582   A5 7C                LDA M2	; GET THE SIGN OF THE INCREMENT (+ OR -)
2584   08                   PHP		; SAVE STATUS ON STACK FOR LATER
2585   20 BB 2C             JSR PUSHIV	; SAVE AGAIN FOR POSSIBLE REPEAT OF LOOP
2588   20 AE 2C             JSR FETVAR	; GO GET THE VARIABLE'S CURRENT VALUE
258B   20 79 32             JSR FADD	; ADD THE INCREMENT TO FLAC
258E   20 A1 2C             JSR PUTVAR	; STORE AS NEW LOOP COUNTER VALUE
2591   20 8F 28             JSR PHTMP	; SAVE TEMPORARY ON STACK
2594   20 9A 28             JSR PLFAC2	; PLACE INTO FAC2
2597   20 73 32             JSR RTSN	; SUBTRACT COUNTER FROM UPPER LIMIT
259A   28                   PLP		; GET SIGN OF THE INCREMENT
259B   30 0E                BMI CNTDWN	; BRANCH IF NEGATIVE, WE ARE COUNTING DOWN
259D   A5 81                LDA FLCSGN	; GET THE SIGN OF THE NUMBER
259F   10 10                BPL MORFOR	; BRANCH IF REPEAT NECESSARY
25A1   20 C3 2C   FOREND    JSR POPIV	; CLEAN UP STACK
25A4   A5 73      FORXIT    LDA ITEMP1	; RESTORE PC
25A6   85 26                STA PC	;   IN CASE 'RETURN' ENCOUNTERED
25A8   20 4B 28             JSR POPJ	; EXIT 'FOR' COMMAND
25AB   A5 81      CNTDWN    LDA FLCSGN	; ARE WE LESS THAN THE LOOP LIMIT?
25AD   F0 02                BEQ MORFOR	; NO, THEN KEEP GOING
25AF   10 F0                BPL FOREND	; YES, THEN THAT'S ALL
25B1   20 8F 28   MORFOR    JSR PHTMP	; PLACE UPPER LIMIT BACK ON THE STACK
25B4   10 AB                BPL FCONT	; UNCONDITIOANALLY REPEAT LOOP
            ; 
            ; 		LINE NUMBER MANIPULATION ROUTINES
            ; 
            ; "GETLN" GET A LINE NUMBER FROM PROGRAM TEXT.
            ; RETURNS WITH V=1 IF "ALL" (00.00), OTHERWISE
            ; IT RETURNS WITH Z=1 IF GROUP NUMBER ONLY (GG.00)
            ; AND Z=0 IF INDIVIDUAL LINE NUMBER (GG.LL).
            ; 
25B6   20 27 34   GETLNC    JSR FINP	; ONLY ALLOW NUMERIC INPUT
25B9   4C DF 25             JMP GETLN1	;   AND ENTER REST OF CODE
25BC   20 B4 29   GETLNS    JSR SPNOR	; GET NEXT NON-BLANK
25BF   A9 00      GETLN     LDA #$00	; ASSUME LINE NUMBER IS ZERO
25C1   85 2C                STA GRPNO	
25C3   85 2D                STA LINENO
25C5   A5 2B                LDA CHAR	; GET FIRST CHARACTER OF EXPRESSION?
25C7   C9 2C                CMP #$2C	; ',' IS EXPRESSION NULL?
25C9   F0 3A                BEQ GOTLNO	; BRANCH IF YES, THEN WE HAVE THE NUMBER
25CB   C9 0D                CMP #$0D	; 'CR' ANOTHER FORM OF NULL?
25CD   F0 36                BEQ GOTLNO	; BRANCH IF YES, THEN WE HAVE THE NUMBER
25CF   20 BE 29             JSR TESTN	; DOES EXPRESSION BEGIN WITH A NUMBER?
25D2   B0 06                BCS GETLNX	; BRANCH IF NOT, THEN MUST BE COMPLEX 
25D4   20 A3 2D             JSR GETILN	; CALL INTEGER LINE NUMBER INPUT FOR SPEED
25D7   4C 05 26             JMP GOTLNO	; WE NOW HAVE THE LINE NUMBER
25DA   20 1C 28   GETLNX    JSR PUSHJ	; CALL 'EVAL' TO EVALUATE EXPRESSION
25DD   06 2A                .BYTE $06,$2A	; 'EVAL'
25DF   20 79 28   GETLN1    JSR PHFAC1	; SAVE EXPRESSION VALUE ON STACK
25E2   20 16 26             JSR GETL	; INTEGERIZE AND RANGE CHECK
25E5   85 2C                STA GRPNO	; SAVE AS GROUP NUMBER
25E7   20 39 32             JSR FLOAT	; NOW FLOAT THE GROUP NUMBER
25EA   20 9A 28             JSR PLFAC2	; POP FULL GG.SS INTO FAC2
25ED   20 73 32             JSR RTSN	; SUBTRACT OFF THE GROUP NUMBER
25F0   20 27 26             JSR GMUL10	; MULTIPLY BY 100
25F3   20 27 26             JSR GMUL10
25F6   A2 96                LDX #FHALF	; MOVE CONSTANT .50
25F8   A0 7B                LDY #X2
25FA   20 FF 33             JSR MOVXY
25FD   20 79 32             JSR FADD	; NOW ADD IN THE .50 FOR ROUNDING
2600   20 16 26             JSR GETL	; INTEGERIZE AND RANGE CHECK
2603   85 2D                STA LINENO	; SAVE AS LINE NUMBER (STEP NUMBER)
2605   B8         GOTLNO    CLV		; ASSUME NOT 00.00
2606   A5 2C                LDA GRPNO	; GET GROUP NUMBER
2608   05 2D                ORA LINENO	; 'OR' IN THE LINE NUMBER
260A   F0 07                BEQ GOTALL	; BRANCH IF BOTH ARE ZERO
260C   A5 2C                LDA GRPNO	; GET GROUP NUMBER AGAIN
260E   F0 15                BEQ BADLNO	; BAD LINE NUMBER IS GROUP ONLY IS ZERO
2610   A5 2D                LDA LINENO	; GROUP NUMBER OK, GET LINE (STEP) NO.
2612   60         RTS3      RTS		; RETURN WITH Z=1 IF GROUP ONLY
2613   24 6F      GOTALL    BIT BITV1	; EXIT WITH V=1, (n=1 ??)
2615   60                   RTS
            ; 
            ; 'LINE NUMBER MANIPULATION ROUTINES'
            ; 
2616   20 18 33   GETL      JSR FIX	; FIX THE NUMBER IN FAC1
2619   A5 81                LDA M1	; GET HIGH ORDERS
261B   05 82                ORA M1+1	; SMASH THEM TOGETHER
261D   D0 06                BNE BADLNO	; LINE NUMBER CAN ONLY BE POSITIVE
261F   A5 83                LDA M1+2
2621   C9 64                CMP #$64	; AND < 100 ?
2623   30 ED                BMI RTS3
2625   00         BADLNO    BRK		; TRAP
2626   FC                   .BYTE $FC	; ILLEGAL LINE NUMBER
2627   A2 91      GMUL10    LDX #FTEN	; MOVE 10.0
2629   A0 7B                LDY #X2	;   INTO FAC2
262B   20 FF 33             JSR MOVXY
262E   4C A0 32             JMP FMUL	; * PJMP *  FAC1*FAC2=FAC1
            ; 
            ; 		'PRINTLN - PRINT A LINE NUMBER'
            ; 
            ; "PRINTLN" PRINT A LINE NUMBER TO OUTPUT DEVICE
            ; 
2631   A4 2A      PRNTLN    LDY TEXTP	; GET TEXT POINTER
2633   B1 28                LDA (TXTADR),Y	; GET GROUP NUMBER
2635   D0 05                BNE PRNTL1	; BRANCH IF NOT ZERO
2637   C8                   INY		; DO NOT PRINT GROUP ZERO LINE NUMBERS
2638   C8                   INY
2639   84 2A                STY TEXTP	; POINT TO FIRST CHARACTER IN LINE
263B   60                   RTS		;   AND RETURN

263C   48         PRNTL1    PHA		; SAVE THE GROUP NUMBER FOR LATER
263D   C8                   INY		; POINT TO THE STEP NUMBER
263E   B1 28                LDA (TXTADR),Y	; GET STEP NUMBER
2640   C8                   INY		; MOVE PAST IT
2641   84 2A                STY TEXTP	; SAVE POINTER
2643   20 77 26             JSR PFLT	; FLOAT THE STEP NUMBER
2646   20 11 34             JSR DIV10	; DIVIDE BY 100
2649   20 11 34             JSR DIV10
264C   20 79 28             JSR PHFAC1	; SAVE 00.SS FOR LATER
264F   68                   PLA		; GET THE GROUP NUMBER BACK
2650   20 77 26             JSR PFLT	; FLOAT IT
2653   20 9A 28             JSR PLFAC2	; RESTORE 00.SS INTO FAC2
2656   20 79 32             JSR FADD	; ADD TOGETHER TO FORM GG.SS
					; * PFALL * INTO OUTPUT ROUTINE
2659   A9 02                LDA #$02	; ASSUME TWO DIGITS BEFORE THE DECIMAL PT.
265B   AA                   TAX		;   AND TWO DIGITS AFTER
265C   D0 04                BNE OUTLN	; UNCONDITIONAL BRANCH
265E   A9 02      OUTLN0    LDA #$02	; ASSUME TWO DIGITS BEFORE DECIMAL
2660   A2 00                LDX #$00	; ASSUME NO DECIMAL POINT
2662   A8         OUTLN     TAY		; SAVE NUMBER BEFORE DECIMAL IN Y REG
2663   A5 8F                LDA MF	; SAVE OLD FORMAT ON HARDWARE STACK
2665   48                   PHA		; (COULD BE CALLED FROM ERROR TRAP)
2666   A5 90                LDA N
2668   48                   PHA
2669   84 8F                STY M	; STORE NEW FORMAT
266B   86 90                STX N
266D   20 1F 33             JSR FPRNT	; PRINT NUMBER IN TEMPORARY FORMAT
2670   68                   PLA		; RESTORE OLD FORMAT
2671   85 90                STA N
2673   68                   PLA
2674   85 8F                STA M
2676   60                   RTS		; AND RETURN

2677   85 82      PFLT      STA M1+1	; SAVE IN LOW ORDER
2679   A9 00                LDA #$00	; MAKE HIGH ORDER ZERO
267B   85 81                STA M1
267D   4C 4D 32             JMP FLT16	; * PJMP * AND FLOAT IT
            ; 
            ;		'FINDLN - FIND A LINE IN THE STORED PROGRAM'
            ; 
            ; "FINDLN"	RETURNS WITH C=1 IF THE LINE WAS FOUND.
            ; 		TXTAD2 POINTS TO THE GROUP NUMBER,
            ; 		RETURNS WITH C=0 IF THE LINE WAS NOT LOCATED
            ; 		TXTAD2 POINTS TO THE GROUP NUMBER OF THE NEXT HIGHEST NO.
            ; 		(I.E., WHERE YOU WOULD INSERT THIS LINE)
            ; 
2680   A5 2C      FINDLN    LDA GRPNO	; PLACE LINE NUMBER OF LINE WE ARE
2682   85 5A                STA ITMP2H	;   LOOKING FOR INTO TEMPORARY
2684   A5 2D                LDA LINENO	; STEP PART ALSO
2686   85 59                STA ITMP2L
2688   A9 00                LDA #$00	; SET FLAG INDICATING FIRST SEARCH
268A   85 3B                STA FSWIT
268C   85 2A                STA TEXTP	; ALSO RESET TEXT POINTER TO BEGINNING OF
268E   A5 26                LDA PC	;   CURRENT LINE. IS CURR LN DIRECT CMD?
2690   10 05                BPL CHKLIN	; NO, THEN START SEARCHING FOR PRESENT POS
2692   20 18 27   FNDINI    JSR TXTINI	; YES, THEN RESET TEXT POINTERS TO START
2695   E6 3B                INC FSWIT	;   OF PROGRAM, INDICATE LAST SEARCH
2697   A4 2A      CHKLIN    LDY TEXTP	; GET TEXT POINTER
2699   B1 28                LDA (TXTADR),Y	; GET THE GROUP NUMBER
269B   C9 FE                CMP #EOP	; END OF TEXT?
269D   F0 23                BEQ NOFIND	; BRANCH IF YES
269F   85 56                STA ITMP1H	; SAVE FOR COMPARISON
26A1   85 51                STA TGRP	; ALSO SAVE IN CASE THIS ONE IS IT
26A3   C8                   INY		; POINT TO STEP NUMBER
26A4   B1 28                LDA (TXTADR),Y	; GET IT
26A6   85 55                STA ITMP1L	; SAVE IT FOR COMPARISON
26A8   85 52                STA TLINE	; ALSO SAVE IN CASE THIS IS IT
26AA   C8                   INY		; POINT TO FIRST CHAR IN LINE
26AB   84 2A                STY TEXTP	; UPDATE TEXT POINTER
26AD   38                   SEC		; SET UP FOR SUBTRACT
26AE   A5 55                LDA ITMP1L	; GET LOW ORDER
26B0   E5 59                SBC ITMP2L
26B2   85 55                STA ITMP1L	; SAVE FOR LATER
26B4   A5 56                LDA ITMP1H	; NOW HIGH ORDERS
26B6   E5 5A                SBC ITMP2H
26B8   30 0E                BMI FNEXT	; BRANCH IF THE ONE IN THE TEXT AREA IS <
26BA   05 55                ORA ITMP1L	; NOT BIGGER, IS IT EQUAL?
26BC   F0 0F                BEQ FOUNDL	; BRANCH IF WE LOCATE THE LINE
26BE   A5 3B                LDA FSWIT	; LAST SEARCH ATTEMPT?
26C0   F0 D0                BEQ FNDINI	; BRANCH IF NOT, TRY AGAIN FROM START OF
					;   PROGRAM
26C2   18         NOFIND    CLC		; FLAG THE FACT WE DIDN'T FIND IT
26C3   A0 00      FNEXIT    LDY #$00	; RESET POINTER TO GROUP NUMBER
26C5   84 2A                STY TEXTP
26C7   60                   RTS

26C8   20 D0 26   FNEXT     JSR EATCR	; FLUSH TO START OF NEXT LINE
26CB   10 CA                BPL CHKLIN	; UNCONDITIONALLY LOOP FOR MORE
26CD   38         FOUNDL    SEC		; FLAG THE FACT WE FOUND IT
26CE   B0 F3                BCS FNEXIT	; AND RETURN
            ; 
            ; 
            ; 
            ; 		UTILITY ROUTINES FOR TEXT MANIPULATIONS
            ; 
            ; FLUSH TILL A CARRIAGE RETURN
            ; 
26D0   E6 20      EATCR     INC DEBGSW	; DISABLE TRACE
26D2   20 92 29   EATCRC    JSR GETC	; GET NEXT CHAR
26D5   10 02                BPL EATCNT	; UNCONDITIONAL BRANCH
26D7   E6 20      EATCR1    INC DEBGSW	; DISABLE TRACE
26D9   A5 2B      EATCNT    LDA CHAR	; GET THE CHAR
26DB   C9 0D                CMP #$0D	; 'CR' ?
26DD   D0 F3                BNE EATCRC	; BRANCH IF NOT
26DF   A5 28                LDA TXTADR	; YES, CALCULATE THE START OF NEXT LINE
26E1   18                   CLC
26E2   65 2A                ADC TEXTP	; ADD IN THE TEXT POINTER
26E4   85 28                STA TXTADR	; SAVE IN POINTER
26E6   85 33                STA TXTAD2	; AND ALTERNATE POINTER
26E8   A5 29                LDA TXTADR+1	; NOW HIGH ORDER
26EA   69 00                ADC #$00
26EC   85 29                STA TXTADR+1
26EE   85 34                STA TXTAD2+1	; AND ALTERNATE POINTER
26F0   A9 00                LDA #$00	; AND RESET THE POINTER
26F2   85 2A                STA TEXTP
26F4   85 35                STA TEXTP2
26F6   C6 20                DEC DEBGSW	; ALLOW TRACE AGAIN
26F8   60                   RTS		; AND RETURN
            ; 
            ; FLUSH UNTIL END OF COMMAND (SEMI-COLON OR CARRIAGE RETURN)
            ; 
26F9   20 92 29   EATEC1    JSR GETC	; GET NEXT CHAR
26FC   10 02                BPL EATECC	; UNCONDITIONAL BRANCH
26FE   E6 20      EATECM    INC DEBGSW	; TURN OFF TRACE
2700   A5 2B      EATECC    LDA CHAR	; GET THE CHAR
2702   20 5A 23             JSR TSTEOC	; GO SEE IF ';' OR CARRIAGE RETURN
2705   D0 F2                BNE EATEC1	; BRANCH IF NOT
2707   C6 20                DEC DEBGSW	; ENABLE TRACE AGAIN
2709   60                   RTS		; AND RETURN
            ; 
            ; PUSH THE TEXT POINTERS ON THE STACK
            ; 
270A   A2 28      PUSHTP    LDX #TXTADR
270C   A0 04                LDY #$04	; THREE PLUS 'CHAR'
270E   4C 6B 28             JMP PUSHB0	; * PJMP *
            ; 
            ; POP THE TEXT POINTERS OFF THE STACK
            ; 
2711   A2 2B      POPTP     LDX #TXTADR+3
2713   A0 04                LDY #$04
2715   4C 5B 28             JMP POPB0	; * PJMP *
            ; 
            ; INIT TEXT POINTER TO BEGINNING OF TEXT
            ; 
2718   A5 2F      TXTINI    LDA TXTBEG	; POINT TO START OF STORED TEXT
271A   85 28                STA TXTADR
271C   A5 30                LDA TXTBEG+1
271E   85 29                STA TXTADR+1
2720   A9 00                LDA #$00	; INIT OFFSET TO ZERO
2722   85 2A                STA TEXTP
2724   60                   RTS
            ; 
            ; 'NEWLIN' SETUP TEXT POINTERS AND PC FOR NEW LINE NUMBER
            ; 
2725   A5 2C      NEWLIN    LDA GRPNO	; GET THE LINE NUMBER
2727   85 26                STA PC	; STORE IN THE PROGRAM COUNTER
2729   A5 2D                LDA LINENO
272B   85 27                STA PC+1
272D   A0 02                LDY #$02	; POINT TO FIRST CHAR 0N LINE
272F   84 2A                STY TEXTP
2731   60                   RTS		; AND RETURN
            ; 
            ; 'NEWLIN' SETUP TEXT POINTERS AND PC FOR NEXT LINE NUMBER
            ; 
2732   A4 2A      NXTLIN    LDY TEXTP	; GET TEXT POINTER
2734   B1 28                LDA (TXTADR),Y	; PICK UP GROUP NUMBER
2736   C9 FE                CMP #EOP	; END OF PROGRAM?
2738   F0 0F                BEQ NONEXT	; BRANCH IF NO NEXT LINE
273A   85 26                STA PC	; SAVE AS NEW LINE NUMBER
273C   C8                   INY
273D   B1 28                LDA (TXTADR),Y	; GET STEP NUMBER
273F   85 27                STA PC+1	; STORE IT
2741   C8                   INY		; POINT TO FIRST CHAR ON THE LINE
2742   84 2A                STY TEXTP
2744   20 92 29             JSR GETC	; GET THE FIRST CHAR OF NEW LINE
2747   38                   SEC		; FLAG THE FACT WE HAVE A NEW LINE
2748   60                   RTS		; AND RETURN
2749   18         NONEXT    CLC		; INDICATE WE HAVE NO NEW LINE
274A   60                   RTS		; AND RETURN
            ; 
            ; 'DELETE' A LINE OF STORED PROGRAM
            ; 
274B   20 0A 27   DELETE    JSR PUSHTP	; SAVE TEXT POINTERS
274E   A0 02                LDY #$02	; SKIP OVER LINE NUMBER
2750   84 2A                STY TEXTP
2752   20 D0 26             JSR EATCR	; SKIP TO THE CARRIAGE RETURN
2755   20 11 27             JSR POPTP	; RESTORE POINTER TO START OF LINE TO ZAP
2758   20 0A 27             JSR PUSHTP	; BUT KEEP THEM AROUND
275B   A0 00                LDY #$00	; SET OFFSET TO ZERO
275D   B1 33      DMVLOP    LDA (TXTAD2),Y	; GET A CHAR
275F   91 28                STA (TXTADR),Y	; MOVE IT DOWN
2761   C9 FE                CMP #EOP	; END OF TEXT REACHED YET?
2763   F0 09                BEQ DELDON	; BRANCH IF YES
2765   C8                   INY		; NO, POINT TO NEXT CHAR TO MOVE
2766   D0 F5                BNE DMVLOP	; BRANCH IF NO OVERFLOW ON OFFSET
2768   E6 29                INC TXTADR+1	; OVERFLOW, BUMP HIGH ORDERS
276A   E6 34                INC TXTAD2+1
276C   D0 EF                BNE DMVLOP	; UNCONDITIONALLY MOVE NEXT BYTE
276E   C8         DELDON    INY
276F   84 2A                STY TEXTP	; SAVE OFFSET
2771   A5 28                LDA TXTADR	; GET BASE ADDR
2773   18                   CLC
2774   65 2A                ADC TEXTP	; ADD IN THE OFFSET
2776   85 3E                STA VARBEG	; SAVE AS START OF VARIABLE LIST
2778   A5 29                LDA TXTADR+1	; GET HIGH ORDER
277A   69 00                ADC #$00	; ADD IN THE CARRY
277C   85 3F                STA VARBEG+1	; SAVE IT
277E   20 0D 28             JSR INSDON	; FLAG VARIABLE LIST AS EMPTY
2781   4C 11 27             JMP POPTP	; * PJMP * RESTORE POINTERS TO POINT TO
					;   WHERE WE WOULD INSERT LINE.
            ; 
            ; 'INSERT' A LINE IN THE STORED PROGRAM TEXT AREA
            ; 
2784   20 0A 27   INSERT    JSR PUSHTP	; SAVE TEXT POINTERS ACROSS CALL
2787   20 80 26             JSR FINDLN	; TRY TO LOCATE THE LINE
278A   90 06                BCC INSCNT	; BRANCH IF LINE DOES NOT EXIST
278C   20 4B 27             JSR DELETE	; LINE EXISTS, DELETE IT
278F   20 80 26             JSR FINDLN	; RE-FIND TO SET UP POINTERS AGAIN
2792   20 11 27   INSCNT    JSR POPTP	; GET COMBUF POINTERS BACK
2795   C6 2A                DEC TEXTP	; POINT TO THE LINE NUMBER DELIMITER
2797   20 0A 27             JSR PUSHTP	;   BUT KEEP THEM AROUND
279A   A2 33                LDX #TXTAD2	; SAVE POINTER TO PLACE TO INSERT
279C   A0 04                LDY #$04	;   ON STACK
279E   20 6B 28             JSR PUSHB0
27A1   A2 02                LDX #$02	; SET COUNTER FOR 3 BYTES MINIMUM
27A3   E8         IFCR      INX		; COUNT THIS BYTE
27A4   20 92 29             JSR GETC	; GET IT FROM COMMAND BUFFER
27A7   C9 0D                CMP #$0D	; 'CR' ?
27A9   D0 F8                BNE IFCR	; NO, KEEP COUNTING
27AB   86 5F                STX TEMP1	; SAVE COUNTER TEMPORARILY
27AD   A0 00                LDY #$00	; OFFSET TO ZERO
27AF   B1 33                LDA (TXTAD2),Y	; GET THE LAST CHAR TO SLIDE DOWN
27B1   48                   PHA		; SAVE FOR LATER
27B2   A9 FD                LDA #UMARK	; FLAG THE LOC WITH ALL ONES
27B4   91 33                STA (TXTAD2),Y
27B6   A5 3E                LDA VARBEG	; GET ADDR OF START OF VARIABLE LIST
27B8   85 28                STA TXTADR	; SAVE FOR LATER
27BA   18                   CLC
27BB   65 5F                ADC TEMP1	; ADD IN AMOUNT TO MOVE DOWNWARD
27BD   85 33                STA TXTAD2	; SAVE FOR LATER
27BF   85 3E                STA VARBEG	; SAVE AS NEW START OF VARIABLE LIST
27C1   A5 3F                LDA VARBEG+1	; NOW HIGH ORDER
27C3   85 29                STA TXTADR+1
27C5   69 00                ADC #$00
27C7   85 34                STA TXTAD2+1
27C9   85 3F                STA VARBEG+1	; AND FALL INTO MOVE LOOP
27CB   B1 28      IMVLOP    LDA (TXTADR),Y	; PICK UP A BYTE
27CD   C9 FD                CMP #UMARK	; END OF MOVE?
27CF   F0 0D                BEQ IMVDON	; BRANCH IF YES
27D1   91 33                STA (TXTAD2),Y	; NO, THEN SLIDE IT DOWN
27D3   88                   DEY		; DECREMENT OFFSET?
27D4   C0 FF                CPY #$FF	; OVERFLOW?
27D6   D0 F3                BNE IMVLOP	; BRANCH IF NOT
27D8   C6 29                DEC TXTADR+1	; OVERFLOW, BUMP HIGH ORDER
27DA   C6 34                DEC TXTAD2+1	;   ADDRESSES
27DC   D0 ED                BNE IMVLOP	; UNCONDITIONALLY LOOP FOR MORE
27DE   68         IMVDON    PLA		; GET THE LAST BYTE BACK AGAIN
27DF   91 33                STA (TXTAD2),Y	; STORE IT AWAY
27E1   20 11 27             JSR POPTP	; RESTORE POINTERS TO PLACE TO INSERT
27E4   A2 36                LDX #TXTAD2+3	; RESTORE POINTERS TO COMBUF
27E6   A0 04                LDY #$04
27E8   20 5B 28             JSR POPB0
27EB   A4 2A                LDY TEXTP	; GET OFFSET
27ED   A5 2C                LDA GRPNO	; GET THE GROUP NUMBER
27EF   91 28                STA (TXTADR),Y	; STRORE IT IN PROGRAM AREA
27F1   C8                   INY
27F2   A5 2D                LDA LINENO	; GET THE STEP NUMBER
27F4   91 28                STA (TXTADR),Y	; STRORE IT IN PROGRAM AREA
27F6   C8                   INY		; POINT TO WHERE FIRST CHARACTER GOES
27F7   84 2A                STY TEXTP	; SAVE IT FOR LATER
27F9   A4 35      INSLOP    LDY TEXTP2	; GET POINTER TO CHAR
27FB   B1 33                LDA (TXTAD2),Y	; PICK IT UP
27FD   C8                   INY		; BUMP IT
27FE   84 35                STY TEXTP2	; STORE IT BACK
2800   A4 2A                LDY TEXTP	; POINT TO WHERE IT GOES
2802   91 28                STA (TXTADR),Y	; PUT IT THERE
2804   C9 0D                CMP #$0D	; CARRIAGE RETURN YET?
2806   F0 05                BEQ INSDON	; BRANCH IF YES
2808   C8                   INY		; NO, POINT TO NEXT
2809   84 2A                STY TEXTP	; SAVE POINTER
280B   D0 EC                BNE INSLOP	; UNCONDITIONALLY LOOP FOR MORE
280D   A0 00      INSDON    LDY #$00	; OFFSET TO ZERO
280F   A9 FF                LDA #EOV	; FLAG VARIABLE LIST AS EMPTY
2811   91 3E                STA (VARBEG),Y
2813   A5 3E                LDA VARBEG	; AND UPDATE 'VAREND'
2815   85 42                STA VAREND
2817   A5 3F                LDA VARBEG+1
2819   85 43                STA VAREND+1
281B   60                   RTS		; AND RETURN
            ; 
            ; 		'SOFTWARE STACK MANIPULATION ROUTINES'
            ; 
            ; "PUSHJ" - PUSH-JUMP TO A ROUTINE
            ; 
            ; CALLING SEQUENCE IS:
            ; 
            ; JSR  PUSHJ	; CALL THIS SUBROUTINE
            ; .WORD		; TWO BYTE ADDR OF ROUTINE TO GO TO
            ; 			; *** NOTE! THIS WORD CANNOT OVERLAP
            ; 			; *** A PAGE BOUNDARY.
            ; 		<-----	; RETURN IS HERE VIA "POPJ" ROUTINE
            ; 
            ; *** this routine has self-modifying code at $281F & $2828 --dhh
            ; 
281C   68         PUSHJ     PLA		; GET LOW ORDER RETURN ADDR FROM STACK
281D   A8                   TAY		; PLACE IN Y REGISTER
281E   C8                   INY		; INCREMENT TO GET LOW ORDER TO JUMP INDIR
281F   8C 2F 28             STY $282F	; STORE IN JUMP INDIRECT INSTRUCTION
2822   C8                   INY		; BUMP FOR THE RTS IN "POPJ"
2823   98                   TYA		; PLACE IN ACCUMULATOR
2824   20 31 28             JSR PUSHA	; SAVE ON STACK FOR LATER
2827   68                   PLA		; GET HIGH ORDER RETURN ADDR
2828   8D 30 28             STA $2830	; STORE IN JUMP INDIRECT INSTRUCTION
282B   20 31 28             JSR PUSHA	; SAVE FOR LATER RETURN VIA "POPJ"
282E   6C 00 00             JMP ($0000)	; ADDR IS OVERWRITTEN FROM ABOVE CODE
					; THIS JUMP WILL GO TO "ROUTINE".
            ; 
            ; "PUSHA" - PUSH THE ACCUMULATOR ON THE SOFTWARE STACK
            ; 
            ; CALLING SEQUENCE IS:
            ; JSR  PUSHA
            ; 
2831   A4 4E      PUSHA     LDY PDP	; GET THE SOFTWARE STACK POINTER
2833   91 4C                STA (PDPADR),Y	; STORE THE ACC VIA POINTER
2835   88                   DEY		; DECREMENT THE SOFT STACK POINTER
2836   C0 FF                CPY #$FF	; IS NEW VALUE $FF ?
2838   D0 02                BNE PUSHRT	; NO, THEN BASE ADDR IS ok
283A   C6 4D                DEC PDPADR+1	; YES, DEC BASE ADDR BY ONE
283C   84 4E      PUSHRT    STY PDP	; STORE UPDATED POINTER
283E   60                   RTS		; AND RETURN
            ; 
            ; "POPA" - POP ITEM OFF SOFTWARE STACK INTO THE ACCUMULATOR
            ; 
            ; CALLING SEQUENCE IS:
            ; JSR  POPA
            ; 
283F   A4 4E      POPA	    LDY PDP	; load software stack pointer
2841   C8                   INY		; increment so it points to new item
2842   D0 02                BNE PHOK	; branch if high-order base addr is OK
2844   E6 4D                INC PDPADR+1  ; if not OK, increment by one page
2846   B1 4C      PHOK      LDA (PDPADR),Y  ; get item from soft stack
2848   84 4E                STY PDP	; store updated pointer
284A   60                   RTS		; and return
            ; 
            ; "POPJ" - RETURN TO ADDRESS SAVED BY A CALL TO "PUSHJ"
            ; 
            ; CALLING SEQUENCE IS:
            ; JSR  POPJ
            ; 
284B   BA         POPJ      TSX			; load X w/ hw stack pointer
284C   20 3F 28             JSR POPA		; get hi order addr to ret to
284F   9D 02 01             STA STACK+2,X	; overwrite return addr
2852   20 3F 28             JSR POPA		; get lo order byte to ret to
2855   9D 01 01             STA STACK+1,X	; overwrite return addr
2858   60                   RTS			; return to proper place, past
						;   JSR PUSHJ and .WORD routine
						; SEQUENCE --->
            ; 
            ; "POPB0"  pop bytes off of stack into zero page
            ; 
2859   A0 02      POPB2     LDY #$02	; entry point when we need 2 bytes only
285B   84 5F      POPB0     STY TEMP1	; save Y register
285D   20 3F 28             JSR POPA	; get a byte from stack
2860   95 00                STA $00,X	; store it in zero page
2862   A4 5F                LDY TEMP1	; get Y register back
2864   CA                   DEX		; count X down
2865   88                   DEY		; done yet?
2866   D0 F3                BNE POPB0	; loop for more
2868   60                   RTS		; yes, return
            ; 
            ; "PUSHB0"  push bytes from page zero onto stack   
            ; 
2869   A0 02      PUSHB2    LDY #$02		; entry point, 2 bytes only
286B   84 5F      PUSHB0    STY TEMP1		; save Y
286D   B5 00                LDA $00,X		; get value from Z Pg
286F   20 31 28             JSR PUSHA		; save on stack
2872   A4 5F                LDY TEMP1		; get Y back
2874   E8                   INX			; next byte
2875   88                   DEY			; done yet?
2876   D0 F3                BNE PUSHB0		; loop if >0
2878   60                   RTS			; return
            ; 
            ; PUSH AND POP F.P. NUMBERS
            ; 
            ; PUSH FAC1 ONTO STACK
            ; 
2879   A2 FB      PHFAC1    LDX #$FB		; get neg of num of bytes to push
287B   B5 85      PHF1B     LDA $85,X		; get a byte of number
287D   20 31 28             JSR PUSHA		; push onto software stack
2880   E8                   INX			; point to next one
2881   30 F8                BMI PHF1B		; loop til all pushed
2883   60                   RTS			
            ; 
            ; PUSH FAC2 ONTO STACK
            ; 
2884   A2 FB      PHFAC2    LDX #$FB		; get neg of num of bytes to push
2886   B5 80      PHF2B     LDA $80,X		; get a byte of number
2888   20 31 28             JSR PUSHA		; etc
288B   E8                   INX
288C   30 F8                BMI PHF2B
288E   60                   RTS
            ; 
            ; PUSH F.P. TEMP ONTO STACK
            ; 
288F   A2 FB      PHTMP     LDX #$FB		; get neg of num of bytes to push
2891   B5 A5      PHTB      LDA $A5,X		; get a byte of number
2893   20 31 28             JSR PUSHA		; etc
2896   E8                   INX
2897   30 F8                BMI PHTB
2899   60                   RTS
            ; 
            ; POP NUMBER ON STACK INTO FAC2
            ; 
289A   A2 04      PLFAC2    LDX #$04		; point to last byte
289C   20 3F 28   PLF2B     JSR POPA		; pop item from stack into ACC
289F   95 7B                STA X2,X		; store into FAC2
28A1   CA                   DEX			; point to next byte
28A2   10 F8                BPL PLF2B		; loop until all popped 
28A4   60                   RTS
            ; 
            ; POP NUMBER ON STACK INTO F.P. TEMP
            ; 
28A5   A2 04      PLTMP     LDX #$04		; point to last byte
28A7   20 3F 28   PLTB      JSR POPA		; get item from stack into ACC
28AA   95 A0                STA $A0,X		; store in temp area
28AC   CA                   DEX			; point to next byte
28AD   10 F8                BPL PLTB		; loop til done
28AF   60                   RTS
            ; 
            ; 		'CHARACTER MANIPULATING ROUTINES'
            ; 
            ; READ ONE CHARACTER WITH NO ECHO
            ; 
28B0   A5 6B      RNOECH    LDA ECHFLG		; get echo ctrl flag
28B2   48                   PHA			; save on stack
28B3   A9 01                LDA #$01		; no disable echo
28B5   85 6B                STA ECHFLG
28B7   20 C0 28             JSR READC		; get a char from input device
28BA   AA                   TAX			; save char into X
28BB   68                   PLA			; get old echo flag value back
28BC   85 6B                STA ECHFLG
28BE   8A                   TXA			; get the char input
28BF   60                   RTS
            ; 
            ; "READC" - READ ONE CHARACTER FROM INPUT DEVICE
            ; 
28C0   A6 66      READC     LDX IDEV	; GET CURRENT INPUT DEVICE NUMBER
28C2   10 03                BPL READC1	; BRANCH IF DEVICE NUMBER IS POSITIVE
28C4   4C CB 30             JMP RSTRNG	; * PJMP * NEG, READ FROM STRING AND RET
28C7   BD AF 35   READC1    LDA $35AF,X	; GET HIGH ORDER DISPATCH ADDRESS
28CA   85 60                STA TEMP1+1	; STORE IT AWAY
28CC   BD B4 35             LDA $35B4,X	; GET LOW ORDER
28CF   85 5F                STA TEMP1	; STORE IT AWAY
28D1   20 5E 00             JSR $005E	;   AND CALL THE INPUT ROUTINE
28D4   90 05                BCC READCC	; BRANCH IF NO ERRORS
28D6   20 15 20   IERRI     JSR CLRDEV	; RESET DEVICES ON AN I-O ERROR
28D9   00                   BRK		; TRAP
28DA   E9		    .BYTE $E9	; ?I-O ERROR ON INPUT DEVICE
28DB   85 2B      READCC    STA CHAR	; SAVE CHAR
28DD   C9 7F                CMP #$7F	; here the Aresco code differs from the
28DF   F0 5F                BEQ RTS1	; ProgExch/6502Grp original. Was only a
28E1   C9 5F                CMP #$5F	; test for CR, but now testing for RUBOUT
28E3   F0 5B                BEQ RTS1	; and CXL LINE. Why we're testing for 'k'
28E5   C9 0A                CMP #$0A	; I have no idea.  --dhh
28E7   F0 57                BEQ RTS1
28E9   A5 6B                LDA $6B	; 'k'
28EB   F0 03                BEQ READCE
28ED   A5 2B      READCR    LDA CHAR	; GET CHAR BACK
28EF   60                   RTS

28F0   A5 2B      READCE    LDA CHAR	; this is also not in original code...
28F2   20 02 29             JSR PRINTC
28F5   C9 0D                CMP #$0D
28F7   D0 47                BNE RTS1	; ... to here. Next line was label READCE
28F9   A9 0A                LDA #$0A	; FOLLOW CARRIAGE RETS WITH A LINE FEED
28FB   20 02 29             JSR PRINTC	; PRINT IT
28FE   10 ED                BPL READCR	; UNCONDITIONAL BRANCH
            ; 
            ; PRINTC ('PRINTC'?) - PRINT THE CHAR IN ACC OR 'CHAR'
            ; 
2900   A9 20      PSPACE    LDA #$20	; OUTPUT A SPACE
2902   29 FF      PRINTC    AND #$FF	; here we're testing for a null ($00),
2904   D0 02                BNE PRNTC	; otherwise, routine branches to the
2906   A5 2B                LDA CHAR	; original ProgExch 'PRINTC'
2908   48         PRNTC     PHA		; SAVE THE CHAR IN THE AC
2909   A6 67                LDX ODEV	; GET CURRENT OUTPUT DEVICE NUMBER
290B   10 06                BPL PUSEA1	; BRANCH IF DEVICE NUMBER IS POSITIVE
					; ProgExch source has a 'patch' here
					; covering the next six bytes:
					; LDY STOPNT   ; get pntr to next char
					; JMP WSTRNG   ; *PJMP* write to string
					; NOP	       ; patch fill
290D   20 BE 30             JSR WSTRNG	
2910   4C 29 29             JMP PRRET
2913   BD B9 35   PUSEA1    LDA $35B9,X	; GET HIGH ORDER ADDR OF OUTPUT ROUTINE
2916   85 60                STA TEMP1+1	; SAVE IT
2918   BD BE 35             LDA $35BE,X	; GET LOW ORDER ADDR OF OUTPUT ROUTINE
291B   85 5F                STA TEMP1	; SAVE IT
291D   68                   PLA		; GET CHAR BACK
291E   48                   PHA		; BUT SAVE ACROSS CALL
291F   20 5E 00             JSR JSRIND	; CALL THE ROUTINE TO DO THE OUTPUT
2922   90 05                BCC PRRET	; BRANCH IF NO ERRORS
2924   20 15 20   OEERO     JSR CLRDEV	; RESET I-O DEVICES IF ERROR
2927   00                   BRK		; TRAP
2928   DE 		    .BYTE $DE	; ?I-O ERROR ON OUTPUT DEVICE
2929   68         PRRET     PLA		; RESTORE THE CHARACTER
292A   60		    RTS		; AND RETURN
            ; 
            ; PACKC - PACK A CHAR INTO MEMORY
            ; 
292B   A5 2B      PACKC     LDA CHAR		; get character
292D   A4 2A      PACKC1    LDY TEXTP		; get text pointer
292F   C9 7F                CMP #$7F		; rubout?
2931   F0 10                BEQ RUB1		; yes, branch
2933   C9 5F                CMP #$5F		; 'line delete' char?
2935   F0 29                BEQ RUBLIN		; yes, branch
2937   91 28                STA (TXTADR),Y	; store char to memory
2939   C8         PCKRUB    INY			; +1 text pointer
293A   C0 7F                CPY #$7F		; over max line length?
293C   10 03                BPL PBIG		; yes, branch
293E   84 2A      PCKRET    STY TEXTP		; save text pointer
2940   60         RTS1      RTS			; and return
2941   00         PBIG      BRK			; trap
2942   FF                   .BYTE $FF		; ?line too long
            ; 
            ; ROUTINE TO RUB OUT ONE CHARACTER
            ; 
2943   C0 00      RUB1      CPY #$00		; anything to rubout?
2945   F0 F7                BEQ PCKRET		; nope, branch
2947   A4 6B                LDY ECHFLG		; has user enabled character echo?
2949   D0 0E                BNE RUB1CC		; branch if disabled
294B   A4 6C                LDY DELSPL		; need special CRT rubout?		
294D   F0 05                BEQ RUB1C		; branch if not
294F   20 7D 29             JSR EATTVC		; yes, eat the char		
2952   10 05                BPL RUB1CC		; uncond. branch
2954   A9 5C      RUB1C     LDA #$5C		; echo sp char '\' for rubout
2956   20 08 29             JSR PRNTC
2959   A4 2A      RUB1CC    LDY TEXTP		; load Y with text pointer
295B   88                   DEY			; -1
295C   10 E0                BPL PCKRET		; RET if positive
295E   30 D9                BMI PCKRUB		; if past beginning, set to 0
            ; 
            ; ROUTINE TO RUB OUT THE ENTIRE LINE
            ; 
2960   C0 00      RUBLIN    CPY #$00		; anything to rubout?
2962   F0 DA                BEQ PCKRET		; branch if not
2964   A4 6B                LDY ECHFLG		; has user enabled char echo?
2966   D0 11                BNE RUBLR		; branch if disabled
2968   A4 6C                LDY DELSPL		; need special CRT rubout proc?
296A   F0 08                BEQ RUBLC		; branch if not
296C   20 7D 29   RUBLCL    JSR EATTVC		; eat a char off CRT screen
296F   C6 2A                DEC TEXTP		; zap it from buffer
2971   D0 F9                BNE RUBLCL		; loop til all zapped
2973   60                   RTS	
2974   A9 5F      RUBLC     LDA #$5F		; echo 'line del' character
2976   20 08 29             JSR PRNTC
2979   A0 00      RUBLR     LDY #$00		; reset text pointer
297B   F0 C1                BEQ PCKRET		; and RET
            ; 
            ; EAT A CRT CHAR WITH BS-SPC-BS SEQUENCE
            ; 
297D   20 83 29   EATTVC    JSR BACKSP		; output a BS
2980   20 00 29             JSR PSPACE		; followed by a space
2983   A9 08      BACKSP    LDA #$08		; get BS char
2985   4C 02 29             JMP PRINTC		; * PJMP * output it and return
            ; 
            ; 'GETC' GET A CHAR FROM MEMORY, ECHO IF TRACE ON
            ; 
2988   A4 20      GETCX     LDY DEBGSW		; is trace disabled?
298A   D0 17                BNE GETC1		; yes, don't look at flag
298C   A5 21                LDA DMPSW		; flip state of the dump switch
298E   49 FF                EOR #$FF
2990   85 21                STA DMPSW		; and store it back
2992   A5 24      GETC      LDA INSW		; where do we get the char from?
2994   F0 03                BEQ GETCC		; from memory
2996   4C C0 28             JMP READC		; * PJMP * go get from input dev
2999   A4 2A      GETCC     LDY TEXTP		; get text pointer
299B   E6 2A                INC TEXTP		; +1 to next char
299D   B1 28                LDA (TXTADR),Y	; get it
299F   C9 3F                CMP #$3F		; is it '?'
29A1   F0 E5                BEQ GETCX		; yes, go handle
29A3   85 2B      GETC1     STA CHAR		; store away for others
29A5   A5 20                LDA DEBGSW		; check to see if we print it
29A7   05 21                ORA DMPSW		; for debugging
29A9   D0 03                BNE GETRT1		; no
29AB   20 F0 28             JSR READCE		; print only if both are 0
29AE   A5 2B      GETRT1    LDA CHAR		; get char back
29B0   60                   RTS			; and RET
		            ; the ProgramExchange/6502Group code has a 'patch'
		            ; over GETC1:
		            ; GETC1	STA CHAR	; STORE IT
		            ; 		PHA		; SAVE ON STACK
		            ; 		LDA DEBGSW	; DO WE PRINT IT?
		            ; 		ORA DMPSW	; FOR DEBUGGING
		            ; 		BNE TESTN+7	; NO
		            ; 		PLA		; GET CHAR BACK
		            ; 		JSR TRACBG	; FIX FOR TRACE BUG
		            ; 		RTS		; CHAR IS RETURNED
            ; 
            ; 'SPNOR' ROUTINE TO IGNORE LEADING SPACES
            ; 
29B1   20 92 29   GSPNOR    JSR GETC	; CALL GETC FIRST
29B4   A5 2B      SPNOR     LDA CHAR	; GET THE CHAR
29B6   C9 20                CMP #$20	; IS IT A SPACE?
29B8   F0 F7                BEQ GSPNOR	; YES, THEN IGNORE
29BA   60                   RTS		; NO, RETURN
            ; 
            ; "TESTN"  TESTS TO SEE IF CHARACTER IS A NUMBER
            ; 
29BB   20 B1 29   TESTNS    JSR GSPNOR	; GET NEXT NON-BLANK
29BE   A5 2B      TESTN     LDA CHAR	; GET CHAR
29C0   48         TESTN1    PHA		; SAVE CHAR ON STACK
29C1   49 30                EOR #$30	; CONVERT TO BCD (IF A NUMBER)
29C3   C9 0A                CMP #$0A	; SET C BIT IF GREATER THAN 9
29C5   68                   PLA		; RETORE CHARACTER TO ACCUMULATOR
29C6   60                   RTS		; RETURN (C BIT CLEAR IF NUMBER)
            ; 
            ; 		'EVAL' - EXPRESSION EVALUATOR
            ; 
            ; 'EVAL' - EVALUATE AN EXPRESSION (RECURSIVE)
            ; 
29C7   A9 00      EFUN      LDA #$00	; GET A ZERO
29C9   0A         EFUNL     ASL A	; ROTATE LEFT TO HASH
29CA   85 65                STA ETEMP1	; SAVE IT
29CC   20 92 29             JSR GETC	; GET NEXT CHARACTER OF FUNCTION NAME
29CF   20 3E 2B             JSR TTERMS	; TERMINATOR?
29D2   F0 07                BEQ EFNAME	; BRANCH IF END OF NAME
29D4   29 1F                AND #$1F	; KEEP ONLY 5 BITS
29D6   18                   CLC
29D7   65 65                ADC ETEMP1	; ADD IN THE HASH
29D9   D0 EE                BNE EFUNL	; UNCONDITIONALLY LOOP FOR MORE
29DB   C9 28      EFNAME    CMP #$28	; '(' LEFT PAREN?
29DD   F0 02                BEQ EFUNC	; BRANCH IF YES
29DF   00                   BRK		; TRAP
29E0   E3                   .BYTE $E3	; ?PARENTHESES ERROR IN FUNCTION
29E1   A5 65      EFUNC     LDA ETEMP1	; GET THE HASH CODE FOR FUNCTION NAME
29E3   20 31 28             JSR PUSHA	; SAVE FOR LATER
29E6   20 1C 28             JSR PUSHJ	; MOVE PAST PAREN, EVALUATE 1ST ARGUMENT
29E9   03 2A                .BYTE $3,$2A
29EB   20 3F 28             JSR POPA	; GET THE NAME BACK AGAIN
29EE   AA                   TAX		; TRANSFER TO X REGISTER
29EF   20 1C 28             JSR PUSHJ	; AND GO DO THE FUNCTION
29F2   E9 2D                .BYTE $E9,$2D
29F4   4C CD 2A             JMP ERPAR	; GO SEE IF TERMINATOR IS A RIGHT PAREN.
            ; 
            ; HERE FOR A QUOTED CONSTANT
            ; 
29F7   20 92 29   ECHAR     JSR GETC	; GET CHARACTER FOLLOWING QUOTE
29FA   20 41 32             JSR FLT8	; AND MAKE IT A FLOATING POINT NUMBER
29FD   20 92 29             JSR GETC	; MOVE PAST CHARACTER
2A00   4C 83 2A             JMP OPNEXT	; AND CHECK FOR OPERATOR
            ; 
            ; *** MAIN ENTRY POINT(S) TO 'EVAL' ***
            ; 
2A03   20 92 29   EVALM1    JSR GETC	; ENTER HERE TO GET PAST CURRENT CHARACTER
2A06   A9 00      EVAL      LDA #$00	; ASSUME LOWEST LEVEL ARITHMETIC OPERATION
2A08   85 75                STA LASTOP
2A0A   85 3B                STA STRSWT	; MAKE SURE STRING VAR SWITCH IS OFF
2A0C   20 CB 2C             JSR L2CCB	; ASSUME VALUE OF EXPRESSION IS ZERO
2A0F   A5 75      ARGNXT    LDA LASTOP	; SAVE LAST OPERATION ON STACK
2A11   20 31 28             JSR PUSHA
2A14   20 3E 2B             JSR TTERMS	; GO SEE IF THIS CHARACTER IS A TERMINATOR
2A17   D0 03                BNE ECHKC	; BRANCH IF NOT
2A19   4C C4 2A             JMP ETERM1	; YES, THEN HANDLE
2A1C   C9 46      ECHKC     CMP #$46	; 'F' IS IT A FUNCTION?
2A1E   F0 A7                BEQ EFUN	; BRANCH IF YES
2A20   C9 27                CMP #$27	; ''' IS IT A CHARACTER CONSTANT?
2A22   F0 D3                BEQ ECHAR	; BRANCH IF YES
2A24   C9 2E                CMP #$2E	; '.' IS IT A FRACTION?
2A26   F0 1C                BEQ ENUM	; BRANCH IF YES, CALL FLOATING P. ROUTINE
2A28   20 C0 29             JSR TESTN1	; NO, BUT IS IT A NUMBER?
2A2B   B0 28                BCS EGTVAR	; BRANCH IF NOT A NUMBER
            				; *** START OF KLUDGE HACK
            				;     TO SPEED THINGS UP ***
2A2D   A5 24                LDA INSW	; ARE WE INPUTTING FROM INPUT DEVICE?
2A2F   D0 13                BNE ENUM	; BRANCH IF YES, CALL FLOAT PT ROUTINE
2A31   A2 02                LDX #$02	; NO, THEN WE CAN LOOK AHEAD TO SEE IF
2A33   A4 2A                LDY TEXTP	;   CONSTANT IS IN RANGE 0-99
2A35   B1 28      KLOOP     LDA (TXTADR),Y	; GET NEXT CHAR
2A37   C8                   INY		; BUMP POINTER
2A38   C9 2E                CMP #$2E	; '.' DOES NUMBER HAVE A FRACTIONAL PART
2A3A   F0 08                BEQ ENUM	; BRANCH IF IT DOES, CALL F.P. ROUTINE
2A3C   20 C0 29             JSR TESTN1	; IS THIS CHAR A DIGIT 0-9 ALSO?
2A3F   B0 09                BCS FSTNUM	; BRANCH IF NOT, THEN CALL FAST INPUT
2A41   CA                   DEX		; CAN ONLY HAVE UP TO TWO DIGITS
2A42   D0 F1                BNE KLOOP	; LOOK AT NEXT ONE
            				; IF WE FALL OUT OF THE LOOP, WE HAVE TO
2A44   20 27 34   ENUM      JSR FINP	;   CALL FLOAT PT. INPUT ROUTINE (SLOW!)
2A47   4C 83 2A             JMP OPNEXT	; AND LOOP FOR OPERATOR
2A4A   A5 2B      FSTNUM    LDA CHAR	; GET FIRST DIGIT OF NUMBER
2A4C   20 C2 2D             JSR L2DC2	; CALL FAST INPUT ROUTINE FOR #S 0-99
2A4F   20 41 32             JSR FLT8	; CALL FAST ONE-BYTE FLOAT ROUTINE
2A52   4C 83 2A             JMP OPNEXT	;    AND LOOK FOR OPERATOR
            				; *** END OF KLUDGE HACK ***
2A55   20 1C 28   EGTVAR    JSR PUSHJ	; IT MUST BE A VARIABLE, GET VALUE
2A58   51 2B                .BYTE $51,$28	; or .WORD GETVAR
2A5A   A5 2B                LDA CHAR	; GET CHARACTER THAT TERMINATED THE VARIB
2A5C   C9 3D                CMP #$3D	; '=' DOES HE WANT SUBSTITUTION?
2A5E   D0 23                BNE OPNEXT	; BRANCH IF NOT, JUST A TERM
2A60   A2 37                LDX #VARADR	; YES, THEN SAVE THE INFO ABOUT THIS VARIB
2A62   A0 05                LDY #$05
2A64   20 6B 28             JSR PUSHB0	;   ONTO THE STACK
2A67   20 1C 28             JSR PUSHJ	; CALL OURSELVES TO EVAL THE EXPRESSION
2A6A   03 2A                .BYTE $03,$2A	; or .WORD EVALM1
2A6C   A2 3B                LDX #VARADR+4	; RESTORE POINTERS TO VARIABLE
2A6E   A0 05                LDY #$05
2A70   20 5B 28             JSR POPB0
2A73   A5 3B                LDA STRSWT	; WAS THE VARIABLE A STRING VARIABLE?
2A75   D0 05                BNE SETSTR	; BRANCH IF IT WAS
2A77   20 A1 2C             JSR PUTVAR	; NO, THEN STORE EXPRESS VALUE AS VARIB'S
2A7A   F0 07                BEQ OPNEXT	;   VALUE - IS ALSO VALUE OF THIS TERM
2A7C   20 93 2F   SETSTR    JSR INTGER	; KEEP ONLY 8 BITS FOR VALUE
2A7F   A4 3A                LDY VSUB+1	; POINT TO POSITION IN STRING
2A81   91 37                STA (VARADR),Y	; STORE IT INTO $, FALL INTO...
2A83   20 3E 2B   OPNEXT    JSR TTERMS	; GO SEE IF NEXT NON-SPACE IS SPECIAL
2A86   D0 04                BNE MISOPR	; BRANCH IF NOT
2A88   E0 06                CPX #$06	; LEFT PAREN?
2A8A   D0 08                BNE OPNXT1	; NO, THAT'S GOOD AS WE CAN'T HAVE 1 HERE
2A8C   00         MISOPR    BRK		; TRAP TO ERROR HANDLER
2A8D   FB                   .BYTE $FB	; ?OPERATOR MISSING - EVAL
2A8E   4C 0F 2A   JARGN     JMP ARGNXT	; BRANCH AID
2A91   20 4B 28   EVALRT    JSR POPJ	; RETURN FROM CALL TO "EVAL"

2A94   E0 07      OPNXT1    CPX #$07	; IS THIS A DELIMITER?
2A96   30 02                BMI OPNXT2	; BRANCH IF NOT
2A98   A2 00                LDX #$00	; YES, THEN THE OPERATION LEVEL IS LOWEST
2A9A   20 3F 28   OPNXT2    JSR POPA	; GET LAST OPERATION LEVEL
2A9D   85 5F                STA TEMP1	; SAVE IT FOR COMPARE
2A9F   E4 5F                CPX TEMP1	; IS THIS OPER LVL < OR = TO LAST ONE?
2AA1   30 02                BMI DOBOP	; BRANCH IF YES
2AA3   D0 12                BNE ESTACK	; BRANCH IF NO
2AA5   09 00      DOBOP     ORA #$00	; TO RESET FLAGS AFTER CPX
2AA7   85 75                STA LASTOP	; YES, THEN GET THE LAST OPERATOR
2AA9   F0 E6                BEQ EVALRT	; IF LOWEST LEVEL, THEN WE ARE ALL DONE
2AAB   8A                   TXA		; SAVE 'THISOP'
2AAC   48                   PHA		; ON HARDWARE STACK
2AAD   20 9A 28             JSR PLFAC2	; POP PARTIAL RESULT BACK INTO FAC2
2AB0   20 E8 2A             JSR EVBOP	; AND GO DO THE OPERATION LEAVING THE
            				;   RESULT IN FLAC
2AB3   68                   PLA		; GET 'THISOP' BACK
2AB4   AA                   TAX
2AB5   10 E3                BPL OPNXT2	; UNCOND. BRANCH WITH NEW PARTIAL RESULT.

2AB7   20 31 28   ESTACK    JSR PUSHA	; SAVE BACK ON STACK FOR LATER COMPUTATION
2ABA   86 75                STX LASTOP	; NOW UPDATE 'LASTOP' TO 'THISOP'
2ABC   20 79 28             JSR PHFAC1	; SAVE PARTIAL RESULT ON STACK
2ABF   20 92 29             JSR GETC	; SKIP OVER THE OPERATOR
2AC2   10 CA                BPL JARGN	; UNCOND. BRANCH TO PICK UP NEXT ARGUMENT
2AC4   E0 06      ETERM1    CPX #$06	; LEFT PAREN?
2AC6   D0 12                BNE ETERM2	; BRANCH IF NOT
2AC8   20 1C 28             JSR PUSHJ	; ENTERING NEW LEVEL OF NESTING, SO CALL
2ACB   03 2A                .BYTE $03,$2A   ; OURSELVES TO EVALUATE IT!
2ACD   A5 2B      ERPAR     LDA CHAR	; GET THE DELIMITER THAT ENDED THIS LEVEL
2ACF   48                   PHA		; SAVE IT MOMENTARILY
2AD0   20 92 29             JSR GETC	; MOVE PAST IT
2AD3   68                   PLA		; GET DELIMITER BACK
2AD4   C9 29                CMP #$29	; ')' RIGHT PAREN?
2AD6   F0 AB                BEQ OPNEXT	; YES. GO PICK UP NEXT OPERATOR
2AD8   00         EPMISS    BRK		; TRAP TO ERROR HANDLER
2AD9   FA                   .BYTE $FA	; ?PARENTHESIS MISMATCH - EVAL
2ADA   E0 07      ETERM2    CPX #$07	; DELIMITER ON RIGHT-HAND SIDE?
2ADC   10 04                BPL ETERM3	; BRANCH IF YES
2ADE   E0 03                CPX #$03	; OR UNARY OPERATOR
2AE0   10 04                BPL MISOPN	; NO, THEN IT CAN'T BE HERE
2AE2   A5 75      ETERM3    LDA LASTOP	; PICK UP OPERATION LEVEL
2AE4   F0 AE                BEQ OPNXT1	; ONLY ALLOW IF AT LOWEST LEVEL
2AE6   00         MISOPN    BRK		; TRAP TO ERROR HANDLER
2AE7   F9 		    .BYTE $F9	; ?OPERAND MISSING - EVAL

2AE8   A6 75      EVBOP     LDX LASTOP	; GET THE ARITHMETIC OPERATION TO PERFORM
2AEA   BD 80 35             LDA $3580,X	; GET THE HIGH-ORDER ADDR OF ROUTINE
2AED   85 60                STA TEMP1+1	; STORE IT
2AEF   BD 85 35             LDA $3585,X	; GET THE LOW-ORDER ADDR OF ROUTINE
2AF2   85 5F                STA TEMP1	; STORE IT
2AF4   6C 5F 00             JMP ($005F)	; * PJMP * TO ROUTINE TO DO THE OPERATION
            ; 
            ; 
            ; 		EVALUATE A POWER
            ; 
            ; *** NOTE: THIS ROUTINE IS CURRENTLY RESTRICTED TO RAISING
            ; 		THE NUMBER TO AN INTEGER POWER WITHIN THE RANGE
            ; 		OF + OR - 32,767		(label: EVPOWR)
            ; 
2AF7   20 A7 2F             JSR INTFIX	; GET EXPONENT
2AFA   85 55                STA ITMP1L	; STORE IT AWAY
2AFC   A5 82                LDA M1+1	; AS NUMBER OF TIMES TO DO OPERATION
2AFE   85 56                STA ITMP1H
2B00   A2 9B                LDX #$9B	; GET THE CONSTANT 1.0 INTO FAC1
2B02   A0 80                LDY #FAC1
2B04   20 FF 33             JSR MOVXY
2B07   A5 56                LDA ITMP1H	; RAISING TO A NEGATIVE POWER?
2B09   30 1A                BMI NPOWR	; BRANCH IF WE ARE
2B0B   A9 FF      POWRLP    LDA #$FF	; POSITIVE POWER, ARE WE DONE YET?
2B0D   C6 55                DEC ITMP1L
2B0F   C5 55                CMP ITMP1L
2B11   D0 02                BNE POWR1	; BRANCH IF HIGH ORDER OK
2B13   C6 56                DEC ITMP1H	; DECREMENT HIGH ORDER
2B15   C5 56      POWR1     CMP ITMP1H	; DONE YET?
2B17   F0 32                BEQ TTRET	; YES, THEN RETURN
2B19   20 84 28             JSR PHFAC2	; NO, SAVE FAC2
2B1C   20 A0 32             JSR FMUL	; NUMBER TIMES ITSELF (EXCEPT FIRST TIME)
2B1F   20 9A 28             JSR PLFAC2	; RESTORE NUMBER TO FAC2
2B22   4C 0B 2B             JMP POWRLP	; AND KEEP MULTIPLYING
            ; 
            ; HERE IF RAISING TO A NEGATIVE POWER
            ; 
2B25   A5 56      NPOWR     LDA ITMP1H	; DONE YET?
2B27   F0 22                BEQ TTRET	; BRANCH IF ALL DONE
2B29   E6 55                INC ITMP1L	; NO, THEN COUNT UP SINCE COUNT IS NEG.
2B2B   D0 02                BNE NPOWR1
2B2D   E6 56                INC ITMP1H	; INCREMENT HIGH ORDER ALSO
2B2F   20 29 32   NPOWR1    JSR SWAP	; PUT PARTIAL INTO FAC2, 'X' INTO FAC1
2B32   20 79 28             JSR PHFAC1	; SAVE 'X'
2B35   20 CA 32             JSR FDIV	; 1/(X*X*X*X...)
2B38   20 9A 28             JSR PLFAC2	; RESTORE 'X'
2B3B   4C 25 2B             JMP NPOWR	; AND LOOP TILL DONE
            ; 
            ; 		'ROUTINES USED BY "EVAL" '
            ; 
            ; TEST TO SEE IF CHARACTER IS A SPECIAL TERMINATOR
            ; 
2B3E   20 B4 29   TTERMS    JSR SPNOR	; IGNORE SPACES, GET NEXT NON-BLANK CHAR
2B41   A2 0C                LDX #$0C	; GET MAX TABLE OFFSET
2B43   DD E8 34   TRMCHK    CMP $34E8,X	; MATCH?
2B46   F0 03                BEQ TTRET	; YES, RETURN WITH Z=1
2B48   CA                   DEX		; POINT TO NEXT ENTRY
2B49   10 F8                BPL TRMCHK	; AND CHECK IT
2B4B   60         TTRET     RTS		; RETURN (NOTE: Z=0 IF CANNOT FIND)
            ; 
            ; 		'GETVAR' - GET A VARIABLE FROM VARIABLE LIST
            ; 
            ; "GETVAR" - GET A VARIABLE FROM THE VARIABLE LIST
            ; 		 OTHERWISE CREATE IT AND ASSIGN IT A VALUE OF ZERO
            ; 
2B4C   4C D8 2A   GPMISS    JMP EPMISS	; BRANCH AID
2B4F   00         GTERR3    BRK		; TRAP
2B50   F5 		    .BYTE $F5	; ?FUNCTION ILLEGAL HERE
2B51   A9 00      GETVAR    LDA #$00	; ASSUME VARIABLE IS NOT A STRING
2B53   85 3B                STA STRSWT
2B55   20 B4 29             JSR SPNOR	; (DEFENSIVE!) GET THE CHARACTER
2B58   C9 26                CMP #$26	; '&' IS IT SPECIAL 'FSBR' SCRATCH VARIB?
2B5A   F0 0A                BEQ VAROK	; YES, THEN NAME IS OK
2B5C   C9 41                CMP #$41	; 'A' IS IT ALPHABETIC?
2B5E   30 04                BMI VARBAD	; BRANCH IF NOT
2B60   C9 5B                CMP #$5B	; '[' Z+1
2B62   30 02                BMI VAROK	; BRANCH IF ALPHABETIC
2B64   00         VARBAD    BRK		; NOT ALPHABETIC
2B65   F4                   .BYTE $F4	; ?BAD VARIABLE NAME
2B66   C9 46      VAROK     CMP #$46	; 'F' FUNCTION?
2B68   F0 E5                BEQ GTERR3	; BRANCH IF YES
2B6A   0A                   ASL A
2B6B   0A                   ASL A
2B6C   0A                   ASL A	; SHIFT ALPHA LEFT 3
2B6D   48                   PHA		; SAVE IT
2B6E   20 92 29             JSR GETC	; GET NEXT CHARACTER
2B71   49 30                EOR #$30	; CONVERT TO BCD IF A NUMBER
2B73   C9 08                CMP #$08	; IS IT 0-7?
2B75   B0 09                BCS VARDUN	; IF NOT, NAME IS ON STACK
2B77   85 3D                STA VCHAR	; IF YES, SAVE IT
2B79   68                   PLA		; GET BACK ALPHA PART
2B7A   05 3D                ORA VCHAR	; PUT THE PARTS TOGETHER
2B7C   48                   PHA		; AND STICK ON STACK
2B7D   20 92 29             JSR GETC	; GET A NEW CHARACTER IN CHAR
            ; 
            ; 
            ; X X X X X X X X X X X X X X X X X X X X X X X X X X X
            ;
            ; *** here begins work done by Nils Anders (2023)
            ; 
            ; 


2B80   A5 2B      VARDUN    LDA CHAR
2B82   C9 24                CMP #$24			;STRING VARIABLE?
2B84   D0 05                BNE VARDN1			;BRANCH IF NOT, PRESS ON
2B86   85 3B                STA STRSWT			;YES, FLAG THE FACT
2B88   20 92 29             JSR GETC			;AND MOVE TO THE '3'
2B8B   68         VARDN1    PLA				;GET VARIABLE OFF STACK
2B8C   20 31 28             JSR PUSHA			;PUT NAME ON SOFT STACK
2B8F   20 B4 29             JSR SPNOR			;GET NEXT NON-BLANK
2B92   C9 28                CMP #$28			;LEFT PARAMETER?
2B94   F0 06                BEQ VARSUB			;BRANCH IF VARIABLE HAS A SUBSCRIPT
2B96   A9 00                LDA #$00			;OTHERWISE ASSUME 0
2B98   85 3A                STA VSUB+1			;ZERO THE SUBSCRIPT
2B9A   F0 21                BEQ VARSOK			;AND PROCESS IT
2B9C   A5 3B      VARSUB    LDA STRSWT			;SAVE STRING FLAG
2B9E   20 31 28             JSR PUSHA
2BA1   20 1C 28             JSR PUSHJ			;CALL EAVL TO CALCULATE SUBSCRIPT
2BA4   03 2A                .WORD EVALM1		
2BA6   20 3F 28             JSR POPA			;RESTORE STRING FLAG
2BA9   85 3B                STA STRSWT
2BAB   A5 2B                LDA CHAR			;GET TERMINATOR
2BAD   C9 29                CMP #$29			;PARAMETER MATCH?
2BAF   D0 9B                BNE GPMISS			;BRANCH IF NOT
2BB1   20 92 29             JSR GETC			;MOVE PAST THE RIGHT PAREN (TYPO?)
2BB4   20 18 33             JSR FIX			;MAKE SUBSCRIPT AN INTEGER
2BB7   A5 83                LDA X1+3			;GET LOW ORDER BYTE
2BB9   85 3A                STA VSUB+1			;STORE IT
2BBB   A5 82                LDA X1+2			;GET HIGH ORDER BYYTE (NOTE:16 BIT)
2BBD   85 39      VARSOK    STA VSUB			;SAVE FOR LATER
2BBF   20 3F 28             JSR POPA			;GET THE VARIABLE NAME BACK
2BC2   85 3D                STA VCHAR			;SAVE IT
2BC4   20 76 2C   FNDVAR    JSR VARINI			;SET ADDR TO START OF VARIABLE LIST
2BC7   A0 00      CHKVAR    LDY #$00			;SET OFFSET TO ZERO
2BC9   B1 37                LDA(VARADR),Y		;GET THE VARIABLE NAME
2BCB   C9 FF                CMP #EOV			;IS THIS THE END OF THE VARIABLE LIST?	
2BCD   F0 57                BEQ NOVAR			;BRANCH IF END OF LIST
2BCF   C9 FC                CMP #STRMRK			;IS THIS VARIABLE IN THE LIST A STRING VARIABLE?
2BD1   F0 09                BEQ CHKSTR			;BRANCH IF YES, WE HANDLE DIFFERENTLY
2BD3   C5 3D                CMP VCHAR			;ARE THE NAMES THE SAME
2BD5   F0 37                BEQ CHKSUB			;YES, GO SEE IF THE SUBSCRIPTS ARE EQUAL
2BD7   20 7F 2C   NOTVAR    JSR NXTVAR			;POINT TO NEXT VARIABLE IN LIST
2BDA   D0 EB                BNE CHKVAR			;UNCONDITIONAL BRANCH TO CHECK NEXT VARIABLE
2BDC   A5 3B      CHKSTR    LDA STRSWT			;ARE WE LOOKING FOR A STRING VARIABLE?
2BDE   F0 1E                BEQ SKPSTR			;BRANCH IF NOT, JUST SKIP OVER THIS STRING VARIB
2BE0   A5 3D                LDA VCHAR			;YES, THEN GET IT'S NAME
2BE2   C8                   INY				;POINT TO NAME OF STRING VARIABLE IN VAR LIST 
2BE3   D1 37                CMP(VARADR),Y		;IS THIS THE ONE WE ARE LOOKING FOR?
2BE5   D0 18                BNE SKPST1			;BRANCH IF NOT, JUST SKIP IT OVER
2BE7   C8                   INY				;YES, THIS IS THE ONE, GET THE SIZE OF THE
2BE8   B1 37                LDA(VARADR),Y		;STRING
2BEA   85 3C                STA VSIZE			;STORE FOR THOSE WHO NEED IT
2BEC   C8                   INY				;AND UPDATE
2BED   98                   TYA
2BEE   20 81 2C             JSR UPDVAR			;'VARADR' TO POINT TO BASE ADDR OF STRING
2BF1   A4 3A      GETSTC    LDY VSUB+1			;GET SUBSCRIPT (POSITION) OF BYTE WE WANT
2BF3   B1 37                LDA(VARADR),Y		;GET THE BYTE WE WANT
2BF5   85 82                STA M1+1 			;STORE AS LOW ORDER 8 BITS
2BF7   A9 00                LDA #$00
2BF9   85 81                STA M1			;ZERO HIGH ORDER
2BFB   4C E3 2E             JMP FL16PJ			;*PJMP* FLOAT AND RETURN THE VALUE
2BFE   C8         SKPSTR    INY				;MOVE OVER STRING VARIABLE'S NAME
2BFF   C8         SKPST1    INY				;POINT TO STRING VARIABLE'S LENGTH
2C00   B1 37                LDA(VARADR),Y		;GET THE STRING LENGTH
2C02   48                   PHA				;SAVE IT
2C03   C8                   INY				;POINT TO FIRST BYTE IN STRING
2C04   98                   TYA				;UPDATE 'VARADR' TO BASE OF STRING
2C05   20 81 2C             JSR UPDVAR			
2C08   68                   PLA				;GET SIZE OF STRING
2C09   20 81 2C             JSR UPDVAR			;UPDATE 'VARADR' BY PROPER AMOUNT
2C0C   D0 B9                BNE CHKVAR			;AND LOOK FOR NEXT VARIABLE IN LIST
2C0E   A5 3B      CHKSUB    LDA STRSWT			;ARE WE LOOKING FOR A STRING VARIABLE
2C10   D0 C5                BNE NOTVAR			;BRANCH IF WE ARE, CAN'T BE THIS NUMERIC VARIABLE
2C12   A5 39                LDA VSUB			;GET HIGH ORDER SUBSCRIPT WE ARE LOOKING FOR
2C14   C8                   INY				;POINT TO SUBSCRIPT IN LIST
2C15   D1 37                CMP(VARADR),Y		;ARE THEY THE SAME?	
2C17   D0 BE                BNE NOTVAR			;BRANCH IF THIS ONE IS NOT IT
2C19   A5 3A                LDA VSUB+1			;ARE LOW ORDERS ALSO THE SAME?
2C1B   C8                   INY
2C1C   D1 37                CMP(VARADR),Y		
2C1E   D0 B7                BNE NOTVAR			;BRANCH IF THEY ARE NOT THE SAME
2C20   20 AE 2C   LOCVAR    JSR FETVAR		;GET THE VARIABLE'S VALUE INTO FLAC
2C23   20 4B 28             JSR POPJ    	;AND RETURN TO CALLER 
2C26   A5 3B      NOVAR     LDA STRSWT		;IS THIS STRING A VARIABLE 
2C28   D0 21                BNE NOSTR       	;BRANCH IF IT IS A STRING VARIABLE 
2C2A   A5 3D                LDA VCHAR		;GET THE VARIABLE'S NAME 
2C2C   91 37                STA (VARARD),Y  	;STORE IT IN LIST
2C2E   C8                   INY			;POINT TO NEXT IN LIST
2C2F   A5 39                LDA VSUB 		;GET HIGH ORDER SUBSCRIPT
2C31   91 37                STA (VARADR),Y	;SAVE IT IN LIST
2C33   C8                   INY			;POINT TO NEXT
2C34   A5 3A                LDA VSUB+1 		;GET LOW ORDER SUBSCRIPT
2C36   91 37                STA (VARADR),Y	;SAVE IT IN LIST
2C38   A9 00                LDA #$00		;GET A ZERO
2C3A   A2 06                LDX #$06		;GET COUNT OF NUMBER OF BYTES IN NUMBER
2C3C   C8         ZERVAR    INY			;POINT TO THE NEXT VARIABLE
2C3D   91 37                STA (VARADR),Y	;ZERO OUT VARIABLES VALUE
2C3F   CA                   DEX			;COUNT THIS BYTE
2C40   D0 FA                BNE ZERVAR		;LOOP TILL DONE. NOTE: EXTRA ZERO AT END
2C42   A9 FF                LDA #$FF		;FLAG END OF VARIABLE LIST
2C44   91 37                STA (VARADR),Y	;FLAG END OF VARIABLE LIST
2C46   20 8D 2C             JSR UPDEND		;UPDATE THE END OF THE VARIABLE LIST
2C49   D0 D5                BNE LOCVAR		;UNCONDITIONAL BRANCH, AS WE HAVE FOUND
						;THE VARIABLE
                  ; 
                  ;  HERE WHEN STRING VARIABLE WAS NOT FOUND
                  ; 
2C4B   A9 FC      NOSTR     LDA #STRMRK		;ADD A STRING MARKER AT THE END OF VARIABLE LIST
2C4D   91 37                STA (VARADR),Y
2C4F   C8                   INY
2C50   A5 3D                LDA VCHAR		;ADD IT'S NAME
2C52   91 37                STA (VARADR),Y
2C54   C8                   INY
2C55   A5 64                LDA STRSIZ		;GET DEFAULT STRING SIZE
2C57   91 37                STA (VARADR),Y	;STORE AS SIZE OF STRING
2C59   85 3C                STA VSIZE		;ALSO STORE FOR OTHERS WHO NEED TO KNO
2C5B   C8                   INY			;POINT TO FIRST BYTE OF STRING
2C5C   98                   TYA			;UPDATE 'VARADR'
2C5D   20 81 2C             JSR UPDVAR
2C60   A0 00                LDY #$00		;POINT TO FIRST BYTE OF STRING
2C62   A9 20                LDA #$20		;GET A BLANK
2C64   91 37      STRINI    STA (VARADR),Y	;SET STRING TO ALL BLANKS
2C66   C8                   INY
2C67   C4 64                CPY STRSIZ		;DONE YET?
2C69   D0 F9                BNE STRINI		;NO, LOOP TILL STRING IS ALL BLANKS
2C6B   A9 FF                LDA #$FF		;GET THE END OF VARIABLE LIST MARKER
2C6D   91 37                STA (VARADR),Y	;FLAG END OF LIST
2C6F   98                   TYA			;UPDATE 'VARADR'
2C70   20 8F 2C             JSR UBDENV
2C73   4C F1 2B             JMP GETSTC		;GET BYTE FROM STRING AND RETURN
2C76   A5 3E      VARINI    LDA $3E		;GET ADDR OF START OF VARIABLE LIST
2C78   85 37                STA VARADR		;AND SET POINTER
2C7A   A5 3F                LDA VARBEG+1
2C7C   85 38                STA VARADR+1
2C7E   60                   RTS			;AND RETURN

2C7F   A9 08      NXTVAR    LDA #VARSIZ		;ADD IN SIZE OF NUMERIC VARIABLE
2C81   18         UPDVAR    CLC			;SETUP FOR ADDITION
2C82   65 37                ADC VARADR		;TO 'VARADR'
2C84   85 37                STA VARADR
2C86   A5 38                LDA VARADR+1
2C88   69 00                ADC #$00
2C8A   85 38                STA VARADR+1
2C8C   60                   RTS
                  ;
                  ; ROUTINE TO UPDATE THE END OF THE VARIABLE LIST
                  ;
2C8D   A9 08      UPDEND    LDA #VARSIZ		;ADD SIZE OF NUMERIC VARIABLE
2C8F   18         UBDENV    CLC
2C90   65 37                ADC VARADR		;ADD NUMBER IN ACCUMULATOR 'VARADR'
2C92   85 42                STA VAREND		;AND STORE RESULT IN 'VAREND'
2C94   A5 38                LDA VARADR+1
2C96   69 00                ADC #$00		;ADD IN THE CARRY
2C98   85 43                STA VAREND+1
2C9A   60         BOMSVR    RTS			;AND RETURN
                  ;
                  ;ROUTINE TO BOMB OUT IF THE VARIABLE IS A STRING VARIABLE
                  ;
2C9B   A5 3B      BOMSTV    LDA STRSWT		;GET A STRING FLAG
2C9D   F0 FB                BEQ BOMSVR		;RETURN IF NOT A STRING
2C9F   00                   BRK			;TRAP
2CA0   DD                   .BYTE $DD      	;?STRING VARIABLE NOT ALLOWED HERE 
                  ;
                  ;		'VARIABLE MANIPULATION UTILITIES
                  ;
                  ;"PUTVAR" PUT NUMBER IN FAC1 INTO THE VARIABLE
                  ;
2CA1   A0 03      PUTVAR    LDY #$03		;POINT TO START OF VALUE
2CA3   B9 7D 00   PUTV1     LDA $007D,Y		;GET A BYTE FROM FAC1
2CA6   91 37                STA (VARADR),Y	;STORE IT INTO VARIABLE
2CA8   C8                   INY			;POINT TO NEXT BYTE
2CA9   C0 08                CPY #VARSIZ		;REACHED END OF VARIABLE YET?		
2CAB   D0 F6                BNE PUTV1		;NO, THEN MOVE SOME MORE
2CAD   60                   RTS			;*** MUST RETURN WITH Z BIT = ! ! ***

                  ; "FETVAR" FETCH VARIABLE VALUE INTO FAC1

2CAE   A0 03      FETVAR    LDY #$03		;POINT TO START OF VALUE
2CB0   B1 37      FETV1     LDA (VARADR),Y	;GET A BYTE FROM VARIABLE
2CB2   99 7D 00             STA $007D,Y		;PUT IT INTO FAC1
2CB5   C8                   INY			;POINT TO NEXT BATE
2CB6   C0 08                CPY #VARSIZ		;REACHED THE END OF VARIABLE YET?
2CB8   D0 F6                BNE FETV1		;NO, THEN MOVE ANOTHER BYTE
2CBA   60                   RTS			;YES, RETURN

                  ;"PUSHIV" PUSH INCREMENT AND VARIABLE ADDR ON STACK USED BY "FOR" COMMAND

2CBB   A2 37      PUSHIV    LDX #VARADR		;POINT TO VARIABLE ADDR
2CBD   20 69 28             JSR PUSHB2		;PUSH IT INTO STACK
2CC0   4C 84 28             JMP PHFAC2		;* PJMP * PUSH FAC2 INTO STACK AND RETURN

                  ;"POPIV" POP INCREMENT AND VARIABLE ADDR OFF STACK

2CC3   20 9A 28   POPIV     JSR PLFAC2		;RESTORE INTO FAC2
2CC6   A2 38                LDX #VARADR+1	;POINT TO VARIABLE ADDR
2CC8   4C 59 28             JMP POPB2		;* PJMP * RESTORE INTO VARIABLE ADDR AND RETURN

                  ;ZERO THE FLOATING POINT ACCUMULATOR FACE1

2CCB   A2 04      ZRFAC1    LDX #NUMBF-1	;POINT TO LAST BYTE
2CCD   A9 00                LDA #$00		;LOAD A ZERO
2CCF   95 80      ZRFAC     STA X1,X		;ZERO THE BYTE
2CD1   CA                   DEX			;POINT TO NEXT ONE
2CD2   D0 FB                BNE ZRFAC		;LOOP TILL ALL OF MANTISSA ZEROED
2CD4   A9 80                LDA #$80		;NOW SET EXPONENT
2CD6   85 80                STA X1
2CD8   60                   RTS			;AND RETURN
                  ;
                  ;		'INTERRUPT HANDLERS'
                  ;
2CD9   48         NOTBRK    PHA			;SAVE THE PROCESSOR STATUS		
2CDA   A9 ED                LDA #UNKINT		;UNKNOWN INTERRUPT
2CDC   48                   PHA			;SAVE CODE ON STACK
2CDD   D0 22                BNE BERROR		;AND PRINT ERROR CODE
2CDF   EA         NMISRV    NOP			;CURRENTLY PONT NMI'S AS UNKNOWNS
2CE0   85 71      INTSRV    STA ACSAV		;SAVE ACCUMULATOR
2CE2   68                   PLA			;GET THE PROCESSOR STATUS
2CE3   24 70                BIT MSKBRK		;IS B BIT ON?
2CE5   F0 F2                BEQ NOTBRK		;BRANCH TO INTERRUPT SERVICE CHAIN
2CE7   85 72                STA STATUS		;SAVE OLD PROCESSOR STATUS	
2CE9   68                   PLA			;GET THE LOW ORDER RETURN ADDRESS
2CEA   18                   CLC			;GET READY FOR ADD
2CEB   69 FF                ADC #$FF		;ADD IN A -1
2CED   85 73                STA ITEMP1		;STORE IT IN PAGE ZERO
2CEF   68                   PLA			;GET HIGH ORDER RETURN ADDR
2CF0   69 FF                ADC #$FF		;ADD IN A -1
2CF2   85 74                STA ITEMP1+1	;STORE IN PAGE ZERO
2CF4   98                   TYA			;GET Y REGISTER
2CF5   48                   PHA			;SAVE ON STACK
2CF6   A0 00                LDY #$00		;OFFSET OF ZERO
2CF8   B1 73                LDA (ITEMP1),Y	;GET BRK CODE	
2CFA   48                   PHA			;SAVE ON STACK
2CFB   30 04                BMI BERROR		;BRANCH IF A SOFTWARE DETECTED ERROR
2CFD   68                   PLA			;POSITIVE ERROR CODE, GET IT BACK
2CFE   A9 EE                LDA #UNRBRK		;UNRECOGNIZABLE BREAK
2D00   48                   PHA			;SAVE ON STACK
                  ;
                  ;		ERROR CODE OUTPUT ROUTINE
                  ;
2D01   A9 FF      BERROR    LDA #$FF		;GET -1
2D03   85 81                STA M1		;FOR HIGH ORDER
2D05   68                   PLA			;GET THE NEG ERROR CODE
2D06   85 82                STA M1+1		;STORE INIC LOW ORDER
2D08   20 4D 32             JSR FLT16		;FLOAT IT
2D0B   20 0D 20             JSR SETUP		;RESET AND INITIALIZE IMPORTANT STUFF
2D0E   20 99 2D             JSR CRLF		;ADVANCE A LINE
2D11   A9 3F                LDA #$3F		;'?' INDICATE AN ERROR
2D13   20 02 29             JSR PRINTC		;
2D16   20 5E 26             JSR OUTLN0		;OUTPUT IT
2D19   A5 26                LDA PC		;GET HIGH ORDER FOCAL STATEMENT COUNTER
2D1B   10 04                BPL BERR1		;BRANCH IF ERROR OCCURED IN A STORED STATEMENT
2D1D   C9 FE                CMP #STRLIN		;DID ERROR OCCUR WHILE EXECUTING A STRING?
2D1F   D0 32                BNE BERRC		;NO, THEN ERROR OCCURED IN DIRECT COMMAND
2D21   A9 20      BERR1     LDA #$20		;SPACE DOR LOOKS
2D23   20 02 29             JSR PRINTC		;
2D26   A9 40                LDA #$40		;NOW AN '@'
2D28   20 02 29             JSR PRINTC		
2D2B   A9 20      L2D2B     LDA #$20		;ANOTHER SPACE FOR THE LOOKS
2D2D   20 02 29             JSR PRINTC
2D30   20 0A 27             JSR PUSHTP		;SAVE THE TEXTPOINTERS
2D33   A5 26                LDA PC		;EXECUTING A STRING WHEN ERROR OCCURED?
2D35   10 0C                BPL BERR2		;BRANCH IF NOT, PRINT STATEMENT NUMBER
2D37   A5 27                LDA PC+1		;YES, THEN GET THE STRING NAME
2D39   20 E7 23             JSR PRTVNM		;AND PRINT IT
2D3C   A9 24                LDA #$24		;INDICATE IT'S A STRING
2D3E   20 02 29             JSR PRINTC		
2D41   D0 0D                BNE BERR3		;AND UNCONDITIONALLY PRESS ON
2D43   A9 26      BERR2     LDA #PC		;GET ADDR OF WHERE PROGRAM COUNTER IS STORED
2D45   85 28                STA TXTADR		;MAKE TEXT POINTER POINT TO IT
2D47   A9 00                LDA #$00
2D49   85 29                STA TXTADR+1	;HIGH ORDER IS ZERO
2D4B   85 2A                STA TEXTP
2D4D   20 31 26             JSR PRNTLN		;OUTPUT THE LINE NUMBER
2D50   20 11 27   BERR3     JSR POPTP		;RESTORE TEXT POINTERS
                   				;FALL INTO 'BERRC'
                  ;
                  ;		'MORE INTERRUPT HANDLERS'
                  ;
2D53   20 96 2D   BERRC     JSR CRLF2		;ADVANCE TWO LINES
2D56   A0 00                LDY #$00		;POINT TO FIRST CHAR IN LINE
2D58   A5 26                LDA PC		;DIRECT COMMAND OR STRING?
2D5A   30 02                BMI OUTCMD		;BRANCH IF YES
2D5C   A0 02                LDY #$02		;NO, THEN POINT PAST LINE NUMBER
2D5E   C4 2A      OUTCMD    CPY TEXTP		;ARE WE AT FRONT OF LINE?
2D60   F0 31                BEQ BERRET		;BRANCH IF YES, DON'T OUTPUT SPECIAL ERROR AID
2D62   98         OUTCML    TYA			;SAVE Y OUTPUT ACROSS OUTPUT CALL
2D63   48                   PHA
2D64   B1 28                LDA (TXTADR),Y	;OUTPUT CHAR FROM COMMAND LINE SO USER CAN SEE
2D66   20 02 29             JSR PRINTC
2D69   C9 0D                CMP #$0D		;REACHED END OF LINE YET?
2D6B   F0 05                BEQ EREOL		;BRANCH IF YES,
2D6D   68                   PLA			;RESTORE Y REG
2D6E   A8                   TAY
2D6F   C8                   INY			;POINT TO THE NEXT CHAR IN THE COMMAND LINE
2D70   D0 F0                BNE OUTCML		;AND LOOP TILL ALL OF THE COMMAND LINE HAS BEEN OUTPUT
2D72   68         EREOL     PLA			;ADJUST STACK
2D73   20 9E 2D             JSR OUTLF		;FOLLOW WITH A LINE FEED
2D76   C6 2A      CHKERR    DEC TEXTP		;COUNT DOWN NUMBER OF BYTES TILL ERROR
2D78   A0 00                LDY #$00		;ASSUME WE COUNT BACK TO ZERO
2D7A   A5 26                LDA PC		;DIRECT COMMAND OR STRING
2D7C   30 02                BMI CHKERC		;BRANCH IF YES
2D7E   A0 02                LDY #$02		;NO, THEN WE ONLY COUNT BACK TO LINE NUMBER
2D80   C4 2A      CHKERC    CPY TEXTP		;HAVE WE OUTPUT ENOUGH SPACES TO GET ERROR BYTE?
2D82   F0 07                BEQ EARROW		;BRANCH IF YES, OUTPUT UPARROW TO FLAG CHARACTER
2D84   A9 20                LDA #$20		;NO, THEN ADVANCE ONE SPACE
2D86   20 02 29             JSR PRINTC		
2D89   10 EB                BPL CHKERR		;AND UNCONDITIONALLY CHECK AGAIN
2D8B   A9 5E      EARROW    LDA #$5E		;OUTPUT UPARROW TO INDICATE WHERE ERROR IS
2D8D   20 02 29             JSR PRINTC
2D90   20 96 2D             JSR CRLF2		;AND ADVANCE FOR LOOKS
2D93   4C 31 20   BERRET    JMP START		;AND RESTART
                  ;
                  ;
2D96   20 99 2D   CRLF2     JSR CRLF		;ADVANCE TWO LINES
2D99   A9 0D      CRLF      LDA #$0D		;A CARRIAGE RETURN
2D9B   20 02 29             JSR PRINTC
2D9E   A9 0A      OUTLF     LDA #$0A		;AND A LF
2DA0   4C 02 29             JMP PRINTC		;* PJMP * TO PRINT ROUTINE
                  ;
                  ;		'INTEGER LINE NUMBER INPUT ROUTINE'
                  ;
                  ; 'GETLIN' THIS ROUTINE IS CALLED IF THE FIRST CHAR OF A LINE NUMBER
                  ; IS 0-9 FOR ADDED SPEED, AS THE CALL TO 'EVAL' IS POWERFUL
                  ; BUT SLOW (SEE 'GETLN').
                  ;
2DA3   20 C2 2D   GETILN    JSR GETIN 		;GET A TWO-DIGIT INTEGER
2DA6   85 2C                STA GRPNO		;SAVE AS GROUP NUMBER
2DA8   20 3E 2B             JSR TTERMS		;IS TERMINATOR ONE WE RECOGNIZE?
2DAB   F0 31                BEQ GETIR		;YES, THEN RETURN
2DAD   C9 2E                CMP #$2E		;NO, IS IT A PERIOD?
2DAF   D0 29                BNE GETBAD		;NO, THEN A BAD LINE NUMBER
2DB1   20 BB 29             JSR TESTNS		;ANOTHER NUMBER?
2DB4   B0 24                BCS GETBAD		;NO, THEN ERROR
2DB6   20 C2 2D             JSR GETIN		;YES, THEN GET NEXT NUMBER
2DB9   90 04                BCC LNOK		;BRANCH, IF TWO-DIGIT OUTPUT
2DBB   AA                   TAX			;MOVE INTO X
2DBC   BD DF 2D             LDA TENS,X		;YES, THEN ASSUME TRAILING ZERO
2DBF   85 2D      LNOK      STA LINENO		;SAVE THE LINE (STEP) NUMBER
2DC1   60                   RTS			;AND RETURN
                  ;
2DC2   29 0F      GETIN     AND #$0F		;MAKE 0-9
2DC4   48                   PHA			;SAVE ON STACK
2DC5   20 BB 29             JSR TESTNS		;TEST NEXT NON-BLANK
2DC8   68                   PLA			;RESTORE SAVED NUMBER
2DC9   B0 13                BCS GETIR		;RETURN IF NOT A DIGIT
2DCB   AA                   TAX			;PLACE SAVED NUMBERINTO X
2DCC   A5 2B                LDA CHAR		;GET NEW DIGIT
2DCE   29 0F                AND #$0F		;FORM 0-9
2DD0   7D DF 2D             ADC TENS,X		;ADD IN PROPER HIGH ORDER
2DD3   48                   PHA			;SAVE NUMBER ON STACK
2DD4   20 BB 29             JSR TESTNS		;TEST NEXT NON-BLANK
2DD7   68                   PLA			;GET SAVED NUMBER BACK
2DD8   B0 03                BCS GETIRC		;BRANCH IF NOT A NUMBER
2DDA   4C 25 26   GETBAD    JMP BADLNO		;BAD LINE NUMBER BRANCH AID
2DDD   18         GETIRC    CLC			;INDICATE TWO DIGITS INPUT
2DDE   60         GETIR     RTS			;RETURN
                  ;
2DDF   00         TENS      .BYTE 0
2DE0   0A                   .BYTE 10
2DE1   14                   .BYTE 20
2DE2   1E 		    .BYTE 30
2DE3   28  		    .BYTE 40
2DE4   32      		    .BYTE 50		; Aresco code has a $15 here, clearly wrong
2DE5   3C  		    .BYTE 60                 
2DE6   46  		    .BYTE 70
2DE7   50  		    .BYTE 80             
2DE8   5A 		    .BYTE 90                  
                  ;
                  ;
                  ;
                  ;			FOCAL FUNCTIONS
                  ;
                  ;               ;	
2DE9   A0 00      FUNC      LDY #$00		; SET OFFSET TO ZERO
2DEB   8A                   TXA			;PLACE HASH CODE INTO ACCUMULATOR
2DEC   BE F5 34   FUNC1     LDX $34F5,Y		;GET TABLE VALUE
2DEF   F0 15                BEQ BADFUN		;END OF TABLE AND NOT FOUND
2DF1   D9 F5 34             CMP $34F5,Y		;MATCH YET?
2DF4   F0 03                BEQ GOTFUN		;YES, WE FOUND IT
2DF6   C8                   INY			;NO, POINT TO NEXT ENTRY
2DF7   D0 F3                BNE FUNC1		;AND TRY IT
2DF9   B9 2D 35   GOTFUN     LDA $352D,Y	;GET LOW ORDER ARRD OFROUTINE TO HANDLE
2DFC   85 5F                STA TEMP1		;FUNCTION
2DFE   B9 11 35             LDA $3511,Y		;GET HIGH ORDER
2E01   85 60                STA TEMP1+1		;STORE IT
2E03   6C 5F 00             JMP ($005F)		;AND GO TO IT (TEMP1)

2E06   00         BADFUN    BRK			;TRAP
2E07   E2                   .BYTE UNRFUN	;?UNRECOGNIZABLE FUNCTION NAME
                  ;
                  ;	FABS - ABS. VALUE FUNCTION
                  ;
2E08   20 F7 33   FABS      JSR ABSF1		;TAKE ABSOLUTE VALUE OF FAC1 (vers.4=$5523)
2E0B   4C 14 2E             JMP FPOPJ		;*PJMP* AND RETURN
                  ;
                  ;	FINT & FINR - RETURN INTEGER FUNCTIONS
                  ;
2E0E   20 A7 2F   FINT      JSR INTFIX		; MAKE FAC1 AN INTEGER (VERS.4=$5052)
2E11   20 39 32   FLPOPJ    JSR FLOAT		; FLOAT ALL BITS
2E14   20 4B 28   FPOPJ     JSR POPJ		; *FJMP* AND RETURN
                  ;
                  ; 'FINR' INTEGERIZE AFTER ROUNDING
                  ;
2E17   20 93 2F   FINR      JSR INTGER		; FORM ROUNDED INTEGER
2E1A   4C 11 2E             JMP FLPOPJ		;*PJMP*FLOAT AND RETURN
                  ;
                  ;	         ROUTINES TO CHECK RANGE INPUT AND OUTPUT DEVICE NUMBERS
                  ;
2E1D   C9 03      CHKODV    CMP #$03		;COMPARE AC AGAINST MAX ALLOWED
2E1F   10 05                BPL RNGDEV		;BRANCH IF ERROR
2E21   60         CHKRTS    RTS			;RETURN IF OK
2E22   C9 03      CHKIDV    CMP #$03		;COMPARE AGAINST MAX
2E24   30 FB                BMI CHKRTS		;RETURN IF OK
2E26   C9 FF      RNGDEV    CMP #$FF		;MINUS 1?
2E28   F0 F7                BEQ CHKRTS		;BRANCH IF YES, ALWAYS IN RANGE
2E2A   00                   BRK			;TRAP
2E2B   F0 		    .BYTE DEVRNG	;DEVICE NUMBER OUT OF RANGE
                  ;
                  ;	         "FINI" INITIALIZE INPUT DEVICE 
                  ;
2E2C   20 93 2F	  FINI	    JSR INTGER   	;MAKE ARGUMENT INTEGER
2E2F   30 06                BMI ININRET		;IGNORE IF NEGATIVE
2E31   20 22 2E             JSR CHKIDV		;CHECK FOR VALIDITY
2E34   20 8D 2E             JSR INI		;GO CALL APPROPRIATE ROUTINE	
2E37   4C 11 2E   INIRET    JMP FLPOPJ		;NO ERRORS, RETURN
                  ;
                  ;            'FINO' INITIALIZE OUTPUT DEVICE
                  ;
2E3A   20 93 2F   FIND      JSR INTGER		;MAKE ARGUMENT AN INTEGER
2E3D   30 F8                BMI ININRET		;IGNORE IF NEGATIVE
2E3F   20 1D 2E             JSR CHKODV		;CHECK FOR VALIDITY
2E42   20 A2 2E             JSR INO		;GO CALL APPROPRIATE ROUTINE
2E45   4C 11 2E             JMP FLPOPJ		;NO ERRORS - RETURN
                  ;
                  ;            'FCLI' CLOSE INPUT DEVICE
                  ;
2E48   20 93 2F   FCLI      JSR INTGER		;MAKE ARGUMENT AN INTEGER
2E4B   30 06                BMI CLIRET		;IGNORE IF NEGATIVE
2E4D   20 22 2E   L2E4D     JSR CHKIDV		;RANGE CHECK THE DEVICE NUMBER
2E50   20 B6 2E             JSR CLI		;CALL DEVICE DEPENDENT CODE
2E53   4C 11 2E   CLIRET    JMP FLPOPJ		;NO ERRORS - RETURN
                  ;
                  ; 		"FCLO" CLOSE OUTPUT DEVICE
                  ;
2E56   20 93 2F   FCLO      JSR INTGER		;MAKE ARGUMENT AN INTEGER
2E59   30 F8                BMI CLIRET		;IGNORE IF NEGATIVE
2E5B   20 1D 2E             JSR CHKODV		;RANGE CHECK THE DEVICE NUMBER
2E5E   20 C2 2E             JSR CLO		;CALL DEVICE DEPENDENT CODE
2E61   4C 11 2E             JMP FLPOPJ		;NO ERRORS - RETURN
                  ;
                  ; 		"FCON" SET CONSOLE
                  ;
2E64   20 93 2F   FCON      JSR INTGER		;MAKE ARGUMENT AN INTEGER
2E67   30 11                BMI RETCON		;BRANCH IF NEGATIVE
2E69   20 22 2E             JSR CHKIDV		;MAKE SURE DEVICE IS IN RANGE FOR BOTH INPUT
2E6C   20 1D 2E             JSR CHKODV		;AND OUTPUT
2E6F   85 6A                STA CONDEV		;MAKE IT CURRENT CONSOLE	
2E71   20 15 20             JSR CLRDEV		;MAKE CURRENT IO DEVICE
2E74   20 27 20             JSR INIDEV		;INITIALIZE IT FOR INPUT AND OUTPUT
2E77   4C 11 2E             JMP FLPOPJ		;*PJMP* NO ERRORS - RETURN
2E7A   A5 6A      RETCON    LDA CONDEV		;GET THE DEVICE NUMBER OF CONSOLE
2E7C   20 41 32             JSR FLT8		;FLOAT IT
2E7F   4C 14 2E             JMP FPOPJ		;*PJMP* AND RETURN
                  ;
                  ; 		"FCUR" CONSOLE CURSOR ADDRESSING FUNCTION
                  ;		NOTE:	THIS FUNCTION IS DEVICE DEPENDENT, AND IS HERE
                  ;				PRIMARILY BY POPULAR DEMAND. THE FUNCTION HAS
                  ;				TWO ARGUMENTS. THE FIRST IS THE ROW, THE SECOND	
                  ;				IS THE COLUMN, OF THE PLACE TO POSITION ON THE CONSOLE
                  ;				DEVICE (USUALLY ASSUMED TO BE CRT).
                  ;
2E82   20 79 2F   FCUR      JSR FI2ARG 		;PICK UP TWO INTEGER ARGS
2E85   20 40 29             JSR CONCUR		;*** CALL THE DEVICE DEPENDENT CODE ***
2E88   B0 29                BCS JOERRO		;BRANCH IF ERROR HAS OCCURED
2E8A   4C 11 2E             JMP FLPOPJ		;* PJMP * AND RETURN
                  ;
                  ;ROUTINES TO DISPATCH TO DEVICE DEPENDENT INITIALIZATION ROUTINE
                  ;ENTER EACH WITH THE DEVICE NUMBER IN THE ACCUMULATOR
                  ;THEY WILL RETURN ONLY IF NO ERRORS WERRE ENCOUNTERED
                  ;
2E8D   AA         INI       TAX				;USE AS OFFSET TO ADDR TABLE
2E8E   BD C3 35             LDA $35C3,X		;GET HIGH ORDER ADDR OF THE ROUTINE TO HANDLE
2E91   85 60                STA TEMP1+1		;SAVE IT
2E93   BD C8 35             LDA $35C8,X		;GET LOW ORDER ADDR
2E96   85 5F      INIC      STA TEMP1		;SAVE IT
2E98   18                   CLC			;ASSUME SUCCESSS
2E99   20 5E 00             JSR $005E		;CALL THE PROPER ROUTINE FOR THIS DEVICE
2E9C   90 03                BCC IRTS		;RETURN IF NO ERRORS
2E9E   4C D6 28             JMP IERRI		;ERROR, GO COMPLAIN
2EA1   60         IRTS      RTS

2EA2   AA         INO       TAX			;USE AS OFFSET
2EA3   BD CD 35             LDA L35CD,X		;GET HIGH ORDER OF THE ROUTINE TO HANDLE
2EA6   85 60                STA TEMP1+1		;SAVE IT
2EA8   BD D2 35             LDA $35D2,X		;GET LOW ORDER OF THE ROUTINE TO HANDLE
2EAB   85 5F      INOC      STA TEMP1		;SAVE IT
2EAD   18                   CLC			;ASSUME SUCCESS
2EAE   20 5E 00             JSR $005E		;CALL PROPER ROUTINE FOR THIS DEVICE
2EB1   90 EE                BCC IRTS		;RETURN IF NO ERRORS
2EB3   4C 24 29   JOERRO    JMP OERRO		;COMPLAIN IF ERRORS

2EB6   AA         CLI       TAX			;USE AS OFFSET TO TABLE
2EB7   BD D7 35             LDA $35D7,X		;GET HIGH ORDER ADDR OF THE DEVICE DEPENDENT CODE
2EBA   85 60                STA TEMP1+1
2EBC   BD DC 35             LDA $35DC,X		;GET LOW ORDER ADDR
2EBF   4C 96 2E             JMP INIC		;*PJMP* CALL DEVICE DEPENDENT CODE AND RETURN


2EC2   AA         CLO       TAX				;USE AS OFFSET TO TABLE
2EC3   BD E1 35             LDA $35E1,X		;GET HIGH ORDER ADDR OF THE DEVICE DEPENDENT CODE
2EC6   85 60                STA TEMP1+1
2EC8   BD E6 35             LDA $35E6,X 	;GET LOW ODER
2ECB   4C AB 2E             JMP INOC		;*PJMP* CALL DEVICE DEPENDENT CODE AND RETURN
                  ;
                  ; 		"FMEM"  MEMORY EXAMINE-DEPOSIT FUNCTION
                  ;
2ECE   20 79 2F   FMEM      JSR FI2ARG		;PICK UP TWO INTEGER ARGS
2ED1   A4 2B                LDY CHAR		;GET THE TERMINATOR
2ED3   C0 2C                CPY #$2C		;ANOTHER ARG?
2ED5   F0 12                BEQ FMEMD		;YES, THEN IT'S THE DEPCSIT FUNCTION
2ED7   85 56                STA ITMP1H		;SAVE HIGH ORDER ARRD TO EXAMINE
2ED9   86 55                STX ITMP1L		;SAVE THE LOW ORDER ADDR TO EXAMINE			
2EDB   A0 00                LDY #$00		;FORM OFFSET OF ZERO
2EDD   B1 55                LDA (ITMP1L),Y	;GET DATA STORED IN THE LOCATION
2EDF   85 82      ST16PJ    STA M1+1		;SAVE IN INTEGER
2EE1   84 81                STY M1		;HIGH ORDER OF ZERO
2EE3   20 4D 32   FL16PJ    JSR FLT16		;FLOAT A 16 BIT INTEGER
2EE6   4C 14 2E             JMP FPOPJ		;*PJMP* AND RETURN

2EE9   48         FMEMD     PHA			;SAVE HIGH ORDER
2EEA   8A                   TXA			;
2EEB   48                   PHA			;AND LOW ORDER 
2EEC   20 89 2F             JSR NXIARG		;PICK UP THE NEXT INTEGER ARG
2EEF   A8                   TAY			;SAVE IN Y REGISTER FOR A MOMENT
2EF0   68                   PLA			;GET LOW ORDER ADDR BACK
2EF1   85 55                STA ITMP1L					
2EF3   68                   PLA			;GET HIGH ORDER ADDR BACK
2EF4   85 56                STA ITMP1H	
2EF6   98                   TYA			;GET DATA TO DEPOSIT BACK
2EF7   A0 00                LDY #$00		;SET OFFSET OF ZERO
2EF9   48                   PHA				;SAVE DATA TO DEPOSIT
2EFA   B1 55                LDA (ITMP1L),Y	;READ THE LOCATION
2EFC   85 82                STA M1+1		;SAVE AS INTEGER
2EFE   84 81                STY M1		;HIGH ORDER OF ZERO
2F00   68                   PLA			;GET DATA TO DEPOSIT BACK AGAIN
2F01   91 55                STA (ITMP1L),Y	;STORE IN THE ADDR	
2F03   A5 2B                LDA CHAR		;GET TERMINATOR
2F05   C9 2C                CMP #$2C		; ',' MORE ARGS?
2F07   D0 DA                BNE FL16PJ		;* PJMP * NO, FLOAT AND RETURN
2F09   20 1C 28             JSR PUSHJ		;MOVE PAST COMMA,
2F0C   03 2A                .WORD EVALM1	;EVALUATE NEXT ARG
2F0E   4C CE 2E             JMP FMEM		;AND TRY AGAIN
                  ;
                  ;		"FOUT" OUTPUT ASCII EQUIVALENT
                  ;
2F11   20 93 2F   FOUT      JSR INTGER		;FORM INTEGER
2F14   20 02 29             JSR L2902		;OUTPUT THE CHARACTER
2F17   4C 11 2E             JMP FLPOPJ		;* PJMP * FLOAT AND RETURN
                  ;
                  ; 		"FCHR" RETUNR DECIMAL EQUIVALIENT CF ASCII CHAR INPUT
                  ;
2F1A   20 20 2F   FCHR      JSR GICHR		;GET A CHAR FROM INPUT DEVICE 
2F1D   4C E3 2E             JMP FL16PJ		;* PJMP * FLOAT AND RETURN
                  ;
                  ; ROUTINE TO INPUT ONE CHAR FROM INPUT DEVICE INTO FAC1
                  ;
2F20   A9 00      GICHR     LDA #$00		;ZERO HIGH ORDER
2F22   85 81                STA M1		;			
2F24   A5 2B                LDA CHAR		;SAVE CURRENT HAR
2F26   48                   PHA
2F27   20 C0 28             JSR READC		;NEXT CHAR FROM INPUT DEVICE
2F2A   85 82                STA M1+1		;STORE IN LOW ORDER
2F2C   68                   PLA			;RESTORE SAVED CHAR
2F2D   85 2B                STA CHAR		
2F2F   A5 82                LDA M1+1		;GET CHAR INPUT INTO ACCUMULATOR
2F31   60                   RTS			;AND RETURN
                  ;
                  ; 		"FECH" SET CHAR ECHO CONTROL
                  ;
2F32   20 93 2F   FECH      JSR INTGER		;FORM INTEGER
2F35   85 6B                STA ECHFLG		;SAVE IN FLAG FOR LATER REFERENCE
2F37   4C 11 2E             JMP FLPOPJ      	;* PJMP * FLOAT AND RETURN
				  ;
                  ; 		"FIDV" SET INPUT DEVICE FUNCTION
                  ;
2F3A   A2 44      FIDV      LDX #STIADR		;GET ADDR TO STORE INTO STRING INFORMATION
2F3C   20 5F 2F             JSR GTDEVN		;GET DEVICE NUMBER (POSSIBLY A STRING)
2F3F   20 22 2E             JSR CHKIDV		;RANGE CHECK IT
2F42   A6 66                LDX IDEV		;SAVE PREVIOUS VALUE FOR POSSIBLE RESTORE
2F44   86 68                STX IDVSAV		;
2F46   85 66                STA IDEV		;MAKE IT THE CURRENT INPUT DEVICE
2F48   4C 59 2F             JMP FIODRT		;* PJMP * SET FAC1 TO ZERO, THEN RETURN
                  ;
                  ; 		"FODV" SET OUTPUT DEVICE FUNCTION
                  ;
2F4B   A2 48      FODV      LDX #STOADR		;GET SDDR TO STORE STRING INFORMATION
2F4D   20 5F 2F             JSR GTDEVN		;GET DEVICE NUMBER (POSSIBLY A STRING)
2F50   20 1D 2E             JSR CHKODV		;RANGE CHECK IT
2F53   A6 67                LDX ODEV		;SAVE PREVIOUS VALUE FOR POSSIBLE RESTORE
2F55   86 69                STX ODVSAV
2F57   85 67                STA ODEV		;SET AS OUTPUT DEVICE
2F59   20 CB 2C   FIODRT    JSR ZRFAC1		;RETURN A VALUE OF ZERO FOR THE FUNCTION 
2F5C   4C 11 2E             JMP FLPOPJ		;* PJMP * FLOAT AND RETURN
                  ;
                  ; ROUTINE TO GET A DEVICE NUMBER (POSSIBLY A STRING)
                  ;
2F5F   A5 3B      GTDEVN    LDA STRSWT		;WAS ARGUMENT A STRING VARIABLE?
2F61   D0 03                BNE STRDEV		;BRANCH IF YES
2F63   4C 93 2F             JMP INTGER		;* PJMP * NO, JUST TO INTEGRIZE ARG AND RETURN
2F66   A5 37      STRDEV    LDA VARADR		;STORE BASE ADDR OF STRING
2F68   95 00                STA $00,X		;IN POINTER
2F6A   A5 38                LDA VARADR+1
2F6C   95 01                STA $01,X
2F6E   A5 3A                LDA VSUB+1		;GET SUBSCRIPT OF PLACE TO START
2F70   95 02                STA $02,X		
2F72   A5 3C                LDA VSIZE		;AND GET MAX SIZE OF STRING
2F74   95 03                STA $03,X
2F76   A9 FF                LDA #$FF		;RETURN DEVICE NUMBER OF -1
2F78   60                   RTS			;AND RETURN

2F79   A5 2B      FI2ARG    LDA CHAR		;GET TERMINATOR
2F7B   C9 2C                CMP #$2C		;',' ANOTHER ARG?
2F7D   D0 12                BNE FARGM		;BRANCH IF ARG IS MISSING
2F7F   20 93 2F             JSR INTGER		;GET A SINGLE BYTE INTEGER
2F82   48                   PHA			;SAVE ACROSS 'EVAL' CALL
2F83   20 89 2F             JSR NXIARG		;GET ANOTHER ARG
2F86   AA                   TAX			;SAVE THE SECOND ARGUMENT
2F87   68                   PLA			;GET THE FIRST ARGUMENT 
2F88   60                   RTS			;AND RETURN
                  ;
2F89   20 1C 28   NXIARG    JSR PUSHJ		;MOVE PAST COMMA, EVALUATE NEXT ARGUMENT
2F8C   03 2A	  	    .WORD EVALM1
2F8E   4C 93 2F             JMP INTGER		;*PJMP* FORM SINGLE BYTE INTEGER AND RETRUN

2F91   00         FARGM     BRK			;TRAP
2F92   DF         	   .BYTE     ARGM	;?ARGUMENT MISSING IN FUNCTION
                  ;
                  ;	ROUTINE TO GENERATE A ROUNDED INTEGER
                  ;
2F93   A2 96      INTGER    LDX #FHALF		;MOVE CONSTANT .50
2F95   A0 7B                LDY #$7B		;INTO FAC2
2F97   20 FF 33             JSR MOVXY
2F9A   20 29 32             JSR SWAP		;PUT .5 IN FAC1
2F9D   A5 7C                LDA $7C		;GET SIGN OF FAC2
2F9F   10 03                BPL INTG1		;OK IF POSITIVE
2FA1   20 B8 32             JSR FCOMPL		;MAKE -.50
2FA4   20 79 32   INTG1     JSR FADD		;ADD IT IN AS ROUNDING
2FA7   20 18 33   INTFIX    JSR FIX		;AND FORM 23 BIT INTEGER
2FAA   A5 83                LDA M1+2		;GET LOW ORDER IF CALLER NEEDS IT			
2FAC   60                   RTS			;AND RETURN
                  ;
                  ; 		"FPIC" SOFTWARE PRIORITY INTERRUPT CONTROL FUNCTION
                  ;
2FAD   20 1C 28   FPICC     JSR PUSHJ		;CALL 'EVAL' TO PICK UP NEXT ARG
2FB0   03 2A        		.WORD EVALM1
2FB2   A5 2B      FPIC      LDA CHAR		;GET CHAR WHICH TERMINATED ARGUMENT
2FB4   C9 2C                CMP #$2C		;IS THERE ANOTHER ARGUMENT TO FOLLOW
2FB6   D0 D9                BNE FARGM		;BRANCH IF NOT, GO COMPLAIN
2FB8   20 93 2F             JSR INTGER		;YES, PICK UP VALUE OF FIRST
2FBB   F0 27                BEQ PISET		;BRANCH IF LEVEL TO ENABLE IS 0
2FBD   48                   PHA				;SAVE LEVEL TO ENABLE
2FBE   20 92 29             JSR GETC		;MOVE PAST COMMA
2FC1   20 BC 25             JSR GETLNS		;AND PICK UP THE LINE NUMBER TO 'DO'
2FC4   68                   PLA				;GET LEVEL BACK
2FC5   AA                   TAX				;INTO X REGISTER
2FC6   A5 2C                LDA GRPNO		;GET GROUP NUMBER OF LINE TO 'DO'
2FC8   9D 8B 35             STA $358B,X		;SAVE FOR LATER USE
2FCB   A5 2D                LDA LINENO		;GET STEP NUMBER OF LINE TO 'DO'
2FCD   9D 94 35             STA $3594,X		;SAVE FOR LATER USE
2FD0   A5 6D                LDA ACTMSK		;GET MASK WHICH INDICATES WITH CHANNELS
2FD2   1D A6 35             ORA $35A6,X		;SET THE BIT FOR SPECIFIED CHANNELS
2FD5   85 6D                STA ACTMSK		;MAKING IT ACTIVE NOW
2FD7   A5 2B      ENDPIC    LDA CHAR		;GET CHAR WHICH TERMINATES SECOND ARG
2FD9   C9 2C                CMP #$2C		;',' ANY MORE ARGS?
2FDB   F0 D0                BEQ L2FAD		;BRANCH IF YES, PICK THEM UP
2FDD   A0 00                LDY #$00		;NO GET A ZERO
2FDF   A5 6D                LDA ACTMSK		;AND THE CURRENT ACTIVE MASK
2FE1   4C DF 2E             JMP ST16PJ		;* PJMP * STORE, FLOAT AND RETURN IT AS VALUE

2FE4   20 89 2F   PISET     JSR NXIARG		;GET NEXT ARG AS NUMBER
2FE7   A5 82                LDA M1+1		;IS IT NEGATIVE
2FE9   30 EC                BMI ENDPIC		;YES, THEN THIS CALL IS A NO-OP
2FEB   A5 83                LDA M1+2		;NO, GET THE INTEGER VALUE (0-255)
2FED   85 6D                STA ACTMSK		;AND STORE THAT AS NEW ACTIVE MASK
2FEF   4C D7 2F             JMP ENDPIC		;AND CHECK FOR MORE ARGUMENTS BEFORE RETURNING
                  ;
                  ;				'FOCAL STRING FUNCTIONS'
                  ;
                  ; 		"FISL" INITIALIZE STRING LENGTH
                  ;
2FF2   20 1C 28   FISLNX    JSR PUSHJ		;PICK UP NEXT ARGUMENT
2FF5   03 2A 		    .WORD EVALM1	
2FF7   A5 64      FISL      LDA STRSIZ		;SAVE DEFAULT STRING SIZE
2FF9   48                   PHA		
2FFA   20 93 2F             JSR INTGER		;GET FIRST ARGUMENT WHICH IS SIZE TO SET
2FFD   85 64                STA STRSIZ
2FFF   20 0E 30             JSR FGTSV		;GET NEXT ARGUMENT WHICH IS A STRING VARIABLE
						;IF NOT PREVIOUSLY DEFINED IT WILL BE DEFINED
						;WITH SUPPLIED LENGTH.
3002   68                   PLA			;RESTORE WITH LENGTH
3003   85 64                STA STRSIZ
3005   A5 2B                LDA CHAR
3007   C9 2C                CMP #$2C		;',' ANY MORE ARGS?
3009   F0 E7                BEQ FISLNX		;BRANCH IF YES, PROCESS THEM
300B   4C 14 2E             JMP FPOPJ		;* PJMP * NO, THEN RETURN
                  ;
                  ; ROUTINE TO GET A STRING VARIABLE FROM PROGRAM TEXT
                  ;
300E   A5 2B      FGTSV     LDA CHAR		;ANY MORE ARGUMENTS IN FUNCTION CALL?
3010   C9 2C                CMP #$2C
3012   D0 15                BNE FSTRBA		;BRANCH IF NOT, ERROR
3014   20 92 29             JSR GETC		;YES, MOVE PAST COMMA
3017   20 1C 28   FGTSV1    JSR PUSHJ		;CALL 'GETVAR' TO GET A VARIABLE
301A   51 2B                .WORD GETVAR
301C   A5 3B                LDA STRSWT		;WAS IT A STRING VARIABLE?
301E   D0 02                BNE SVOK		;BRANCH IF IT WAS 
3020   00                   BRK			;TRAP
3021   DC  		    .BYTE SVRO		;?STRING VARIABLE REQUIRED HERE
3022   A4 3A      SVOK      LDY VSUB+1		;GET ELEMENT POSITION
3024   A5 37                LDA VARADR		;AND LOW AND
3026   A6 38                LDX VARADR+1	;HIGH ORDER BASE ADDR OF STRING
3028   60                   RTS			;AND RETURN

3029   00         FSTRBA    BRK			;TRAP
302A   DB    	  	    .BYTE BASTRF	;?BAD OR MISSING ARGUMENT IN STRING FUNCTION
                  ;
                  ; 		"FSTI" INPUT A STRING FROM INPUT DEVICE
                  ;
302B   20 8D 30   FSTI      JSR SETSIO		;PICK UP ARGS
302E   20 20 2F   FSTINX    JSR GICHR		;GET A CHARACTER FROM INPUT DEVICE
3031   C5 3D                CMP VCHAR		;IS THIS THE TERMINATOR?
3033   F0 10                BEQ SENDIO		;YES, THEN THAT'S ALL FOLKS
3035   A4 3A                LDY VSUB+1		;GET SUBSCRIPT TO PLACE CHAR
3037   C9 7F                CMP #$7F		;IS THE CHARACTER A RUBOUT?
3039   F0 15                BEQ RUBSTI		;BRANCH IF YES, SEE IF WE DO SOMETHING
303B   91 37      FSTOC     STA (VARADR),Y  	;STORE CHAR THERE
303D   E6 3A                INC VSUB+1		;POINT TO NEXT
303F   E6 55                INC STRCNT		;COUNT THIS CHARACTER
3041   C6 59                DEC STRMAX		;REACH MAX ALLOWED?
3043   D0 E9                BNE FSTINX		;BRANCH IF NOT, INPUT MORE
3045   A9 00      SENDIO    LDA #$00		;STORE A ZERO IN HIGH ORDER
3047   85 81                STA M1			
3049   A5 55                LDA STRCNT		;GET NUMBER ACTUALLY MOVED
304B   85 82                STA M1+1		
304D   4C E3 2E             JMP FL16PJ		;* PJMP * FLOAT AND RETURN
                  ;
                  ;HERE IF RUBOUT SEEN DURING A STRING INPUT
                  ;
3050   A6 66      RUBSTI    LDX IDEV		;IS THE INPUT DEVICE
3052   E4 6A                CPX CONDEV		;THE CONSOLE?
3054   D0 E5                BNE FSTOC		;BRANCH IF NOT, DON'T DO ANYTHING SPECIAL
3056   C4 5D                CPY STBSAV		;YES, ARE WE TRYING TO RUBOUT PAST STARTING SUBSCRIPT?
3058   F0 D4                BEQ FSTINX		;BRANCH IF SO, DON'T DO ANYTHING, IGNORE RUBOUT
305A   A4 6B                LDY ECHFLG		;DOES USER WANT CHARACTER ECHOING?
305C   D0 0E                BNE RUBSC		;BRANCH IF ECHOING DISABLED
305E   A4 6C                LDY DELSPL		;DO WE DO FANCY CRT STYLE RUBOUTS?
3060   F0 05                BEQ RUBS1		;BRANCH IF NOT
3062   20 7D 29             JSR EATTVC		;YES, THEN EAT THE CHAR OFF CRT SCREEN
3065   10 05                BPL RUBSC		;AND DO COMMON THINGS
3067   A9 5C      RUBS1     LDA RUBECH		;ECHO PLAIN CHAR TO INDICATE A RUBOUT
3069   20 08 29             JSR PRINTC
306C   C6 3A      RUBSC     DEC VSUB+1		;PACK UP ONE BYTE IN THE STRING
306E   C6 55                DEC STRCNT		;DON'T COUNT THE CHARACTER RUBBED OUT
3070   E6 59                INC STRMAX
3072   4C 2E 30             JMP FSTINX		;AND GET NEXT CHARACTER
                  ;
                  ; 		"FSTO" OUTPUT A STRING TO OUTPUT DEVICE
                  ;
3075   20 8D 30   FSTO      JSR SETSIO		;GET ARGS
3078   A4 3A      FSTONX    LDY VSUB+1		;GET SUBSCRIPT OF BYTE IN STRING
307A   B1 37                LDA(VARADR),Y	;GET THE BYTE
307C   C5 3D                CMP VCHAR		;TERMINATOR?
307E   F0 C5                BEQ SENDIO		;BRANCH IF YES
3080   20 02 29             JSR PRINTC		;OUTPUT IT
3083   E6 3A                INC VSUB+1		;POINT TO NEXT BATE
3085   E6 55                INC STRCNT		;COUNT THIS ONE OUTPUR
3087   C6 59                DEC STRMAX		;OUTPUT MAX YET?
3089   D0 ED                BNE FSTONX		;BRANCH IF MORE TO OUTPUT
308B   F0 B8                BEQ SENDIO		;BRANCH IF WE HAVE HIT LIMIT
                  ;
                  ; ROUTINE TO GET ARGS FOR 'FSTI' AND 'FSTD'
                  ;
308D   A9 00      SETSIO    LDA #$00		;GET A ZERO
308F   85 55                STA STRCNT		;INIT BYTE COUNT TO ZERO
3091   20 93 2F             JSR INTGER		;GET MAX NUMBER OF CHARACTER TO MOVE
3094   85 59                STA STRMAX
3096   20 0E 30             JSR FGTSV		;GET THE STRING VARIABLE
3099   48                   PHA			;SAVE NEAT STUFF RETURNED
309A   8A                   TXA
309B   48                   PHA
309C   98                   TYA
309D   48                   PHA
309E   A5 2B                LDA CHAR		;IS THE OPTIONAL TERMINATOR ARG SUPPLIED?
30A0   C9 2C                CMP #$2C	 
30A2   F0 04                BEQ SETS1		;YES, THEN PICK IT UP
30A4   A9 FF                LDA #$FF		;NO, THEN SET IT TO $FF
30A6   D0 08                BNE SETS2		;AND ENTER COMMON CODE
30A8   20 1C 28   SETS1     JSR PUSHJ		;MOVE PAST COMMA, PICK UP NEXT ARG
30AB   03 2A                .WORD EVALM1
30AD   20 93 2F             JSR INTGER		;FORM INTEGER
30B0   85 3D      SETS2     STA VCHAR		;SAVE TERMINATION CHARACTER
30B2   68                   PLA			;RESTORE GOOD STUFF
30B3   85 3A                STA VSUB+1		;
30B5   85 5D                STA STBSAV		;REMEMBER SUBSCRIPT TO BEGIN I-O TO/FROM
30B7   68                   PLA				
30B8   85 38                STA VARADR+1
30BA   68                   PLA
30BB   85 37                STA VARADR
30BD   60                   RTS			;AND RETURN
                  ;
                  ; ROUTINE TO WRITE A STRING
                  ;
30BE   A4 4A      WSTRNG    LDY STOPNT 		;new line - not in the original
						;original code  (appears to be a patch
						;WSTRNG CPY STOMAX    in ProgExch code)
						;	BEQ WSRET
						;	STA (STOADR),Y
						;	INC STOPNT
						;WSRET 	PLA
						;	RTS
                  ;				; then go on with IOSRET
                  ;
30C0   C4 4B                CPY STOMAX			;BEYOND END OF STRING
30C2   F0 04                BEQ IOSRET			;BRANCH IF YES, IGNORE
30C4   91 48                STA (STOADR),Y		;NO, STORE CHAR IN STRING
30C6   E6 4A                INC STOPNT			;POINT TO NEXT BYTE

30C8   A9 0D      IOSRET    LDA #$0D			;RETURN A CR   
						;additional line in original: 
                  				;STA CHAR ;also in char
30CA   60                   RTS			;AND RETURN 
                  ;
                  ; ROUTINE TO INPUT FROM A STRING
                  ;
30CB   A4 46      RSTRNG    LDY STIPNT			;GET POINTER TO NEXT BYTE
30CD   C4 47                CPY STIMAX			;BEYOND END OF STRING?
30CF   F0 F7                BEQ IOSRET			;BRANCH IF YES, RETURN A CARRIAGE RETURN
30D1   B1 44                LDA (STIADR),Y		;NO, GET BYTE FROM STRING
30D3   85 2B                STA CHAR			;SAVE FOR THOSE WHO NEED IT
30D5   E6 46                INC STIPNT			;AND POINT TO NEXT
30D7   60                   RTS				;AND RETURN
                  ;
                  ; 		FSLK - STRING "LOOK" FUNCTION
                  ;
30D8   A5 3B      FSLK      LDA STRSWT			;WAS ARG A STRING VARIABLE
30DA   D0 02                BNE FSLK1			;YES, THEN PROCEED
30DC   00                   BRK				;TRAP
30DD   DB                   .BYTE BASTRF		;?BAD OR MISSING ARGUMENT IN STRING
30DE   A5 37      FSLK1     LDA VARADR			;COPY POINTERS INTO STRING1 POINTERS
30E0   85 55                STA STRAD1
30E2   A5 38                LDA VARADR+1
30E4   85 56                STA STRAD1+1
30E6   A5 3A                LDA VSUB+1
30E8   85 57                STA SBEG1			;STORE BEGINNING POSITION
30EA   20 0E 30             JSR FGTSV			;GET NEXT STRING PARAMETER
30ED   84 58                STY SEND1			;STORE ENDING POSITION
30EF   20 0E 30             JSR FGTSV			;GET STRING 2 POINTERS
30F2   85 59                STA STRAD2			;
30F4   86 5A                STX STRAD2+1
30F6   84 5B                STY SBEG2
30F8   20 0E 30             JSR FGTSV			;GET ENDING POSITION 
30FB   84 5C                STY SEND2			;STORE IT
30FD   A9 FF                LDA #$FF			;ASSUME -1 (STRING NOT FOUND)
30FF   85 81                STA M1
3101   85 82                STA M1+1
                  ;
                  ;SEARCH ROUTINE
                  ;
3103   20 41 31   LKFCHR    JSR CMPCHR			;FIRST CHAR MATCH?
3106   F0 09                BEQ FCMAT			;BRANCH IF YES
3108   C4 5C      CHKEOS    CPY SEND2			;NO, REACHES END OF STRING2?
310A   F0 32                BEQ SNOTF			;BRANCH IF YES, STRING1 NOT FOUND IN STRING2
310C   E6 5B                INC SBEG2			;NO, POINT TO NEXT CHAR IN STRING2
310E   4C 03 31             JMP LKFCHR			;AND TRY TO FIND CHAR MATCH
                  ;
                  ;  HERE IF FIRST CHAR IN STRING1 MATCHES A CHAR IN STRING2
                  ;
3111   20 4A 31   FCMAT     JSR PUSHSP			;SAVE CURRENT POSITION IN BOTH STRINGS
3114   A5 57      NXCMAT    LDA SBEG1			;REACHED END OF  FIRST STRING?
3116   C5 58                CMP SEND1						
3118   F0 13                BEQ SFOUND			;BRANCH IF YES, THEN STRING1 WAS FOUND IN STRING2
311A   C4 5C                CPY SEND2			;NO, REACHED END OF STRING2?	
311C   F0 1D                BEQ SNOTFP			;BRANCH IF YES, THEN STRING 1 CAN'T BE FOUND IN STRING2
311E   E6 57                INC SBEG1			;POINT TO NEXT CHAR IN EACH STRING
3120   E6 5B                INC SBEG2
3122   20 41 31             JSR CMPCHR			;MATCH?
3125   F0 ED                BEQ NXCMAT			;BRANCH IF YES, KEEP CHECKING AS LONG AS THEY MATCH
3127   20 56 31             JSR POPSP			;NO, THEN RETURN TO THE POINT OF FIRST CHAR MATCH
312A   4C 08 31             JMP CHKEOS			;AND TRY AGAIN FOR FIRST CHAR MATCH
312D   20 56 31   SFOUND    JSR POPSP			;RESTORE POINTERS TO POSITION OF FIRST CHAR MATCH
3130   A9 00                LDA #$00			;STORE 0 IN HIGH ORDER
3132   85 81                STA M1				
3134   A5 5B                LDA SBEG2			;RETURN SUBSCRIPT WHERE FIRST CHAR MATCHED
3136   85 82                STA M1+1			
3138   4C E3 2E             JMP FL16PJ			;* PJMP * FLOAT AND RETURN
313B   20 56 31   SNOTFP    JSR POPSP			;POP OFF SAVED POINTERS
313E   4C E3 2E   SNOTF     JMP FL16PJ			;FLOAT -1 AND RETURN STRING1 WAS NOT FOUND IN STRING2
                  ;
                  ; ROUTINES USED BY 'FSLK'
                  ;
3141   A4 57      CMPCHR    LDY SBEG1			;GET CHAR FROM STRING1
3143   B1 55                LDA (STRAD1),Y
3145   A4 5B                LDY SBEG2			;GET CHAR FROM STRING2
3147   D1 59                CMP (STRAD2),Y		;COMPARE THEM
3149   60                   RTS				;RETURN WITH Z=1 IF THEY ARE THE SAME
                  ;
314A   98         PUSHSP    TYA				;PRESERVE Y REGISTER
314B   48                   PHA		
314C   A2 55                LDX STRAD1			;SAVE STRING POINTERS ON STACK
314E   A0 08                LDY #$08
3150   20 6B 28             JSR PUSHB0
3153   68                   PLA				;RESTORE Y REGISTER
3154   A8                   TAY
3155   60                   RTS				;AND RETURN
                  ;
3156   98         POPSP     TYA				;PRESERVE Y REGISTER
3157   48                   PHA
3158   A2 5C                LDX STRAD1+7		;RESTORE STRING POINTERS
315A   A0 08                LDY #$08
315C   20 5B 28             JSR POPB0
315F   68                   PLA				;RESTORE Y REGISTER
3160   A8                   TAY
3161   60                   RTS				;AND RETURN
                  ;
                  ;  		'FSBR' SINGLE VALUED SUBROUTINE CALL
                  ;
3162   20 DF 25   FSBR      JSR GETLN1			;FINISH EVALUATING GROUP OR LINE TO "DO"
3165   08                   PHP				;SAVE STATUS FLAGS ON STACK
3166   A9 30                LDA #$30			;GET CODE NAME FOR VARIABLE '&0'
3168   85 3D                STA VCHAR			;SAVE AS VARIABLE NAME TO LOOK FOR
316A   A9 00                LDA #$00			;ALSO SET SUBSCRIPT TO ZERO
316C   85 39                STA VSUB
316E   85 3A                STA VSUB+1
3170   85 3B                STA STRSWT			;MAKE SURE STRING VARIABLE FLAG IS OFF
3172   20 1C 28             JSR PUSHJ			;CALL 'FNDVAR' TO LOCATE '&0(0)'
3175   C4 2B                .WORD FNDVAR
3177   20 29 32             JSR SWAP			;PUT CURRENT VALUE OF '&0' INTO FAC2
317A   20 BB 2C             JSR PUSHIV			;SAVE IT'S VALUE AND ADDR ON STACK
317D   A5 2B                LDA CHAR			;GET TERMINATOR
317F   C9 2C                CMP #$2C			;',' IS THERE ANOTHER ARGUMENT
3181   F0 02                BEQ FSBR1			;BRANCH IF YES, PRESS ON
3183   00                   BRK				;NO, TRAP
3184   DF                   .BYTE ARGM			;?ARGUMENT MISSING IN FUNCTION
3185   68         FSBR1     PLA				;GET FLAGS FROM 'GETLN' INTO ACCUMULATOR
3186   20 31 28             JSR PUSHA			;SAVE ON STACK
3189   A2 2C                LDX #GRPNO			;SAVE LINE OR GROUP TO 'DO'
318B   20 69 28             JSR PUSHB2
318E   20 1C 28             JSR PUSHJ			;MOVE PAST COMMA, EVALUATE NEXT ARGUMENT
3191   03 2A                .WORD EVALM1  
3193   A2 2D                LDX #LINENO			;GET LINE OR GROUP TO 'DO' BACK
3195   20 59 28             JSR POPB2			
3198   20 3F 28             JSR POPA			;GET 'GETLN'FLAGS BACK
319B   48                   PHA				;SAVE ON STACK FOR LATER 
319C   20 C3 2C             JSR POPIV			;GET VALUE OF '&0' AND POINTER TO IT
319F   20 BB 2C             JSR PUSHIV			;SAVE FOR LATER (VALUE IS IN FAC2)
31A2   20 A1 2C             JSR PUTVAR			;NOW SET '&0' TO ARG VALUE (IN FAC1)
                   ;
                   ;in original ProgExchange/6502 Group (missing here completely):
				   ;lda insw	;save where input is comming from
				   ;jsr pusha	;(program or input device)
				   ;lda #$0		;and force it to be program
				   ;sta insw
				   ;
31A5   68                   PLA				;GET STATUS FLAGS RETURNED BY 'GETLN'
31A6   AA                   TAX				;SAVE IN X REGISTER
31A7   20 1C 28             JSR PUSHJ			;NOW PERFORM THE 'DO' OF THE LINE OR GROUP
31AA   B6 21                .WORD D01
31AC   20 C3 2C             JSR POPIV			;RESTORE WHERE INPUT IS COMMING FROM
							;AND OLD VALUE IS IN FAC2
31AF   20 AE 2C             JSR FETVAR			;GET CURRENT VALUE IN FAC1
31B2   20 29 32             JSR SWAP			;OLD VALUE IN FAC1, CURRENT VALUE IN FAC2
31B5   20 A1 2C             JSR PUTVAR			;REPLACE OLD VALUE OF '&0' BEFORE CALL
31B8   20 29 32             JSR SWAP			;GET CURRENT VALUE OF '&0' INTO FAC1
31BB   4C 14 2E             JMP FPOPJ			;RETURN IT AS THE VALUE OF THE 'FSBR'
                  ;
                  ;		"FRAN" RANDOM NUMBER GENERATOR, 
		  ;       		RETURNS A FRACTION BETWEEN 0.00 AND 1.00
                  ;
31BE   20 93 2F   FRAN      JSR INTGER			;INTEGRIZE ARGUMENT
31C1   F0 0F                BEQ FRANC			;BRANCH IF =0, RETURN NEXT RANDOM NUMBER
31C3   10 04                BPL FRSET			;BRANCH IF >0, SET TO REPEATABILITY
31C5   A5 76                LDA HASH			;GET THE RANDOM NUMBER HASH VALUE
31C7   D0 02                BNE FRNINI			;AND RANDOMITE
31C9   A9 55      FRSET     LDA #$55			;SET TO ALTERNATING ZEROS AD ONES
31CB   A2 02      FRNINI    LDX #$02			;SETUP LOOP COUNTER
31CD   95 77      FRNILP    STA SEED,X			;STORE IN SEED
31CF   CA                   DEX				;POINT TO NEXT
31D0   10 FB                BPL FRNILP			;AND LOOP TILL DONE
31D2   A9 7F      FRANC     LDA #$7F			;SET EXPONENT OF FAC1
31D4   85 80                STA X1
31D6   18                   CLC				;ADD K TO SEED
31D7   A5 77                LDA SEED
31D9   69 B1                ADC #$B1
31DB   85 83                STA M1+2			;PUT RESULT IN LOW ORDER
31DD   85 77                STA SEED			;ALSO THIS PART IN SEED
31DF   A5 78                LDA SEED+1
31E1   69 0C                ADC #$0C
31E3   85 82                STA M1+1			;INTO MIDDLE ORDER
31E5   A5 79                LDA SEED+2
31E7   69 1B                ADC #$1B
31E9   29 7F                AND #$7F			;KILL SIGN BIT
31EB   85 81                STA M1
31ED   A5 83                LDA M1+2
31EF   0A                   ASL A			;2^17
31F0   18                   CLC
31F1   65 83                ADC M+2			;2^16
31F3   18                   CLC
31F4   65 81                ADC M1			;PLUS HIGH ORDER
31F6   85 79                STA SEED+2			;NEW SEED
31F8   18                   CLC
31F9   A5 83                LDA M1+2			;2^8 ADDED
31FB   65 82                ADC M1+1
31FD   85 78                STA SEED+1
31FF   A5 82                LDA M1+1
3201   65 79                ADC SEED+2
3203   85 79                STA SEED+2			;SEED NOW READY FOR NEXT TIME
3205   A9 00                LDA #$00			;GET A ZERO
3207   20 55 32             JSR NORM0			;NORMALIZE THE FRACTION
320A   4C 14 2E             JMP FPOPJ			;* pjmp * and return
                  ;
                  ;  in the original here are floating point package definitions...    ***
                  ;  1 BYTE EXPONENT, 4 BYTE MANTISSA (APPROX 9 SIG FIGS)
				  ;.DEF  SPACE=%40
				  ;.DEF  RUB=%177
				  ;.DEF  CR=%15
				  ;.DEF  LF=%12
				  
                  ;
                  ;  		CENTRAL ROUTINES
                  ;
320D   18         ADD       CLC
320E   A2 03                LDX #$03			;*INDEX FOR 4 BYTE ADD
3210   B5 81      ADD1      LDA M1,X			
3212   75 7C                ADC M2,X			;ADD NEXT BYTE
3214   95 81                STA M1,X
3216   CA                   DEX				;TO NEXT MORE SIG BYTE
3217   10 F7                BPL ADD1			;DO ALL THREE
3219   60                   RTS

321A   06 7A      MD1       ASL SIGN			;CLEAR LSB OF SIGN
321C   20 1F 32             JSR ABSWAP			;ABS VAL M1, THEN SWAP
321F   24 81      ABSWAP    BIT M1			;M1 NEG?
3221   10 05                BPL ABSWP1			;NO JUST SWAP
3223   20 B8 32             JSR FCOMPL			;YES, NEGATE IT
3226   E6 7A                INC SIGN			;COMPLEMENT SIGN
3228   38         ABSWP1    SEC				;FOR RETURN TO MUL/DIV
                  ;
                  ; SWAP FAC1 WITH FAC2
                  ;
3229   A2 05      SWAP      LDX #$05			;*FIVE BYTES TOTAL
322B   94 84      SWAP1     STY EM1,X			
322D   B5 7F                LDA X1M1,X			;SWAP A BYTE OF FAC1 WITH
322F   B4 7A                LDY SIGN,X			;FAC2 AND LEAVE COPY OF
					;$7A is X2M1 and SIGN. 
					;used SIGN, because it is defined!!!
3231   94 7F                STY X1M1,X			;M1 IN E, E+3 USED
3233   95 7A                STA SIGN,X
3235   CA                   DEX				;NEXT BYTE
3236   D0 F3                BNE SWAP1			;UNTIL DONE
3238   60                   RTS
                  ;
                  ; ROUTINE TO FLOAT 23 BITS OF MANTISSA
                  ;
3239   A9 96      FLOAT     LDA #FHALF			;SET EXPONENT TO 22 DECIMAL
323B   85 80                STA X1				
323D   A9 00                LDA #$00			;ZERO INTO LOW BYTES
323F   F0 14                BEQ NORM0			;* PBE Q* NORMALIZE IT AND RETURN
                  ;
                  ; DO A FAST FLOAT OF A 1-BYTE QUANTITY 
                  ;
3241   85 81      FLT8      STA M1			;STORE THE BYTE
3243   A9 86                LDA #$86			;ASSUME ALREADY SHIFTED 8 BLACES
3245   85 80                STA X1				
3247   A9 00                LDA #$00			;GET A ZERO
3249   85 82                STA M1+1			;ZERO OUT BYTE OF MANTISSA
324B   F0 06                BEQ FLOATC			;*P BEQ * CLEAR THIRD BYTE, NORMALIZE AND RETURN
                  ;
                  ; FLOAT A 16-BUT INTEGER IN M1 & M1+1 TO FAC1
                  ; FAC2 UNAFFECTED
                  ;
324D   A9 8E      FLT16     LDA #$8E
324F   85 80                STA X1			;SET EXP TO 14 DEC
3251   A9 00                LDA #$00			;CLEAR LOW BYTES
3253   85 83      FLOATC    STA M1+2
3255   85 84      NORM0     STA M1+3			;*
							;* PFALL * NORMALIZE IT AND RETURN
3257   20 1E 34   NORM      JSR CHKZER			;* IS MANTISSA ZERO?
325A   D0 0F                BNE NORML			;BRANCH IF NOT, THEN DO THE NORMALIZE SHIFTING
325C   A9 80                LDA #$80			;YES, THEN AVOID MUCH SHIFTING BY SETTING
325E   85 80                STA X1			;THE EXPONENT
3260   60                   RTS				;AND RETURN
3261   C6 80      NORM1     DEC X1
3263   06 84                ASL M1+3			;* SHIFT 4 BYTES LEFT
3265   26 83                ROL M1+2
3267   26 82                ROL M1+1
3269   26 81                ROL M1
326B   A5 81      NORML     LDA M1			;NORMALISED CHECK
326D   0A                   ASL A			;UPPER TWO BYTES UNEQUAL?
326E   45 81                EOR M1
3270   10 EF                BPL NORM1			;NO, LOOP TILL THEY ARE
3272   60                   RTS
3273   20 B8 32   RTSN      JSR FCOMPL
                  ;
                  ;FAC2-FAC1 INTO FAC1
                  ;
                  ;original JSR FCOMPL is missing!!!!!!!!
                  ;
3276   20 86 32   FSUB      JSR ALGNSW   		;Label could also be called SWPALG
                  ;
                  ;FAC1 + FAC2 INTO FAC1
                  ;
3279   A5 7B      FADD      LDA X2				
327B   C5 80                CMP X1  			;EXPONENTS EQUAL?
327D   D0 F7                BNE FSUB			;IF NOT SWAP OR ALIGN
327F   20 0D 32             JSR ADD			;ADD MANTISSAS
3282   50 D3      ADDEND    BVC NORM			;IF COOL, NORMALIZE
3284   70 05                BVS RTLOG			;DV: SHIFT RIGHT-CARRY IS COOL
				;SWAP IF CARRY CLEAR, ELSE SHIFT RIGHT ARITHMETICALLY
3286   90 A1      ALGNSW    BCC SWAP
3288   A5 81      RTAR      LDA M1			;SIGN INTO CARRY
328A   0A                   ASL A			;ARITH SHIFT
328B   E6 80      RTLOG     INC X1			;COMPENSATE FOR SHIFT
328D   F0 39                BEQ OVFL			;EXP OUT OF RANGE
328F   A2 F8      RTLOG1    LDX #$F8			;* INDEX FOR 8 BYTE RT SHIFT
3291   A9 80      ROR1      LDA #$80
3293   B0 01                BCS ROR2
3295   0A                   ASL A
3296   56 89      ROR2      LSR E+4,X			;*FAKE RORX E+4
3298   15 89                ORA E+4,X
329A   95 89                STA E+4,X
329C   E8                   INX				;NEXT BYTE
329D   D0 F2                BNE ROR1			;UNTIL DONE
329F   60                   RTS
                  ;
                  ;  FAC1 * FAC2 INTO FAC1
                  ;
32A0   20 1A 32   FMUL      JSR MD1			;ABS VAL OF M1,M2
32A3   65 80                ADC X1			;ADD EXPONENTS
32A5   20 FE 32             JSR MD2			;CHECK & PREP FOR NUL
32A8   18                   CLC
32A9   20 8F 32   MUL1      JSR RTLOG1			;SHIFT PROD AND MFYR(?) RIGHT
32AC   90 03                BCC MUL2			;SKIP PARTIAL PROD
32AE   20 0D 32             JSR ADD			;ADD IN MCAND
32B1   88         MUL2      DEY				;NEXT ITERATION
32B2   10 F5                BPL MUL1			;LOOP UNTIL DONE
32B4   46 7A      MDEND     LSR SIGN			;SIGN EVEN OR ODD?
32B6   90 9F      NORMX     BCC NORM			;IF EVEN NORMALIZE, ELSE COMPARE
32B8   38         FCOMPL    SEC				
32B9   A2 04                LDX #$04			;*4 BYTE SUBTRACT
32BB   A9 00      COMPL1    LDA #$00
32BD   F5 80                SBC X1,X
32BF   95 80                STA X1,X
32C1   CA                   DEX				;TO MORE SIG BYTE
32C2   D0 F7                BNE COMPL1			;UNTIL DONE
32C4   F0 BC                BEQ ADDEND			;FIX UP
                  ;						
32C6   10 46      OVCHK     BPL MD3			;IF POSITIVE EXPONENT NO CVF	
32C8   00         OVFL      BRK				;TRAP
32C9   F8                   .BYTE FOVFL			;FLOATING POINT OVERFLOW
                  ;
                  ; DIVIDE FAC2 BY FAC1 INTO FAC1
                  ;
32CA   20 1A 32   FDIV      JSR MD1			;ABS VALUE OF M1, M2
32CD   E5 80                SBC X1			;SUBTRACT EXPONENTS
32CF   20 FE 32             JSR MD2			;SAVE AS RES EXP
32D2   38         DIV1      SEC
32D3   A2 03                LDX #$03			;* FOR 4 BYTES
32D5   B5 7C      DIV2      LDA M2,X			
32D7   F5 85                SBC E,X			;SUBTRACT BYTE OF E FROM M2
32D9   48                   PHA	
32DA   CA                   DEX				;NEXT MORE SIG BYTE
32DB   10 F8                BPL DIV2			;UNTIL DONE
32DD   A2 FC                LDX #$FC			;* FOR 4 BYTE COND MOVE
32DF   68         DIV3      PLA				;DIFF WAS ON STACK
32E0   90 02                BCC DIV4			;IF M2<E DON'T RESTORE
32E2   95 80                STA X1,X			;*
32E4   E8         DIV4      INX				;NEXT LESS SIG BYTE
32E5   D0 F8                BNE DIV3			;UNTIL DONE
32E7   26 84                ROL M1+3			;*
32E9   26 83                ROL M1+2			
32EB   26 82                ROL M1+1			;ROLL QUOTIENT LEFT
32ED   26 81                ROL M1			;CARRY INTO LSB
32EF   06 7F                ASL M2+3			;*
32F1   26 7E                ROL M2+2
32F3   26 7D                ROL M2+1			;DIVIDEND LEFT
32F5   26 7C                ROL M2
32F7   B0 CF                BCS OVFL			;OVF IS DUE TO UNNORM DIVISOR
32F9   88                   DEY				;NEXT ITERATION
32FA   D0 D6                BNE DIV1			;UNTIL DONE (23 ITERATIONS)
32FC   F0 B6                BEQ MDEND			;NORM QUOTIENT AND FIX SIGN
32FE   86 84      MD2       STX M1+3			;*
3300   86 83                STX M1+2
3302   86 82                STX M1+1			;CLEAR M1
3304   86 81                STX M1				
3306   B0 BE                BCS OVCHK			;CHECK FOR OVFL
3308   30 04                BMI MD3			;IF NEG NO UNDERFLOW
330A   68                   PLA				;POP ONE RETURN
330B   68                   PLA
330C   90 A8                BCC NORMX			;CLEAR X1 AND RETURN
330E   49 80      MD3       EOR #$80			;COMPL. SIGN OF EXPONENT
3310   85 80                STA X1				
3312   A0 1F                LDY #$1F			;COUNT FOR 31 (/), 32 (*) ITERATIONS
3314   60                   RTS
                  ;
                  ; FAC1 TO 23 BIT SIGNED INTEGER IN M1 (HIGH), M1+1 (MIDDLE), M1+2 (LOW) 
                  ;
3315   20 88 32   FIX1      JSR RTAR			;SHIFT MANTISSA, INC EXPONENT
3318   A5 80      FIX       LDA X1			;CHECK EXP
331A   C9 96                CMP #FHALF			;IS EXP #22?
331C   D0 F7                BNE FIX1			;NO, SHIFT MORE
331E   60                   RTS				;DONE
                  ;
                  ;  		FLOATING POINT OUTPUT ROUTINE
                  ;
331F   A5 81      FPRNT     LDA M1			;SAVE THE SIGN OF THE NUMBER
3321   85 8A                STA SIGNP			;FOR LATER REFERENCE
3323   20 F7 33             JSR ABSF1			;DEAL ONLY WITH ABSOLUTE VALUE
3326   20 1E 34             JSR CHKZER			;IS NUMBER = 0?
3329   D0 05                BNE FPR0			;BRANCH IF NOT, THEN TRY TO DIVIDE DOWN
332B   85 8D                STA K			;YES, SOME FLAVOR OF ZERO. INDICATE THAT WE
332D   48                   PHA				;DID NOT HAVE TO DIVIDE AS ALREADY <1
332E   F0 43                BEQ FPR4A			;AND PUNT DIVIDE DOWN AND ROUNDING CODE
3330   A5 80      FPR0      LDA X1			;GET THE EXPONENT
3332   48                   PHA				;SAVE FOR LATER REFERENCE
3333   A9 00                LDA #$00			;ZERO COUNTER WHICH COUNTS HOW MANY TIMES
3335   85 8D                STA K			;WE HAD TO DIVIDE TO GET NUMBER <1
3337   24 80      FPR1      BIT X1			;IS NUMBER <1?
3339   10 07                BPL FPR2			;BRANCH IF YES
333B   20 11 34             JSR DIV10			;NO, THEN DIVIDE BY 10
333E   E6 8D                INC K			;COUNT THE FACT WE DID
3340   10 F5                BPL FPR1			;AND CHECK AGAIN
3342   20 79 28   FPR2      JSR PHFAC1			;SAVE NUMBER (NOW <1) ON STACK
3345   A2 96                LDX #FHALF			;GET THE CONSTANT .5
3347   A0 80                LDY X1			;INTO FAC1
3349   20 FF 33             JSR MOVXY
334C   18                   CLC
334D   A5 8D                LDA K			;ROUNDING FACTOR IS .5*10^-(K+N)
334F   65 90                ADC N
3351   85 8E                STA L
3353   F0 0F                BEQ FPR4			;BRANCH IF WE NEED .5*10^0
3355   A9 09                LDA #$09			;* IS FACTOR BEYOND OUR PRECISSION?
3357   C5 8E                CMP L
3359   10 02                BPL FPR3			;BRANCH IF NOT, THEN ROUNDING FACTOR IS OK
335B   85 8E                STA L			;YES, THEN APPLY ROUNDING TO LEAST SIG FIG
335D   20 11 34   FPR3      JSR DIV10			;NOW SHIFT .5 INTO PROPER POSITION
3360   C6 8E                DEC L
3362   D0 F9                BNE FPR3
3364   20 9A 28   FPR4      JSR PLFAC2			;GET NUMBER INTO FAC2
3367   20 79 32             JSR FADD			;ADD THE ROUNDING FACTOR
336A   24 80                BIT X1			;IS IT STILL <1?
336C   10 05                BPL FPR4A			;BRANCH IF IT IS
                  ;
                  ;original ProgExch/6502Grp code has more lines here:
			;	pla		;no then get original exponent
			;	bmi fpr4a	;branch if original number >1 do nothing
			;	lda x1		;we gained a sig fig in rounding, get new exp
			;fpr41	pha		;save exponent for later
                  ;
336E   20 11 34             JSR DIV10		;SCALE NUMBER BACK DOWN
3371   E6 8D                INC K		;AND INDICATE WE HAD TO
3373   38         FPR4A     SEC
3374   A5 8F                LDA M		;NOW CONSULATE NUMBER OF LEADING BLANKS NEEDED
3376   E5 8D                SBC K
3378   85 8E                STA L		;INTO L
337A   68                   PLA			;GET EXPONENT OF ORIGINAL NUMBER BACK
337B   48                   PHA			;SAVE AGAIN FOR LATER
337C   30 02                BMI FPR4B		;BRANCH IF ORIGINAL NUMBER IS <1?
337E   C6 8E                DEC L		;IT WAS <1. LEAVE ROOM FOR LEADINF 0
3380   24 8A      FPR4B     BIT SIGNP		;WAS NUMBER NEGATIVE
3382   10 02                BPL FPR5		;BRANCH IF NOT
3384   C6 8E                DEC L		;YES, THEN LEAVE ROOM FOR A MINUS SIGN
3386   A5 8E      FPR5      LDA L		;ANY BLANKS TO OUTPUT?
3388   30 09                BMI FPR7		;BRANCH IF NOT
338A   F0 07                BEQ FPR7		;BRANCH IF NOT
338C   20 00 29   FPR6      JSR PSPACE		;OUTPUT A BLANK
338F   C6 8E                DEC L		;COUNT IT
3391   D0 F9                BNE FPR6		;AND LOOP TILL ALL HAVE BENN OUTPUT
3393   24 8A      FPR7      BIT SIGNP		;WAS NUMBER NEGATIVE?
3395   10 05                BPL FPR7A		;BRANCH IF NOT
3397   A9 2D                LDA #$2D		;YES, OUTPUT A LEADING "-"
3399   20 02 29             JSR L2902		;AND FALL INTO NEXT PAGE
339C   68         FPR7A     PLA			;GET EXPONENT OF THE ORIGINAL NUM BACK AGAIN
339D   30 03                BMI FPR8		;BRANCH IF NOT <1
339F   20 C8 33             JSR PZERO		;YES, THEN GIVE A LEADING ZERO
						;(PEOPLE LIKE IT!)
						;(IT'S ALSO A PAIN TO CHECK FOR!)
                  ;								
                  ; NOW FOR THE MEAT OF IT
                  ;
33A2   A9 09      FPR8      LDA #$09			;* GET MAX NUMBER OF SIG FIGS
33A4   85 8E                STA L			;INTO L
33A6   A5 8D      FPR9      LDA K			;ANY OUTPUT BEFORE DECIMAL?
33A8   F0 07                BEQ FPR11			;BRANCH IF NO MORE
33AA   20 C4 33   FPR10     JSR MDO			;OUTPUT A DIGIT BEFORE DECIMAL
33AD   C6 8D                DEC K
33AF   D0 F9                BNE FPR10			;AND LOOK TILL ALL DONE
33B1   A5 90      FPR11     LDA N			;GET NUMBER AFTER DECIMAL POINT
33B3   85 8D                STA K			;INTO K
33B5   F0 0C                BEQ FPRET			;BRANCH IF NONE TO OUTPUT
33B7   A9 2E                LDA #$2E			;THERE ARE SOME TO OUTPUT,
33B9   20 02 29             JSR PRINTC			;PRINT THE DECIMAL POINT
33BC   20 C4 33   FPR12     JSR MDO			;OUTPUT A DIGIT AFTER DECIMAL
33BF   C6 8D                DEC K			;AND LOOP
33C1   D0 F9                BNE FPR12			;TILL ALL OUTPUT
33C3   60         FPRET     RTS				;RETURN FROM 'FPRNT' FAC1 IS DESTROYED!
                  ;
                  ; MPY BY 10, PRINT INTEGER AND SUBTRACT IT
                  ;
33C4   C6 8E      MDO       DEC L			;HAVE WE OUTPUT ALL DIGITS OF SIGNIFICANCE?
33C6   10 05                BPL MDO1			;BRANCH IF NOT, OUTPUT THIS ONE
33C8   A9 30      PZERO     LDA #$30			;YES, THEN OUTPUT A ZERO
33CA   4C 02 29             JMP PRINTC			;* PJMP * AND RETURN
33CD   A2 91      MDO1      LDX FTEN			
33CF   A0 7B                LDY X2
33D1   20 FF 33             JSR MOVXY
33D4   20 A0 32             JSR FMUL
33D7   A2 80      FDONE     LDX X1			;SAVE FAC1
33D9   A0 A0                LDY T
33DB   20 FF 33             JSR MOVXY
33DE   20 18 33             JSR FIX
33E1   A5 83                LDA M1+2			;MAKE ASCII
33E3   29 0F                AND #$0F
33E5   09 30                ORA #$30
33E7   20 02 29             JSR PRINTC
33EA   20 39 32             JSR FLOAT			;NOW SUBTRACT IT
33ED   A2 A0                LDX T			;RESTORE TO FAC2
33EF   A0 7B                LDY X2
33F1   20 FF 33             JSR MOVXY
33F4   4C 73 32             JMP RTSN           ; a different JMP here in the original!!!!
							;original JMP FSUB --na
                  ;
                  ;   UTILITIES FOR FPRNT
                  ;
33F7   24 81      ABSF1     BIT M1
33F9   10 03                BPL ABSFE
33FB   20 B8 32             JSR FCOMPL
33FE   60         ABSFE     RTS
33FF   CA         MOVXY     DEX
3400   8E 0A 34             STX MOV1+1
3403   88                   DEY
3404   8C 0C 34             STY MOV1+2
3407   A2 05                LDX #$05			;*
3409   B5 00      MOV1      LDA $00,X
340B   95 00      MOV2      STA $00,X
340D   CA                   DEX
340E   D0 F9                BNE MOV1
3410   60                   RTS
                  ;
3411   20 29 32   DIV10     JSR SWAP
3414   A2 91                LDX FTEN
3416   A0 80                LDY X1
3418   20 FF 33             JSR MOVXY
341B   4C CA 32             JMP FDIV			;*PJMP*
                  ;
341E   A5 81      CHKZER    LDA M1			;GET HIGH ORDER MANTISSA
3420   05 82                ORA M1+1			;'OR' ALL BYTES OF MANTISSA TOGETHER
3422   05 83                ORA M1+2
3424   05 84                ORA M1+3			;*
3426   60                   RTS				;RETURN WITH Z=1 IF MANTISSA IS =0.
                  ;
                  ;   'FLOATING POINT INPUT ROUTINE'
                  ;
3427   A9 00      FINP      LDA #$00
3429   85 8A                STA SIGNP			;SET SIGN +
342B   85 8B                STA DPFLG			;RESET DP FLAG
342D   85 8C                STA GOTFLG			;NO INPUT YET
342F   85 8D                STA K			;NO DIGITS AFTER DECIMAL POINT
3431   85 7B                STA X2			;ZERO RESULT
3433   85 7C                STA M2
3435   85 7D                STA M2+1
3437   85 7E                STA M2+2
3439   85 7F                STA M2+3			;*
343B   A5 2B                LDA CHAR			;GET CHARACTER
343D   C9 2B                CMP #$2B			;IGNORE +'S
343F   F0 06                BEQ FINP3			
3441   C9 2D                CMP #$2D			;'-' FLAG IF NEGATIVE
3443   D0 05                BNE FINP2
3445   E6 8A                INC SIGNP
3447   20 92 29   FINP3     JSR GETC			;ANOTHER CHAR
344A   C9 30      FINP2     CMP #$30			;'0' IS IT A DIGIT?
344C   90 24                BCC FINP4			;NO
344E   C9 3A                CMP #$3A			;':' MAYBE...
3450   B0 20                BCS FINP4			;NO
3452   A2 91                LDX FTEN
3454   A0 80                LDY X1
3456   20 FF 33             JSR MOVXY			;FAC2*10.0=FAC1
3459   20 A0 32             JSR FMUL
345C   20 29 32             JSR SWAP			;INTO FAC2
345F   E6 8C                INC GOTFLG			;YES, WE HAVE INPUT
3461   A5 2B                LDA CHAR
3463   29 0F                AND #$0F			;MAKE NUMERIC
3465   20 41 32             JSR FLT8			;AND FLOAT IT
3468   20 79 32             JSR FADD			;ADD TO PARTIAL RESULT
346B   20 29 32             JSR SWAP			;BACK INTO FAC2
346E   E6 8D                INC K			;COUNT DIGITS AFTER DECIMAL POINT
3470   D0 D5                BNE FINP3			;GET MORE
3472   C9 2E      FINP4     CMP #$2E			;DECIMAL POINT?
3474   D0 0C                BNE FINP5			;NO, END OF #
3476   A5 8B                LDA DPFLG			;YES, ALREADY GOT ONE?
3478   D0 08                BNE FINP5			;THEN END OF #
347A   E6 8B                INC DPFLG			;ELSE FLAG GOT ONE
347C   A9 00                LDA #$00
347E   85 8D                STA K			;RESET K
3480   F0 C5                BEQ FINP3			;AND GET FRACTION
                  ;
                  ; HERE ON END OF NUMBER
                  ;
3482   20 29 32   FINP5     JSR SWAP			;RESULT TO FAC1
3485   A5 8B                LDA DPFLG			;ANY DECIMAL POINTS?
3487   F0 0B                BEQ FINP6			;NO, ITS OK
3489   A5 8D      FINP7     LDA K			;ELSE ADJUST
348B   F0 07                BEQ FINP6			;ADJUST DONE
348D   20 11 34             JSR DIV10			;RESULT/10
3490   C6 8D                DEC K			;K TIMES
3492   D0 F5                BNE FINP7
3494   A5 8A      FINP6     LDA SIGNP			;NOW ADD SIGN
3496   F0 03                BEQ FINP8			;WAS POS
3498   20 B8 32             JSR FCOMPL			;WAS NEG
349B   4C 57 32   FINP8     JMP NORM			;PJUMP TO NORMALIZE
                  ;
                  ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                  ;
                  ; 	Here begins (again) code restoration by dhh
                  ;
                  ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                  ;
                  ; from here, the Aresco version of V3D code (TTY) completely differs from
                  ; the ProgramExchange/6502 Group TIM-monitor code upon which it is based.
                  ; PE code occupies $24A6 to $24D0 (here $349E to $34E7), and seems to be
                  ; related to video terminal output.  What follows here are KIM-1-specific
                  ; initialization and I/O routines.  -dhh 
                  ;
349E   A9 E0                LDA #$E0	; init BRK vector as $2CE0
34A0   8D FE 17             STA $17FE
34A3   A9 2C                LDA #$2C
34A5   8D FF 17             STA $17FF
34A8   18                   CLC
34A9   60                   RTS
34AA   20 A0 1E             JSR $1EA0	; OUTCH in KIM-1 ROM
34AD   18                   CLC
34AE   60                   RTS
34AF   E6 76      L34AF     INC $76	; label HASH
34B1   2C 40 17             BIT $1740	; (R)RIOT I/O register A
34B4   30 F9                BMI L34AF
34B6   AD 42 17             LDA $1742	; (R)RIOT I/O register B
34B9   29 FE                AND #$FE
34BB   8D 42 17             STA $1742
34BE   20 5A 1E             JSR $1E5A	; GETCH in KIM-1 ROM
34C1   48                   PHA
34C2   AD 42 17             LDA $1742	; the echo defeat
34C5   29 FE                AND #$FE
34C7   09 01                ORA #$01
34C9   8D 42 17             STA $1742
34CC   68                   PLA
34CD   18                   CLC
34CE   60                   RTS		; 
                  ;
                  ;  The next bytes do not appear to be used for anything.
                  ;  Perhaps leftover from Aresco conversion of Prog/Exch
                  ;  version for KIM-1 (???).
                  ;
34CF   00                   BRK
34D0   43                   ???                ;01000011 'C'
34D1   11 51                ORA ($51),Y
34D3   11 11                ORA ($11),Y
34D5   17                   ???                ;00010111
34D6   01 01                ORA ($01,X)
34D8   11 41                ORA ($41),Y
34DA   53                   ???                ;01010011 'S'
34DB   01 51                ORA ($51,X)
34DD   51 11                EOR ($11),Y
34DF   53                   ???                ;01010011 'S'
34E0   EE CE FE             INC $FECE
34E3   EE EA EE             INC $EEEA
34E6   06 FE                ASL $FE
                  ;
                  ;	SPECIAL TERMINATOR CHAR TABLE (see P/E code at $2401)
                  ;
34E8   20       	    .BYTE $20	; LEVEL 0 (SPACE)
34E9   2B         	    .BYTE $2B	; LEVEL 1 '+'
34EA   2D         	    .BYTE $2D	; LEVEL 2 '-'
34EB   2F         	    .BYTE $2F	; LEVEL 3 '/'
34EC   2A         	    .BYTE $2A	; LEVEL 4 '*'
34ED   5E         	    .BYTE $5E	; LEVEL 5 '^'
34EE   28         	    .BYTE $28	; LEVEL 6 '('
34EF   29         	    .BYTE $29	; LEVEL 7 ')'  (START OF DELIMITERS)
34F0   2C         	    .BYTE $2C	; LEVEL 8 ','
34F1   3B         	    .BYTE $3B	; LEVEL 9 ';'
34F2   0D         	    .BYTE $0D	; LEVEL 10 'CR'
34F3   3D         	    .BYTE $3D	; LEVEL 11 '=' (TERMINATOR FOR 'SET')
34F4   5F         	    .BYTE $5F	; LEVEL 1 '_'  ('LINE-DELETE IS HERE SO
                  			;		'ASK' CAN ALLOW RE-TYPEIN)
                  ;
                  ; here TRMAX=12 is defined in the ProgExch code
                  ;
                  ; 	THESE FUNCTION DISPATCH TABLES MAY BE PATCHED BY A USER
                  ; 	TO CALL HIS OWN FUNCTIONS.
                  ;
                  ;	TABLE OF 'HASH CODES' FOR FUNCTION NAMES
                  ;
34F5   36       FUNTAB  .BYTE $36	; ABSOLUTE VALUE FUNCTION
34F6   F4            	.BYTE $36	; CHARACTER OUTPUT FUNCTION
34F7   B0            	.BYTE $36	; RANDOM NUMBER FUNCTION
34F8   A8            	.BYTE $36	; INTEGERIZE FUNCTION
34F9   A4            	.BYTE $36	; INTEGERIZE WITH ROUNDING FUNCTION
34FA   84            	.BYTE $36	; INPUT DEVICE FUNCTION
34FB   B4            	.BYTE $36	; OUTPUT DEVICE FUNCTION
34FC   5C            	.BYTE $36	; CHARACTER INPUT FUNCTION
34FD   90            	.BYTE $36	; CONSOLE CURSOR ADDRESSING FUNCTION
34FE   44            	.BYTE $36	; ECHO CONTROL FUNCTION
34FF   AA            	.BYTE $36	; SOFTWARE PRIORITY INTERRUPT FUNCTION
3500   96            	.BYTE $36	; MEMORY EXAMINE-DEPOSIT FUNCTION
3501   92            	.BYTE $36	; INITIALIZE INPUT DEVICE FUNCTION
3502   9E            	.BYTE $36	; INITIALIZE OUTPUT DEVICE FUNCTION
3503   5A            	.BYTE $36	; CLOSE INPUT DEVICE FUNCTION
3504   66            	.BYTE $36	; CLOSE OUTPUT DEVICE FUNCTION
3505   70            	.BYTE $36	; SET CONSOLE DEVICE FUNCTION
3506   C4            	.BYTE $36	; 'SUBROUTINE' CALL FUNCTION
3507   AC            	.BYTE $36	; INITIALIZE STRING LENGTH FUNCTION
3508   FA            	.BYTE $36	; STRING INPUT FUNCTION
3509   06            	.BYTE $36	; STRING OUTPUT FUNCTION
350A   DE            	.BYTE $36	; STRING "LOOK" FUNCTION
350B   00                   BRK		; SPARE LOCS FOR HACKERS
350C   00                   BRK
350D   00                   BRK
350E   00                   BRK
350F   00                   BRK
3510   00                   BRK		; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
                  ;
                  ;	FUNCTION DISPATCH TABLES - HIGH BYTE
                  ;
3511   2E         FUNADH	.BYTE $2E	; FABS
3512   2F               	.BYTE $2F	; FOUT
3513   31               	.BYTE $31	; FRAN
3514   2E               	.BYTE $2E	; FINT
3515   2E               	.BYTE $2E	; FINR
3516   2F               	.BYTE $2F	; FIND
3517   2F               	.BYTE $2F	; FODV
3518   2F               	.BYTE $2F	; FCHR
3519   2E               	.BYTE $2E	; FCUR
351A   2F               	.BYTE $2F	; FECH
351B   2F               	.BYTE $2F	; FPIC
351C   2E               	.BYTE $2E	; FMEM
351D   2E               	.BYTE $2E	; FINI
351E   2E               	.BYTE $2E	; FINO
351F   2E               	.BYTE $2E	; FCLI
3520   2E               	.BYTE $2E	; FCLO
3521   2E               	.BYTE $2E	; FCON
3522   31               	.BYTE $31	; FSBR
3523   2F               	.BYTE $2F	; FISL
3524   30               	.BYTE $30	; FSTI
3525   30               	.BYTE $30	; FSTO
3526   30               	.BYTE $30	; FSLK
3527   00               	.BYTE $00	; SPACE FOR HACKERS
3528   00         L3528     BRK
3529   00                   BRK
352A   00                   BRK
352B   00                   BRK
352C   00                   BRK		; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
                  ;
                  ;	FUNCTION DISPATCH TABLES - LOW ORDER ADDR BYTE
                  ;
352D   08         FUNADL	.BYTE $08	; FABS
352E   11               	.BYTE $11	; FOUT
352F   BE               	.BYTE $BE	; FRAN
3530   0E          		.BYTE $0E	; FINT
3531   17          		.BYTE $17	; FINR
3532   3A          		.BYTE $3A	; FIDV
3533   4B          		.BYTE $4B	; FODV
3534   1A          		.BYTE $1A	; FCHR
3535   82          		.BYTE $82	; FCUR
3536   32          		.BYTE $32	; FECH
3537   B2          		.BYTE $B2	; FPIC
3538   CE          		.BYTE $CE	; FMEM
3539   2C          		.BYTE $2C	; FINI
353A   3A          		.BYTE $3A	; FINO
353B   48          		.BYTE $48	; FCLI
353C   56          		.BYTE $56	; FCLO
353D   64          		.BYTE $64	; FCON
353E   62          		.BYTE $62	; FSBR
353F   F7          		.BYTE $F7	; FISL
3540   2B          		.BYTE $2B	; FSTI
3541   75          		.BYTE $75	; FSTO
3542   D8          		.BYTE $D8	; FSLK
3543   00         L3543     BRK			; SPACE FOR HACKERS
3544   00                   BRK
3545   00                   BRK
3546   00                   BRK
3547   00                   BRK
3548   00                   BRK			; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
                  ;
                  ;	COMMAND DISPATCH TABLES
                  ;
                  ;	THESE COMMAND DISPATCH TABLES MAY BE PATCHED BY USER
                  ;	TO ADD HIS OWN SPECIAL COMMAND HANDLERS
                  ;
                  ;	COMMAND CHARACTER TABLE
                  ;

3549   53         COMTAB	.BYTE $53	; 'S' SAVE COMMAND
354A   49            		.BYTE $49	; 'I' IF COMMAND
354B   44            		.BYTE $44	; 'D' DO COMMAND
354C   4F            		.BYTE $4F	; 'O' ON COMMAND
354D   47            		.BYTE $47	; 'G' GOTO COMMAND
354E   46            		.BYTE $46	; 'F' FOR COMMAND
354F   52            		.BYTE $52	; 'R' RETURN COMMAND
3550   54            		.BYTE $49	; 'T' TYPE COMMAND
3551   41            		.BYTE $41	; 'A' ASK COMMAND
3552   43            		.BYTE $43	; 'C' COMMENT COMMAND
3553   45            		.BYTE $45	; 'E' ERASE COMMAND
3554   57            		.BYTE $57	; 'W' WRITE COMMAND
3555   4D            		.BYTE $4D	; 'M' MODIFY COMMAND
3556   51            		.BYTE $51	; 'Q' QUIT COMMAND
3557   00                   BRK			; SPACE FOR HACKERS
3558   00                   BRK
3559   00                   BRK
355A   00                   BRK
355B   00                   BRK
355C   00                   BRK		; MUST HAVE ONE ZERO TO END TABLE!
                  ;
                  ;	HIGH ORDER ADDR OF COMMAND HANDLING ROUTINE
                  ;
355D   25         COMADH	.BYTE $25	; SET
355E   20               	.BYTE $20	; IF
355F   21               	.BYTE $21	; DO
3560   20               	.BYTE $20	; ON
3561   22               	.BYTE $22	; GOTO
3562   24               	.BYTE $24	; FOR
3563   22               	.BYTE $22	; RETURN
3564   24               	.BYTE $24	; TYPE
3565   24               	.BYTE $24	; ASK
3566   23               	.BYTE $23	; COMMENT
3567   22               	.BYTE $22	; ERASE
3568   22               	.BYTE $22	; WRITE
3569   21               	.BYTE $21	; MODIFY
356A   20               	.BYTE $20	; QUIT
356B   00                   BRK			; SPACE FOR HACKERS
356C   00                   BRK
356D   00                   BRK
356E   00                   BRK		; MUST HAVE ZERO TO END TABLE!
                  ;
                  ;	LOW ORDER ADDR OF COMMAND HANDLING ROUTINE
                  ;
356F   22         COMADL	.BYTE $22	; SET
3570   C7               	.BYTE $C7	; IF
3571   9A               	.BYTE $9A	; DO
3572   C7               	.BYTE $C7	; ON
3573   F2               	.BYTE $F2	; GOTO
3574   F4               	.BYTE $F4	; FOR
3575   0E               	.BYTE $0E	; RETURN
3576   82               	.BYTE $82	; TYPE
3577   82               	.BYTE $82	; ASK
3578   63               	.BYTE $63	; COMMENT
3579   2E               	.BYTE $2E	; ERASE
357A   7D               	.BYTE $7D	; WRITE
357B   33               	.BYTE $33	; MODIFY
357C   31               	.BYTE $31	; QUIT
357D   00                   BRK			; SPACE FOR HACKERS
357E   00                   BRK
357F   00                   BRK
3580   00                   BRK		; MUST HAVE A ZERO TO END TABLE!
                  ;
                  ;	DISPATCH TABLE FOR 'EVBOP' ROUTINE
                  ;


                  ; two definitions here in the Prog/Exch code:
                  ; at $2569 (3580 here) .DEF EVDSPH=.-1  and
                  ; $256E (3585) .DEF EVDSPL=.-1
                  ;
3581   32               	.BYTE $32	; FADD
3582   32               	.BYTE $32	; FSUB
3583   32               	.BYTE $32	; FDIV
3584   32               	.BYTE $32	; FMUL
3585   2A               	.BYTE $2A	; EVPOWR
                  ;
3581   79               	.BYTE $79	; FADD
3582   73               	.BYTE $73	; FSUB
3583   CA               	.BYTE $CA	; FDIV
3584   A0               	.BYTE $A0	; FMUL
3585   F7               	.BYTE $F7	; EVPOWR
                  ;
                  ;		TABLES USED BY SOFTWARE INTERRUPT SYSTEM
                  ;
                  ; TABLE OF GROUP NUMBERS OF LINES TO 'DO' WHEN EVENT HAPPENS
                  ; ONE ENTRY FOR EACH OF THE 8 PRIORITY CHANNELS
                  ;
358B   00          INTGRP   BRK
358C   00                   BRK
358D   00                   BRK
358E   00                   BRK
358F   00                   BRK
3590   00                   BRK
3591   00                   BRK
3592   00                   BRK
3593   00                   BRK
                  ;
                  ; TABLE OF STEP NUMBERS OF LINES TO 'DO' WHEN AN EVENT HAPPENS
                  ;
3594   00          INTLIN   BRK
3595   00                   BRK
3596   00                   BRK
3597   00                   BRK
3598   00                   BRK
3599   00                   BRK
359A   00                   BRK
359B   00                   BRK
359C   00                   BRK
                  ;
                  ; 'AND' MASKS USED TO DISABLE ALL BUT HIGHER PRIO CHANNELS.
                  ; INDEXED BY CURRENT CHANNEL NUMBER
                  ;
359D   FF         INTTAB    .BYTE $FF	; CHANNEL 0 ENABLES THEM ALL
359E   FE                   .BYTE $FE
359F   FC                   .BYTE $FC
35A0   F8                   .BYTE $F8
35A1   F0                   .BYTE $F0
35A2   E0                   .BYTE $E0
35A3   C0                   .BYTE $C0
35A4   80                   .BYTE $80
35A5   00                   .BYTE $00	; CHANNEL 8 ENABLES NONE
                  ;
                  ; BIT TABLE CONTAINING A SINGLE BIT FOR EACH CHANNEL POSITION
                  ;
35A6   00         BITTAB    BRK
35A7   01                   .BYTE $01
35A8   02                   .BYTE $02
35A9   04                   .BYTE $04
35AA   08                   .BYTE $08
35AB   10                   .BYTE $10
35AC   20                   .BYTE $20
35AD   40                   .BYTE $40
35AE   80                   .BYTE $80
                  ;
                  ;	DISPATCH TABLE FOR I/O DEVICE NUMBERS
                  ;
                  ; handwritten note in P/E source: "READ/WRITE"
                  ; Two definitions made here:
                  ;	.DEF IDEWVM=3     .DEF ODEVM=3  ; MAX # OF I/O DEVICES
                  ;
35AF   34         IDSPH    .BYTE $34	; DEVICE 0 - KEYBOARD INPUT ROUTINE
35B0   00                   BRK		; DEVICE 1 - CASSETTE #0 INPUT ROUTINE
35B1   00                   BRK		; DEVICE 2 - CASSETTE #1 INPUT ROUTINE
35B2   00                   BRK		; SPACE FOR HACKERS
35B3   00                   BRK
35B4   AF         IDSPL     .BYTE $AF
35B5   00                   BRK
35B6   00                   BRK
35B7   00                   BRK
35B8   00                   BRK
35B9   34         ODSPH     .BYTE $34	; DEVICE 0 - TV OUTPUT ROUTINE
35BA   00                   BRK		; DEVICE 1 - CASSETTE #0 OUTPUT ROUTINE
35BB   00                   BRK		; DEVICE 2 - CASSETTE #1 OUTPUT ROUTINE
35BC   00                   BRK		; SPACE FOR HACKERS
35BD   00                   BRK
35BE   AA         ODSPL     .BYTE $AA
35BF   00                   BRK
35C0   00                   BRK
35C1   00                   BRK
35C2   00                   BRK
                  ;
                  ; handwritten note in P/E source: "INITIALIZE IN/OUT"
                  ;
35C3   29         INIAH 	.BYTE $29	; DON'T NEED TO INTIALIZE KEYBOARD
35C4   29          		.BYTE $29	; USER MUST PROVIDE ROUTINE
35C5   29          		.BYTE $29	;
35C6   00          		.BYTE $00	; SPACE FOR HACKERS
35C7   00          		.BYTE $00
                  ;
35C8   40         INIAL 	.BYTE $40
35C9   40                	.BYTE $40
35CA   40                	.BYTE $40
35CB   00                   	BRK
35CC   00                   	BRK
                  ;
35CD   34         INOAH 	.BYTE $34	; USE TO STUFF VECTORS WITH BREAK HANDLERS
35CE   29               	.BYTE $29	; USER PROVIDES ROUTINES
35CF   29               	.BYTE $29
35D0   00                   	BRK
35D1   00                   	BRK
                  ;
35D2   9E          INOAL    	.BYTE $9E
35D3   40                	.BYTE $40
35D4   40                	.BYTE $40
35D5   00                   	BRK
35D6   00                   	BRK
                  ;
                  ; handwritten note in P/E source: "CLOSE IN/OUT"
                  ;
35D7   29         CLIAH 	.BYTE $29	; KEYBOARD DOESN'T NEED A CLOSE ROUTINE
35D8   29          		.BYTE $29	; USER PROVIDES ROUTINE
35D9   29          		.BYTE $29	;
35DA   00          		.BYTE $00	; SPACE FOR HACKERS
35DB   00          		.BYTE $00	; SPACE FOR HACKERS
                  ;
35DC   40         CLIAL 	.BYTE $40
35DD   40                	.BYTE $40
35DE   40                	.BYTE $40
35DF   00                   	BRK
35E0   00                   	BRK
                  ;
35E1   29         CLOAH 	.BYTE $29	; TV DOESN'T NEED A CLOSE ROUTINE
35E2   29          		.BYTE $29	; USER PROVIDES ROUTINE
35E3   29          		.BYTE $29	;
35E4   00          		.BYTE $00	; SPACE FOR HACKERS
35E5   00          		.BYTE $00
                  ;
35E6   40         INOAL 	.BYTE $40
35E7   40                	.BYTE $40
35E8   40                	.BYTE $40
35E9   00                   	BRK
35EA   00                   	BRK
                  ;
                  ; 	FOCEND - TEXT AREAS AND THE LIKE
                  ;
35EB   00                   BRK			; LINE NUMBER OF 00.00
35EC   00                   BRK	
35ED			    .ASCII  " C FOCAL-65 (V3D) 26-AUG-77"
3608   0D                   .BYTE $0D		; 'CR'


3609   FE         PBEG		.BYTE $FE	; START OF PROGRAM TEXT AREA
360A   FF         VEND		.BYTE $FF	; END OF VARIABLE LIST

          			.END	
