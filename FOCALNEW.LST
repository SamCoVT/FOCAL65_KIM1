00001  
00002  ; First disassembly by Paul R. Santa-Maria (2004)
00003  ; Initial comments added by Hans Otten, 2022
00004  ;
00005  ; New listing and comments from Wayne Wall's FOCAL-65 v3 (6502-TIM monitor ROM)
00006  ; and v4 (Apple II-specific) painstakingly typed in by Dave Hassler and
00007  ; Nils Andreas, 2023. (WAYNE'S COMMENTS, my/Nils's comments - dhh)
00008  ; v3d TIM source provided by Paul Birkle, v4 by Wayne Wall, both in 2023.
00009  ; Proofreading and corrections by SamCoVT, MIKE B., GAVIN D., AZin67
00010  ;
00011  
00012  ; Zero page block - *must* be loaded before main program executes
00013  
00014  ; SamCoVT - notes from focal 6502 user notes (describing a zero page
00015  ; initialization routine) indicate that only $00-$BF needs to be loaded.
00016  ; This zero page data has been patched to make FOCAL65 take 8K (assumes
00017  ; a 16K KIM-1).  This leaves room on the end for other patches, including
00018  ; the aforementioned zero page initialization routine.
00019  
00020  ;        .ORG $0000
00021  ;
00022  ;        .BYTE $53, $53, $4C, $E0, $2C, $4C, $DF, $2C, $00, $00, $00, $00, $00, $00, $00, $00        
00023  ;        .BYTE $00, $62, $7B, $66, $EB, $6B, $3A, $7B, $6A, $6B, $6B, $7B, $FB, $7B, $6B, $6B
00024  ;        .BYTE $00, $00, $00, $00, $00, $00, $FF, $00, $00, $01, $00, $00, $00, $00, $00, $E0
00025  ;        .BYTE $3F, $FE, $3F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $FF, $3F
00026  ;        .BYTE $FF, $3F, $FF, $3F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00027  ;        .BYTE $00, $00, $00, $00, $5F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $4C, $00
00028  ;        .BYTE $00, $6C, $00, $00, $48, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $C0
00029  ;        .BYTE $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00030  ;        .BYTE $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05
00031  ;        .BYTE $05, $83, $50, $00, $00, $00, $7F, $40, $00, $00, $00, $80, $40, $00, $00, $00
00032  ;        .BYTE $00, $00, $00, $00, $00, $FF, $1C, $3C, $7C, $5F, $7F, $7C, $3E, $7F, $3E, $FF
00033  ;        .BYTE $94, $DD, $84, $D4, $85, $D4, $95, $04, $DD, $94, $95, $DF, $8C, $15, $1D, $94
00034  ;        .BYTE $00, $D3, $E0, $C1, $80, $90, $D3, $C0, $C2, $A3, $00, $C0, $81, $82, $C3, $80
00035  ;        .BYTE $62, $6A, $FB, $6B, $6A, $6A, $02, $FF, $5A, $4B, $E3, $10, $EB, $62, $62, $4B
00036  ;        .BYTE $7F, $6C, $7F, $7D, $3F, $7F, $2E, $7F, $7F, $7E, $7F, $36, $5F, $7E, $3E, $7F
00037  ;        .BYTE $94, $00, $FF, $FF, $84, $A7, $19, $83, $00, $00, $DF, $10, $A9, $FF, $C7, $01
00038  
00039  ; ZERO PAGE USE:
00040  
00041  ; 00	= unused
00042  ; 02	= JMP INTSRV	- on IRQ
00043  ; 05	= JMP NMISRV	- on NMI
00044  ;    -- I have *no* idea what's going on with $10-$1F... dhh)
00045  
00046    0020              DEBGSW	= $20		; TRACE FLAG
00047    0021              DMPSW	= $21		; 'DUMP SWITCH'
00048    0022              ATSW	= $22		; ASK-TYPE CMDS FLAG
00049    0023              IFONSW	= $23		; IF-ON CMDS FLAG
00050    0024              INSW	= $24		; INPUT INDICATOR
00051    0025              MSCHAR	= $25		; 'MODIFY' SEARCH CHAR
00052  
00053  		; *** FOLLOWING MUST BE CONTIGUOUS ***
00054    0026              PC	= $26		; PROG COUNTER
00055    0028              TXTADR	= $28		; CHAR ADDR
00056    002A              TEXTP	= $2A		; TEXT POINTER
00057    002B              CHAR	= $2B		; CURRENT CHARACTER
00058    002C              GRPNO	= $2C		; GROUP NUMBER
00059    002D              LINENO	= $2D		; LINE (STEP) NUMBER
00060    002E              PRILVL	= $2E		; CURRENT S/W INTERUPT PRIORITY
00061  		; *** END OF MUST BE CONTIGUOUS ***
00062  
00063    002F              TXTBEG	= $2F		; POINTER TO BEGINNING OF STORED PROGRAM
00064    0031              PBADR	= $31		; ADDR OF START OF USER PROGRAM
00065    0033              TXTAD2	= $33
00066    0035              TEXTP2	= $35		; COUNTERPART TO 'CHAR,' ABOVE
00067  
00068  		; POINTERS TO VARIABLE LIST - *** MUST BE CONTIGUOUS ***
00069  
00070    0037              VARADR	= $37		; POINTER TO CURRENT VAR IN LIST
00071    0039              VSUB	= $39		; LOCATION TO HOLD SUBSCRIPT DURING VAR SEARCH
00072    003B              STRSWT 	= $3B		; FLAG IF CURR VAR IS $ (also label FSWIT)
00073    003B              FSWIT   = $3B
00074    003C              VSIZE	= $3C		; SIZE OF CURR STRING VAR (GETVAR)
00075    003D              VCHAR	= $3D		; PLACE TO HOLD VAR NAME DURING SEARCH (also TCHAR)
00076    003E              VARBEG	= $3E		; POINTER BEGINNING VAR LIST
00077    0040              VARST	= $40		; POINTS TO END OF VARS ON 'E ALL' COMMAND
00078    0042              VAREND	= $42		; POINTS TO END OF VAR LIST
00079  
00080  		; POINTERS FOR STRING I/O
00081  
00082    0044              STIADR	= $44		; HOLDS ADDR POINTER TO INPUT STRING
00083    0046              STIPNT	= $46		; OFFSET POINTER
00084    0047              STIMAX	= $47		; HOLDS SIZE OF INPUT STRING
00085    0048              STOADR	= $48		; HOLDS ADDR POINTER TO OUTPUT STRING
00086    004A              STOPNT	= $4A		; OFFSET POINTER
00087    004B              STOMAX	= $4B		; HOLDS SIZE OF OUTPUT STRING
00088  
00089  		; SOFTWARE PUSHDOWN LIST
00090  
00091    004C              PDPADR	= $4C		; ADDR TO LIST (software stack)
00092    004E              PDP	= $4E		; OFFSET POINTER TO LIST
00093    004F              PDPTMP	= $4F		; TEMP LOC. FOR 'ROOMCK'
00094    0051              TGRP	= $51		; HOLDS TEMPORARY GROUP NUMBER FOR SOME
00095    0052              TLINE	= $52		;   OPERATIONS. TEMP LINE # HERE
00096  
00097    0053              PDLIST	= $53		; STARTING ADDR OF SOFTWARE PDL
00098  			; ** effectively, the last page of FOCAL's user RAM.
00099  			;    Change to what suits your system. - dhh
00100    0055              STRAD1  = $55           ; DEFINE POINTERS TO STRING 1 IN 'FSLK'
00101    0055              STRCNT  = $55           ; TEMP COUNTER FOR SOME STRING OPERATIONS
00102    0055              ITMP1L	= $55		; TEMP1 LOW BYTE
00103    0056              ITMP1H	= $56		; TEMP1 HIGH BYTE (this is also STRCNT)
00104    0057              SBEG1	= $57		; START POS. OF STRING 1
00105    0058              SEND1	= $58		; END POS. STRING 1
00106  
00107    0059              STRAD2  = $59           ; DEFINE POINTERS TO STRING 2 IN 'FSLK'
00108    0059              STRMAX  = $59           ; TEMP FOR SOME STRING OPERATIONS
00109    0059              ITMP2L	= $59		; TEMP2 LOW BYTE
00110    005A              ITMP2H	= $5A		; TEMP2 HIGH BYTE (this is also STRMAX)
00111    005B              SBEG2	= $5B		; START POS. OF STRING 2
00112    005C              SEND2	= $5C		; END POS. STRING 2
00113    005D              STBSAV	= $5D		; PLACE TO SAVE BEGINNING SUBSCRIPT
00114    005E              JSRIND	= $5E		; JSR OPCODE ($4C) FOR 'JSRIND' - *MUST* BE PLACED
00115  			;   JUST BEFORE 'TEMP1'.
00116    005F              TEMP1	= $5F		;   *** VERY TEMPORARY STORAGE! NOT NECESSARILY
00117  			;   PRESERVED ACROSS SUBROUTINE CALLS!
00118    0061              JMPIND	= $61		; OPCODE FOR 'JMP INDIRECT' ($6C)
00119    0062              PJMPL	= $62		; LOW ORDER ADDR FOR 'JMPIND'
00120    0063              PJMPH	= $63		; HIGH ORDER BYTE
00121  
00122    0064              STRSIZ	= $64		; HOLDS DEFAULT STRING SIZE ($48)
00123    0065              ETEMP1	= $65		; TEMP USED BY 'EVAL'
00124    0066              IDEV	= $66		; SPECIFIES INPUT DEVICE
00125    0067              ODEV	= $67		; SPECIFIES OUTPUT DEVICE
00126    0068              IDVSAV	= $68		; SAVE INP DEV #
00127    0069              ODVSAV	= $69		; SAVE OUTPUT DEV #
00128    006A              CONDEV	= $6A		; SPECIFIES DEVICE # OF CONSOLE
00129    006B              ECHFLG	= $6B		; ECHO FLAG
00130    006C              DELSPL	= $6C		; SPECIAL DELETE FOR CRT
00131    006D              ACTMSK	= $6D		; MASK TO INDICATE WHICH S/W INTERRUPT CH ARE ACTIVE
00132    006E              EVMASK	= $6E		; HOLDS EVENT BITS SET BY EXTERNAL ROUTINES
00133  			;   WHEN THEY WANT FOCAL'S ATTENTION
00134    006F              BITV1	= $6F		; USED TO SET V=1, N=1 (#$C0)
00135    0070              MSKBRK	= $70		; BIT TEST MASK FOR BREAK (#$10)
00136    0071              ACSAV	= $71		; PLACE WHERE ACC IS SAVED ON INTERRUPT
00137    0072              STATUS	= $72		; PLACE WHERE PROC STATUS IS SAVED ON INTERRUPT
00138    0073              ITEMP1	= $73		; PLACE WHERE RET ADDR IS KEPT ON INTERRUPT
00139  
00140    0075              LASTOP	= $75		; USED BY 'EVAL'
00141    0076              HASH	= $76		; LOADED WITH A RANDOM HASH VALUE
00142  			;   *** NOTE: SOME ROUTINE IN YOUR SPECIFIC
00143  			;             COMPUTER SYSTEM SHOULD LOAD THIS
00144  			;	      LOC. WITH A PSEUDO-RANDOM 8-BIT VALUE.
00145    0077              SEED	= $77		; 3 BYTES. HOLDS A 23-BIT RANDOM # SEED - SEE 'FRAN'
00146  
00147  		; FLOATING POINT ROUTINES Z PG USE
00148  
00149    007A              SIGN	= $7A		; (also X2M1)
00150  
00151    007B              X2	= $7B		; FAC2 EXPONENT (also the *beginning of 'FAC2'*)
00152    007C              M2	= $7C		; FAC2 MANTISSA (3 bytes)
00153    007F              X1M1	= $7F
00154  
00155    0080              X1	= $80		; FAC1 EXPONENT (also the *beginning of 'FAC1'*)
00156    0080              FAC1    = $80
00157    0081              M1	= $81		; FAC1 MANTISSA (3 bytes, also 'FLCSGN')
00158    0081              FLCSGN  = $81
00159    0084              EM1	= $84
00160    0085              E	= $85		; SCRATCH AREA
00161    0089              EP4	= $89		; add'l scratch RAM alluded to elsewhere
00162  
00163  		; FLOATING POINT I/O ROUTINES
00164  
00165    008A              SIGNP	= $8A		; TEMPORARY SIGN
00166    008B              DPFLG	= $8B		; SAW DECIMAL POINT
00167    008C              GOTFLG	= $8C		; IF NON ZERO, WE ACTUALLY INPUT A NUMBER
00168    008D              K	= $8D		; MISC COUNTER
00169    008E              L	= $8E		; TEMP
00170    008F              M	= $8F		; # OF PLACES BEFORE DECIMAL POINT
00171    0090              N	= $90		; # OF PLACES AFTER DECIMAL POINT
00172  
00173    0091              FTEN	= $91		; CONSTANT 10.00
00174    0096              FHALF	= $96		; CONSTANT 2.50
00175    009B              FONE	= $9B		; CONSTANT 1.00
00176    00A0              T	= $A0		; TEMP (5 bytes)
00177  
00178  		; FLAG END OF OUR PAGE ZERO USAGE
00179  		; FOR ANYONE WHO NEEDS TO KNOW
00180  
00181  ;	$A5 = SAVYR  save for Y register (was $7F in v3 - RUBOUT)
00182  ;	also, end of zero page usage
00183  ;	TIM I/O package not in the Aresco version of v3d.
00184  
00185  		;		FOCAL SYMBOL DEFINITIONS
00186  		; 
00187  		; ALL POSSIBLE SYMBOLIC EQUATES SHOULD BE KEPT IN THIS MODULE
00188  		;
00189  		; FOCAL ERROR CODES - NEGATIVE
00190  		;
00191  
00192    00DB              BASTRF	= $DB		; -37 BAD OR MISSING ARGUMENT IN A STRING FUNCTION
00193    00DC              SVRQ	= $DC		; -36 STRING VARIABLE REQUIRED HERE
00194    00DD              SVNA	= $DD		; -35 STRING VARIABLE NOT ALLOWED HERE
00195    00DE              ERRO	= $DE		; -34 I-O ERROR ON OUTPUT DEVICE
00196    00DF              ARGM	= $DF		; -33 ARGUMENT MISSING IN FUNCTION
00197    00E0              XNU32	= $E0		; -32 CURRENTLY NOT USED
00198    00E1              WNEXG	= $E1		; -31 "WRITE" OF NON-EXISTANT GROUP
00199    00E2              UNRFUN	= $E2		; -30 UNRECOGNIZABLE FUNCTION NAME
00200    00E3              PFERR	= $E3		; -29 PARENTHESES ERROR IN FUNCTION
00201    00E4              MNEXL	= $E4		; -28 "MODIFY" OF NON-EXISTANT LINE
00202    00E5              DONEXG	= $E5		; -27 "DO" OF NON-EXISTANT GROUP
00203    00E6              DONEXL	= $E6		; -26 "DO" OF NON-EXISTANT LINE
00204    00E7              IFSYN	= $E7		; -25 SYNTAX ERROR IN "IF" OR "ON" COMMAND
00205    00E8              ENEXL	= $E8		; -24 "ERASE" OF NON-EXISTANT LINE
00206    00E9              ERRI	= $E9		; -23 I-O ERROR ON INPUT DEVICE
00207    00EA              WNEXL	= $EA		; -22 "WRITE" OF NON-EXISTANT LINE
00208    00EB              GONEXL	= $EB		; -21 "GOTO" NON-EXISTANT LINE
00209    00EC              BADLI	= $EC		; -20 BAD LINE NUMBER ON INPUT
00210    00ED              UNKINT	= $ED		; -19 UNKNOWN INTERRUPT REQUEST
00211    00EE              UNRBRK	= $EE		; -18 UNRECOGNIZABLE TRAP CODE
00212    00EF              RESBRK	= $EF		; -17 RESET BUTTON PRESSED
00213    00F0              DEVRNG	= $F0		; -16 DEVICE NUMBER OUT OF RANGE
00214    00F1              UFL	= $F1		; -15 USELESS "FOR" LOOP
00215    00F2              FBDTRM	= $F2		; -14 BAD TERMINATOR IN "FOR"
00216    00F3              NOEQLS	= $F3		; -13 NO "=" IN "FOR"
00217    00F4              BADVAR	= $F4		; -12 BAD VARIABLE NAME
00218    00F5              FUNILL	= $F5		; -11 FUNCTION ILLEGAL HERE
00219    00F6              XNU10	= $F6		; -10 NOT USED AT THIS TIME
00220    00F7              XNU9	= $F7		; -9 NOT USED AT THIS TIME
00221    00F8              FOVFL	= $F8		; -8 FLOATING POINT OVERFLOW
00222    00F9              OPNMIS	= $F9		; -7 OPERAND MISSING - EVAL
00223    00FA              PMATCH	= $FA		; -6 PARENTHESES MISMATCH - EVAL
00224    00FB              OPRMIS	= $FB		; -5 OPERATOR MISSING - EVAL
00225    00FC              ILLNO	= $FC		; -4 ILLEGAL LINE NUMBER
00226    00FD              BADCOM	= $FD		; -3 UNRECOGNIZABLE COMMAND
00227    00FE              EILLG0	= $FE		; -2 ILLEGAL GROUP ZERO USAGE
00228    00FF              LTL	= $FF		; -1 LINE TOO LONG
00229  
00230  		;
00231  		; FUNCTION HASH CODE DEFINITIONS
00232  		;
00233    0036              HFABS	= $36		; ABSOLUTE VALUE FUNCTION
00234    00F4              HFOUT	= $F4		; OUTPUT FUNCTION
00235    00B0              HFRAN	= $B0		; RANDOM NUMBER FUNCTION
00236    00A8              HFINT	= $A8		; INTERGERIZE FUNCTION
00237    00A4              HFINR	= $A4		; INTEGERIZE AFTER ROUNDING FUNCTION
00238    0084              HFIDV	= $84		; SET INPUT DEVICE FUNCTION
00239    00B4              HFODV	= $B4		; SET OUTPUT DEVICE FUNCTION
00240    005C              HFCHR	= $5C		; SINGLE ALPHA CHAR INPUT FUNCTION
00241    0090              HFCUR	= $90		; SPECIAL CLRSCR ADDRESSING FUNCTION
00242    0044              HFECH	= $44		; ECHO CONTROL FUNCTION
00243    00AA              HFPIC	= $AA		; PRIORITY INTERRUPT CONTROL FUNCTION
00244    0096              HFMEM	= $96		; MEMORY EXAMINE-DEPOSIT FUNCTION
00245    0092              HFINI	= $92		; INITIALIZE INPUT DEVICE FUNCTION
00246    009E              HFINO	= $9E		; INITIALIZE OUTPUT DEVICE FUNCTION
00247    005A              HFCLI	= $5A		; CLOSE INPUT DEVICE FUNCTION
00248    0066              HFCLO	= $66		; CLOSE OUTPUT DEVICE FUNCTION
00249    0070              HFCON	= $70		; SET CONSOLE DEVICE FUNCTION
00250    00C4              HFSBR	= $C4		; 'SUBROUTINE' CALL FUNCTION
00251    00AC              HFISL	= $AC		; INITIALIZE STRING LENGTH FUNCTION
00252    00FA              HFSTI	= $FA		; STRING INPUT FUNCTION
00253    0006              HFSTO	= $06		; STRING OUTPUT FUNCTION
00254    00DE              HFSLK	= $DE		; STRING "LOOK" FUNCTION
00255  
00256  		; MORE DEFINITIONS
00257  
00258    0005              NUMBF	= 5		; # BYTES IN A F.P. #
00259    0008              VARSIZ	= 3+NUMBF	; 1 BYTE FOR NAME, 2 BYTES SUBSCRIPT, THEN VALUE
00260    007F              LINEL	= 127		; MAX LENGTH FOCAL LINE +1; MUST NOT >127 (SEE 'PACKC')
00261    00FF              EOV	= $FF		; END OF VAR MARKER
00262    00FE              EOP	= $FE		; END OF PROG MARKER
00263    00FD              UMARK	= $FD		; ANOTHER UNIQUE MARKER
00264    00FC              STRMRK	= $FC		; MARKS A STRING VAR IN VAR LIST
00265    0048              STRLEN	= 72		; DEF STRING LENGTH
00266  
00267    005C              RUBECH	= $5C	; '\' ECHOED FOR RUBOUT (unused here for modern tty emu)
00268    005F              LINCHR	= $5F	; '_' ECHOED FOR LINE DELETE
00269    001B              ALTCHR	= $1B	; 'ESC' CHAR USED FOR 'ALTMODE' - MAY REQUIRE CHANGE
00270    007F              RUBCHR  = $7F
00271  
00272    00FF              DIRLIN	= $FF
00273    00FE              STRLIN	= $FE
00274    00FD              RETCMD	= $FD
00275  
00276    0100              STACK	= $0100
00277  
00278  ; self modifying code locations: (P.R.S-M)
00279  ;                H2350   EQU $2350
00280  ;                H2351   EQU $2351
00281  ;                H282F   EQU $282F
00282  ;                H2830   EQU $2830
00283  ;                H340A   EQU $340A
00284  ;                H340C   EQU $340C
00285  
00286  ;			***** 'FOCINT - FOCAL CODE INTERPRETER
00287  ;
00288  ;		THIS IS WHERE THE HEART OF FOCAL LIES.  INPUT PROCESSING,
00289  ;	COMMAND DECODING, CONTROL FLOW, AND EXECUTION ARE PERFORMED
00290  ;	IN THIS MODULE.
00291  ;		
00292  
00293  002000                       .ORG $2000
00294  
00295  ;	'FOCAL' COMES HERE ON A 'RESET' (PANIC RESTART)
00296  
00297  002000  78            FOCAL     SEI		; MAKE SURE INTERRUPTS ARE DISABLED
00298  002001  D8                      CLD		; AND DICIMAL MODE IS OFF
00299  002002  A2 FF                   LDX #$FF	; INIT STACK POINTER
00300  002004  9A                      TXS
00301  002005  20 0D 20                JSR SETUP	; SET UP SOME INITIAL PARAMETERS
00302  002008  20 27 20                JSR INIDEV	; INIT CONSOLE DEVICE
00303  00200B  00                      BRK		; ENTER FOCAL VIA TRAP
00304            .BYTE $EF	; A DATA BYTE - INDICATE 'RESET' PRESSED
00305  00200D  A2 FF         SETUP     LDX #$FF	; INIT SOFTWARE PUSHDOWN LIST
00306  00200F  20 1C 20                JSR PDPINI     
00307  002012  E8                      INX		; FORM A ZERO IN X
00308  002013  86 6B                   STX ECHFLG	; TURNS ECHOING ON
00309  002015  A5 6A         CLRDEV    LDA CONDEV	; SET CONSOLE AS BOTH IN AND OUT DEVICES
00310  002017  85 66                   STA IDEV
00311  002019  85 67                   STA ODEV
00312  00201B  60                      RTS
00313  ; 
00314  ; ROUTINE TO INIT SOFTWARE PUSHDOWN LIST POINTER
00315  ; 
00316  00201C  86 4E         PDPINI    STX PDP	; ASSUMED TO CONTAIN '$FF' IN X REGISTER
00317  00201E  A5 53                   LDA PDLIST	; RESET ADDR POINTER
00318  002020  85 4C                   STA PDPADR
00319  002022  A5 54                   LDA PDLIST+1
00320  002024  85 4D                   STA PDPADR+1
00321  002026  60                      RTS
00322  ; 
00323  ; ROUTINE TO INIT I/O DEVICES
00324  ; 
00325  002027  A5 66         INIDEV    LDA IDEV	; INIT INPUT DEVICE
00326  002029  20 8D 2E                JSR INI     
00327  00202C  A5 67                   LDA ODEV	; INIT OUTPUT DEVICE
00328  00202E  4C A2 2E                JMP INO	; * PJMP * AND RETURN
00329  ; 
00330  002031  A2 FF         START     LDX #$FF	; warm entry point. FOCAL comes here
00331  002033  9A                      TXS		; on an internal restart. INIT STACK
00332  002034  86 21                   STX DMPSW	; FLAG THE TRACE OFF
00333  002036  86 26                   STX PC	; INDICATE PROC. A DIRECT COMMAND
00334  002038  E8                      INX		; GET A ZERO
00335  002039  86 20                   STX DEBGSW	; ALLOW TRACE TO BE ENABLED
00336  00203B  86 28                   STX TXTADR	; INIT TEXT POINTERS TO CMD BUFFER
00337  00203D  86 2A                   STX TEXTP	; RESET OFFSET POINTER TO TEXT LINE
00338  00203F  86 6D                   STX ACTMSK	; INDICATE ALL S/W INTER. CHNLS INACTIVE
00339  002041  86 6E                   STX EVMASK	; CLEAR ANY EXT. EVENT FLAGS
00340  002043  86 2E                   STX PRILVL	; SET TO LOWEST PRIORITY LEVEL
00341  002045  E8                      INX		; GET A 1
00342  002046  86 29                   STX TXTADR+1	; CMD BUFFER IS IN STACK AREA
00343  002048  A9 2A                   LDA #$2A	; LOAD PROMPT CHARACTER '*'
00344  00204A  20 02 29                JSR PRINTC	;   AND ANNOUNCE OUR PRESENCE
00345  00204D  20 C0 28      NEXTIC    JSR READC	; GO INPUT A CHAR FROM INPUT DEVICE
00346  002050  C9 0A                   CMP #$0A	; LF?
00347  002052  F0 F9                   BEQ NEXTIC	; YES, IGNORE LF ON COMMAND INPUT
00348  002054  20 2D 29                JSR PACKC1	; NO, STORE CHAR IN CMD BUFFER
00349  002057  C9 0D                   CMP #$0D	; CR?
00350  002059  D0 F2                   BNE NEXTIC	; IF NOT, GET ANOTHER
00351  ; 
00352  ; COMMAND/INPUT PROCESSOR
00353  ; 
00354  00205B  A2 00         IRETN     LDX #$00	; RESET TEXT POINTER
00355  00205D  86 2A                   STX TEXTP
00356  00205F  86 24                   STX INSW	; FLAG TEXT CHAR TO COME FROM MEMORY
00357  002061  CA                      DEX		; SET TO $FF
00358  002062  20 1C 20                JSR PDPINI	; INIT SOFTWARE PDL POINTER
00359  002065  20 B1 29                JSR GSPNOR	; IGNORE LEADING BLANKS
00360  002068  20 C0 29                JSR TESTN1	; HAVE A NUMBER?
00361  00206B  90 06                   BCC GOTNUM	; YES, BRANCH
00362  00206D  C9 2E                   CMP #$2E	; NO, TEST '.'
00363  00206F  D0 13                   BNE INPX1	; NOT # OR '.', MUST BE DIRECT CMD
00364  002071  00                      BRK		; TRAP
00365           .BYTE $FE	; CODE FOR ILL. GROUP 0 USEAGE
00366  002073  E6 20         GOTNUM    INC DEBGSW	; A DIGIT; DISABLE TRACE FOR PACKING
00367  002075  20 B6 25                JSR GETLNC	; GET THE LINE # FROM COMBUF
00368  002078  70 08                   BVS IBADL	; 00.00 IS A BAD LINE NUMBER
00369  00207A  F0 06                   BEQ IBADL	; GG.00 IS A BAD LINE NUMBER
00370  00207C  20 84 27      REPLIN    JSR INSERT	; GO INSERT THIS LINE IN THE TEXT AREA
00371  00207F  4C 31 20      RSTART    JMP START	; AND START OVER FOR NEXT DIR. CMD
00372  002082  00            IBADL     BRK		; TRAP
00373           .BYTE $EC	; ?BAD LINE # ON INPUT
00374  
00375  002084  20 1C 28      INPX1     JSR PUSHJ	; PROCESS COMMAND
00376            .WORD PROC	; $2302
00377  002089  A5 26                   LDA PC	; GET PROGRAM LINE NUMBER
00378  00208B  30 A4                   BMI START     ; START OVER IF DIRECT CMD
00379  00208D  20 D7 26                JSR EATCR1	; EAT TO END OF LINE
00380  002090  20 32 27                JSR NXTLIN	; GO SET UP POINTERS TO NEXT LINE
00381  002093  B0 EF                   BCS INPX1     ; BRANCH IF MORE TO DO
00382  002095  90 9A                   BCC START     ; BRANCH IF END OF PROGRAM
00383  ; 
00384  ; ROUTINE TO 'DO' CODE STORED IN A STRING
00385  ; 
00386  ; THIS ROUTINE ALLOWS THE EXECUTION OF CODE STORED IN A
00387  ; STRING VARIABLE.  IF ONE PLACES CHARACTERS INTO A STRING
00388  ; VARIABLE, AND ENDS THEM WITH A CARRIAGE RETURN, THEN A
00389  ; 'DO' COMMAND CAN BE USED TO PERFORM THE LINE STORED IN THE
00390  ; STRING VARIABLE.
00391  ; 
00392  002097  20 B9 20      DOSTR     JSR PUSHDO	; SAVE CURRENT GOODIES ON STACK
00393  00209A  A5 37                   LDA VARADR	; POINT TO SPEC. CHAR IN STRING
00394  00209C  85 28                   STA TXTADR	;   WITH TEXT POINTERS
00395  00209E  A5 38                   LDA VARADR+1
00396  0020A0  85 29                   STA TXTADR+1
00397  0020A2  A5 3A                   LDA VSUB+1	; GET CHAR POSITION IN STRING
00398  0020A4  85 2A                   STA TEXTP     
00399  0020A6  A9 FE                   LDA #STRLIN	; FLAG THIS SO 'FNDLIN' WILL ALWAYS LOOK
00400  0020A8  85 26                   STA PC	;   FROM BEGINNING OF PROGRAM TEXT
00401  0020AA  A5 3D                   LDA VCHAR	; STORE THE STRING VARIABLE'S NAME FOR
00402  0020AC  85 27                   STA PC+1	;   ERROR MSG PRINT ROUTINE (BERROR)
00403  0020AE  20 1C 28                JSR PUSHJ	; NOW 'DO' THE STRING (SHUD HAVE CR!)
00404            .WORD PROCES	; $22FF
00405  0020B3  20 C0 20                JSR POPDO	; RESTORE CURRENT GOODIES
00406  0020B6  20 4B 28                JSR POPJ	;   AND RETURN FROM 'DO'
00407  ; 
00408  ; ROUTINE TO SAVE NEEDED INFO ON STACK.  USED BY 'DO'
00409  ; 
00410  0020B9  A2 26         PUSHDO    LDX #$26	; GET ADDR OF START OF SAVE AREA
00411  0020BB  A0 09                   LDY #$09	;   AND # OF BYTES TO SAVE
00412  0020BD  4C 6B 28                JMP PUSHB0	; * PJMP * PUSH THEM ON STACK & RET.
00413  ; 
00414  ; ROUTINE TO RESTORE NEEDED INFO AFTER THE 'DO'
00415  ; 
00416  0020C0  A2 2E         POPDO     LDX #$2E	; GET BASE ADDR TO PUT INFO BACK INTO
00417  0020C2  A0 09                   LDY #$09	;   AND # OF BYTES TO RESTORE
00418  0020C4  4C 5B 28                JMP POPB0	; * PJMP * POP THEM OFF AND RETURN
00419  ; 
00420  ; 'IF' COMMAND PROCESSOR (CONDITIONAL GOTO)
00421  ; THROW IN THE 'QUIT' COMMAND HERE ALSO
00422  ; 
00423    2031              QUIT     = START
00424  
00425  ON
00426  ; 
00427  ; in WW source of '77, JSR PUSHA is here; not in Aresco binary --dhh
00428  ; 
00429  0020C7  85 23         IFON      STA $23	; not in Aresco code
00430  0020C9  20 B1 29                JSR GSPNOR	; MOVE TO NEXT NON-BLANK
00431  0020CC  C9 28                   CMP #$28	; '('
00432  0020CE  F0 02                   BEQ IFCNT1	; YES, BRANCH
00433  0020D0  00                      BRK		; NO, TRAP
00434            .BYTE $E7	; SYNTAX ERROR IN 'IF' OR 'ON' CMD (IFSYN)
00435  0020D2  20 1C 28      IFCNT1    JSR PUSHJ	; NOW EVALUATE WHAT'S IN PARENS
00436            .WORD EVALM1
00437  0020D7  A5 2B                   LDA CHAR	; GET TERMINATOR
00438  0020D9  C9 29                   CMP #$29	; ')'
00439  0020DB  F0 02                   BEQ IFCNT2	; YES, CONTINUE
00440  0020DD  00                      BRK		;NO, TRAP
00441            .BYTE PMATCH	; ?PARENTHESIS MISMATCH
00442  0020DF  20 92 29      IFCNT2    JSR GETC	; MOVE PAST RIGHT PAREN
00443  0020E2  A5 81                   LDA FLCSGN	; GET THE SIGN OF THE EXPRESSION
00444  0020E4  30 2B                   BMI IFXCT	; IF NEGATIVE, GO DO IT NOW
00445  0020E6  10 03                   BPL IF3	; OTHERWISE, LOOK FOR COMMA
00446  0020E8  20 92 29      IFCOM     JSR GETC	; GET A CHAR
00447  0020EB  A5 2B         IF3       LDA CHAR
00448  0020ED  C9 2C                   CMP #$2C	; ','
00449  0020EF  F0 0B                   BEQ IF1	; BRANCH IF YES
00450  0020F1  C9 3B                   CMP #$3B	; ';'
00451  0020F3  F0 31                   BEQ IFNOP	; YES, CONTINUE WITH NEXT CMD ON THIS LINE
00452  0020F5  C9 0D                   CMP #$0D	; CR?
00453  0020F7  D0 EF                   BNE IFCOM	; NO, KEEP LOOKING ('JSR POPA' in betw. orig)
00454  0020F9  20 4B 28                JSR POPJ	; YES, THEN EXIT 'PROCESS'
00455  0020FC  20 92 29      IF1       JSR GETC	; MOVE PAST THE COMMA
00456  0020FF  A9 00                   LDA #$00	;          from here, the Aresco code is wildy
00457  002101  A2 03                   LDX #$03	; different from the original Program Exchange.  ...
00458  002103  15 81         L2103     ORA $81,X	; (left generic label from disassembly here)
00459  002105  CA                      DEX		;
00460  002106  10 FB                   BPL L2103	;
00461  002108  09 00                   ORA #$00	; ... to here.  --dhh
00462  00210A  F0 05                   BEQ IFXCT	; BRANCH IF FAC1=0
00463  00210C  20 CB 2C                JSR ZRFAC1	; SET IT TO ZERO, THIS TIME FOR SURE
00464  00210F  30 DA                   BMI IF3 	; UNCONDITIONAL BRANCH
00465  002111  20 BC 25      IFXCT     JSR GETLNS	; GO GET THE LINE NUMBER
00466  002114  08                      PHP		; SAVE PROCESSOR FLAGS
00467  002115  20 FE 26                JSR EATECM	; NOW EAT UNTIL THE END OF A COMMAND
00468  002118  28                      PLP		; GET FLAGS BACK
00469  002119  70 0B                   BVS IFNOP	; BRANCH IF NO LINE NUMBER GIVEN
00470  00211B  08                      PHP		; SAVE THEM AGAIN
00471  00211C  A5 23                   LDA IFONSW	;   is 'JSR POPA' in orig.
00472  00211E  C9 4F                   CMP #$4F	; 'O'
00473  002120  F0 07                   BEQ IFDO1	; YES, GO 'DO' THE LINE
00474  002122  28                      PLP		; ADJUST STACK
00475  002123  4C F5 22                JMP GOTO1	; NO, 'IF' CMD, THEN 'GOTO' LINE
00476  002126  4C 02 23      IFNOP     JMP PROC	; ADJUST STACK (then 'JMP PROC' in orig...)
00477  002129  68            IFDO1     PLA		; GET STATUS SAVED AFTER 'GETLN' CALL
00478  00212A  AA                      TAX 		; SAVE IN THE X REGISTER
00479  00212B  20 1C 28                JSR PUSHJ	; NOW PERFORM THE 'DO' OF THE LINE OR GROUP
00480            .WORD DO1	; $21B6
00481  002130  4C 02 23                JMP PROC	; AND THEN CONTINUE PROCESSING ON THIS LINE
00482  
00483    20C7              IF     = ON		; BOTH COMMANDS HAVE COMMON ENTRY POINT
00484  
00485  ; MODIFY CMD PROCESSOR: 'MODIFY' A LINE OF THE USER'S PROGRAM
00486  
00487  002133  20 BC 25      MODIFY    JSR GETLNS	; GET THE LINE NUMBER SPECIFIED
00488  002136  70 02                   BVS BADMOD	; BRANCH IF 00.00
00489  002138  D0 02                   BNE MODNOK	; BRANCH IF GG.LL
00490  00213A  00            BADMOD    BRK		; TRAP
00491       	 .BYTE MNEXL	; ?MODIFY OF NON-EXISTANT LINE (#$E4)
00492  00213C  20 80 26      MODNOK    JSR FINDLN	; TRY TO FIND THE LINE
00493  00213F  90 F9                   BCC BADMOD	; BRANCH IF COULD NOT FIND
00494  002141  20 99 2D             	  JSR CRLF	; OUTPUT A BLANK LINE
00495  002144  20 31 26                JSR PRNTLN	; PRINT THE LINE NUMBER
00496  002147  A0 02                   LDY #$02	; SET OFFSET TO FIRST CHAR ON LINE
00497  002149  84 35                   STY TEXTP2
00498  00214B  A9 00                   LDA #$00
00499  00214D  85 28                   STA TXTADR	; INIT POINTERS TO COMBUF
00500  00214F  85 2A                   STA TEXTP	; 
00501  002151  A9 01                   LDA #$01
00502  002153  85 29                   STA TXTADR+1
00503  002155  20 B0 28      MNXTC     JSR RNOECH	; GO WAIT FOR THE GUY TO TYPE A CHAR
00504  002158  C9 0A                   CMP #$0A	; LINE FEED?
00505  00215A  F0 25                   BEQ MLOOK1	; YES, THEN GO FEED TO END OF LINE
00506  00215C  C9 1B                   CMP #ALTCHR	; ALTMODE?
00507  00215E  F0 1E                   BEQ MLOOK	; YES, THEN PICK UP SEARCH CHAR
00508  002160  C9 7F                   CMP #RUBCHR	; RUBOUT
00509  002162  F0 07                   BEQ MNOECH	; YES, THEN DON'T ECHO
00510  002164  C9 5F                   CMP #LINCHR	; WAS CHAR THE 'LINE-DELETE' CHAR?
00511  002166  F0 03                   BEQ MNOECH	; BRANCH IF IT IS, DO NOT ECHO
00512  002168  20 02 29                JSR PRINTC	; ECHO THE CHARACTER
00513  00216B  20 2D 29      MNOECH    JSR PACKC1	; PACK CHAR INTO COMBUF
00514  00216E  C9 0D                   CMP #$0D	; WAS CHAR A CARRIAGE RETURN?
00515  002170  D0 E3                   BNE MNXTC	; NO, THEN PICK UP NEXT CNE
00516  002172  20 9E 2D      MENDL     JSR OUTLF	; FOLLOW WITH A LINE FEED
00517  002175  A9 01                   LDA #$01	; SET COMBUF OFFSET
00518  002177  85 2A                   STA TEXTP	; FOR 'INSERT'
00519  002179  E6 20                   INC DEBGSW	; DISABLE TRACE FOR INSERT
00520  00217B  4C 7C 20                JMP REPLIN	; AND GO REPLACE OLD LINE WITH EDITED LINE
00521  
00522  00217E  20 B0 28      MLOOK     JSR RNOECH	; SILENTLY GET THE SEARCH CHAR
00523  002181  85 25         MLOOK1    STA MSCHAR	; STORE SEARCH CHAR
00524  002183  A4 35         MLOOK2    LDY TEXTP2	; GET POINTER TO TEXT IN MEMORY
00525  002185  B1 33                   LDA (TXTAD2),Y	; GET CHAR
00526  002187  C8                      INY		; POINT TO NEXT
00527  002188  84 35                   STY TEXTP2	; 
00528  00218A  20 2D 29                JSR PACKC1	; PACK THE CHAR
00529  00218D  20 02 29                JSR PRINTC	; ECHO IT
00530  002190  C5 25                   CMP MSCHAR	; WAS IT THE SEARCH CHAR?
00531  002192  F0 C1                   BEQ MNXTC	; BRANCH IF YES
00532  002194  C9 0D                   CMP #$0D	; CR?
00533  002196  F0 DA                   BEQ MENDL	; YES, THEN THAT'S IT
00534  002198  D0 E9                   BNE MLOOK2	; NO, THEN KEEP LOOKING
00535  ;
00536  ;        'DO' RECURSIVE OPERATE, EXECUTE, OR CALL
00537  ;
00538  00219A  20 1C 28      DO        JSR PUSHJ	; CALL THE 'DO' SUBROUTINE
00539            .WORD DOX	; $21A2
00540  00219F  4C 02 23                JMP PROC	; AND CONTINUE PROCESSING
00541  0021A2  A9 00         DOX       LDA #$00	; ZERO OUT THE STRING VARIABLE SWITCH
00542  0021A4  85 3B                   STA STRSWT
00543  0021A6  20 BC 25                JSR GETLNS	; GO GET THE LINE NUMBER TO 'DO'
00544  0021A9  08                      PHP		; SAVE FLAGS FROM 'GETLNS'
00545  0021AA  A5 3B                   LDA STRSWT	; WAS EXPRESSION A STRING VARIABLE?
00546  0021AC  F0 04                   BEQ DOX1	; BRANCH IF NOT, PRESS ON
00547  0021AE  28                      PLP		; YES, THEN ADJUST STACK
00548  0021AF  4C 97 20                JMP DOSTR	; * PJMP * DO CODE STORED IN STRING, RET
00549  0021B2  28            DOX1      PLP		; RESTORE FLAGS FROM 'GETLNS'
00550  0021B3  4C B9 21                JMP DO2	;   AND ENTER ROUTINE
00551  0021B6  8A            DO1       TXA		; ENTER HERE WITH STATUS FROM 'GETLN' IN X
00552  0021B7  48                      PHA		; SAVE ON STACK
00553  0021B8  28                      PLP		; MAKE CURRENT PROCESSOR STATUS
00554  0021B9  08            DO2       PHP		; SAVE PROCESSOR STATUS ACROSS THE SAVE
00555  0021BA  20 B9 20                JSR PUSHDO	; SAVE IMPORTANT STUFF ON STACK FOR LATER
00556  0021BD  28                      PLP		; GET THE FLAGS BACK
00557  0021BE  70 17                   BVS DOGRP	; BRANCH IF "DO ALL"
00558  0021C0  F0 15                   BEQ DOGRP	; OR "DO" IS A GROUP
00559  0021C2  20 80 26      DOONE     JSR FINDLN	; TRY TO FIND THE LINE TO "DO"
00560  0021C5  B0 02                   BCS DOCNT1	; BRANCH IF WE FOUND IT
00561  0021C7  00                      BRK		; TRAP
00562           .BYTE DONEXL	; ?"DO" OF NON-EXISTANT LINE (#$E6)
00563  0021C9  20 25 27      DOCNT1    JSR NEWLIN	; SET UP THE NEW LINE
00564  0021CC  20 1C 28                JSR PUSHJ	; AND EXECUTE IT
00565            .WORD PROCES	; $22FF
00566  0021D1  20 C0 20      DOCONT    JSR POPDO	; NOW RESTORE IMPORTANT STUFF AS IT WAS
00567  0021D4  20 4B 28                JSR POPJ	; AND RETURN
00568  ;
00569  ;        'DO' COMMAND PROCESSOR
00570  ;
00571  0021D7  20 80 26      DOGRP     JSR FINDLN	; TRY TO LOCATE SMALLEST LINE OF THE GRP
00572  0021DA  A5 51                   LDA TGRP	; IS IT THE SAME GRP WE'RE LOOKING FOR?
00573  0021DC  C5 2C                   CMP GRPNO     
00574  0021DE  F0 02                   BEQ DOGRP1	; BRANCH IF YES
00575  0021E0  00                      BRK	; TRAP
00576           .BYTE DONEXG	; ?"DO" OF NON-EXISTANT GROUP (#$E5)
00577  0021E2  A5 51         DOGRP1    LDA TGRP	; GET THE GROUP NUMBER WE ARE 'DO'ING
00578  0021E4  20 31 28                JSR PUSHA	; SAVE ON STACK
00579  0021E7  20 32 27      DOGRPC    JSR NXTLIN	; SET UP POINTERS FOR NEXT LINE
00580  0021EA  90 1C                   BCC ENDGRP	; BRANCH IF END OF PROGRAM
00581  0021EC  20 3F 28                JSR POPA	; GET GROUP NUMBER WE ARE 'DO'ING
00582  0021EF  20 31 28                JSR PUSHA	; SAVE IT AGAIN
00583  0021F2  09 00                   ORA #$00	; ARE WE DOING GROUP ZERO (ALL)?
00584  0021F4  F0 04                   BEQ DONEXT	; YES, THEN ANY LINE IS OK
00585  0021F6  C5 26                   CMP PC	; IS THIS LINE OF THE SAME GROUP?
00586  0021F8  D0 0E                   BNE ENDGRP	; BRANCH IF NOT
00587  0021FA  20 1C 28      DONEXT    JSR PUSHJ	; YES, THEN PROCESS THIS LINE
00588            .WORD PROCES	; $22FF
00589  0021FF  20 D7 26                JSR EATCR1	; EAT UNTIL A CARRIAGE RETURN
00590  002202  A5 26                   LDA PC	; GET THE CURRENT LINE NUMBER
00591  002204  C9 FD                   CMP #RETCMD	; 'RETURN' COMMAND SEEN?
00592  002206  D0 DF                   BNE DOGRPC	; BRANCH IF NOT, CONTINUE
00593  002208  20 3F 28      ENDGRP    JSR POPA	; ADJUST STACK
00594  00220B  4C D1 21                JMP DOCONT	; AND RETURN FROM "DO"
00595  
00596  ; "RETURN" AND "RESTORE" COMMANDS
00597  
00598  00220E  20 B4 29      RETURN    JSR SPNOR	; GET NEXT NON-BLANK
00599  002211  C9 49                   CMP #$49	; 'I' IS THIS A 'RESTORE INPUT' (R I)?
00600  002213  F0 0B                   BEQ RESINP	; BRANCH IF YES
00601  002215  C9 4F                   CMP #$4F	; 'O' IS THIS A 'RESTORE OUTPUT' (R O)?
00602  002217  F0 0E                   BEQ RESOUT	; BRANCH IF YES
00603  002219  A9 FD                   LDA #RETCMD	; NO, THEN IT MUST BE A "RETURN"
00604  00221B  85 26                   STA PC	; SET PC TO SPECIAL VALUE
00605  00221D  20 4B 28                JSR POPJ	; AND EXIT "PROCESS"
00606  
00607  002220  A5 68         RESINP    LDA IDVSAV	; RESTORE INPUT DEVICE # TO WHAT IT WAS
00608  002222  85 66                   STA IDEV	;   BEFORE LAST STRING INPUT
00609  002224  4C FF 22                JMP PROCES	;   AND CONTINUE EXECUTING ON THIS LINE
00610  002227  A5 69         RESOUT    LDA ODVSAV	; RESTORE OUTPUT DEVICE # TO WHAT IT WAS
00611  002229  85 67                   STA ODEV	;   BEFORE LAST STRING OUTPUT
00612  00222B  4C FF 22                JMP PROCES	;   AND CONTINUE EXECUTING ON THIS LINE
00613  
00614  ; "ERASE" COMMAND PROCESSOR
00615  
00616  00222E  20 B4 29      ERASE     JSR SPNOR	; GO GET NEXT NON-BLANK
00617  002231  A0 00                   LDY #$00	; this is not in the 6502 Group/ProgExch
00618  002233  C9 41                   CMP #$41	; 'A'   source code of 13-Oct-77   --dhh
00619  002235  F0 23                   BEQ EALL	;       occurs later at $225A
00620  002237  20 BF 25                JSR GETLN	; NO, GO GET THE LINE NUMBER TO ERASE
00621  00223A  08                      PHP		; SAVE FLAGS
00622  00223B  20 0A 27                JSR PUSHTP	; SAVE TEXT POINTERS
00623  00223E  28                      PLP		; GET FLAGS BACK
00624  00223F  70 0F                   BVS EVAR	; BRANCH IF JUST 'ERASE' WITH NO LINE NO.
00625  002241  F0 2C                   BEQ EGRP	; BRANCH IF WE ERASE A GROUP
00626  002243  20 80 26                JSR FINDLN	; NOW TRY AND LOCATE THE SPECIFIED LINE
00627  002246  B0 02                   BCS ERCONT	; BRANCH IF WE FOUND IT
00628  002248  00                      BRK	; TRAP
00629            .BYTE ENEXL	; ?ERASE OF NON-EXISTANT LINE (#$E8)
00630  00224A  20 4B 27      ERCONT    JSR DELETE	; GO ZAP THE LINE
00631  00224D  4C 31 20      ERDON     JMP START	; AND GO TO DIRECT COMMAND MODE
00632  002250  A9 FF         EVAR      LDA #EOV	; ERASE ALL THE VARIABLES
00633  002252  91 3E                   STA (VARBEG),Y	; BY FLAGGING LIST AS EMPTY
00634  002254  20 11 27                JSR POPTP	; RESTORE TEXT POINTERS
00635  002257  4C 02 23                JMP PROC	; AND CONTINUE PROCESSING THIS LINE
00636  00225A  A9 FE         EALL      LDA #EOP	; ERASE PROGRAM TEXT
00637  00225C  91 31                   STA (PBADR),Y	; EXCEPT GROUP ZERO
00638  00225E  A5 40                   LDA VARST	; UPDATE VARBEG
00639  002260  85 3E                   STA VARBEG
00640  002262  A5 41                   LDA VARST+1
00641  002264  85 3F                   STA VARBEG+1
00642  002266  A9 FF                   LDA #EOV
00643  002268  91 3E                   STA (VARBEG),Y	; FLAG VARIABLE LIST AS EMPTY
00644  00226A  D0 E1                   BNE ERDON	; AND START OVER
00645  00226C  20 4B 27      ELINE     JSR DELETE	; DELETE THE LINE
00646  00226F  20 18 27      EGRP      JSR TXTINI	; RESET TEXT POINTER TO START OF PROGRAM
00647  002272  20 80 26                JSR FINDLN	; TRY TO FIND THE GROUP
00648  002275  A5 51                   LDA TGRP	; GET GROUP NUMBER OF LINE FOUND
00649  002277  C5 2C                   CMP GRPNO     ; IS IT OF THE GROUP WE ARE DELETING?
00650  002279  F0 F1                   BEQ ELINE     ; BRANCH IF YES, GO DELETE IT
00651  00227B  D0 D0                   BNE ERDON     ; AND RETURN IF ALL LINES IN GRP DELETED
00652  
00653  ; WRITE CMD PROCESSOR: 'WRITE' OUT PARTS OF THE PROGRAM TEXT
00654  
00655  00227D  20 BC 25      WRITE     JSR GETLNS	; GO GET THE GROUP TO WRITE
00656  002280  08                      PHP		; SAVE CONDITION CODES
00657  002281  20 0A 27                JSR PUSHTP	; SAVE POSITION ON THIS LINE
00658  002284  E6 20                   INC DEBGSW	; DISABLE TRACE
00659  002286  28                      PLP		; GET CONDITION CODES AFTER 'GETLN'
00660  002287  70 2B                   BVS WALL	; BRANCH IF 'WRITE ALL'
00661  002289  D0 19                   BNE WLINE	; BRANCH IF WE WRITE A SINGLE LINE
00662  00228B  20 80 26      WGRP      JSR FINDLN	; TRY TO FIND THE GROUP
00663  00228E  A5 51                   LDA TGRP	; GET THE GROUP LOCATED IN MEMORY
00664  002290  C5 2C                   CMP GRPNO	; IS IT THE ONE WE ARE LOOKING FOR?
00665  002292  F0 02                   BEQ WGRP1	; BRANCH IF YES     
00666  002294  00                      BRK		; TRAP
00667            .BYTE WNEXG	; ?'WRITE' OF NON-EXISTANT GROUP (#$E1)
00668  002296  20 C0 22      WGRP1     JSR WGRPO	; OUTPUT THE GROUP
00669  002299  20 EB 22      WEXIT     JSR WCRLF	; BLANK LINE
00670  00229C  C6 20                   DEC DEBGSW	; ENABLE TRACE AGAIN
00671  00229E  20 11 27                JSR POPTP	; RESTORE TEXT POINTERS
00672  0022A1  4C 02 23                JMP PROC	;   AND CONTINUE PROCESSING ON THIS LINE
00673  0022A4  20 80 26      WLINE     JSR FINDLN	; TRY TO FIND THE LINE
00674  0022A7  B0 02                   BCS WLINE1	; BRANCH IF WE FOUND IT
00675  0022A9  00                      BRK		; TRAP
00676            .BYTE WNEXL	; ?'WRITE' OF NON-EXISTANT LINE (code #$EA)
00677  0022AB  20 EB 22      WLINE1    JSR WCRLF	; OUTPUT BLANK LINE
00678  0022AE  20 CD 22                JSR WONE	; OUTPUT THE SINGLE LINE
00679  0022B1  4C 99 22                JMP WEXIT	;   THEN EXIT 'WRITE' 
00680  0022B4  20 80 26      WALL      JSR FINDLN	; GO FIND GROUP ZERO (ALWAYS WINS)
00681  0022B7  20 C0 22      WALL1     JSR WGRPO	; OUTPUT THIS GROUP
00682  0022BA  F0 DD                   BEQ WEXIT	; BRANCH IF END OF PROGRAM
00683  0022BC  85 51                   STA TGRP	; MAKE EXIT GROUP THE GROUP TO OUTPUT
00684  0022BE  D0 F7                   BNE WALL1	;    AND GO OUTPUT IT
00685  0022C0  20 EB 22      WGRPO     JSR WCRLF	; OUTPUT BLANK LINE
00686  0022C3  20 CD 22      WGRPO1    JSR WONE	; OUTPUT THIS LINE
00687  0022C6  F0 04                   BEQ WEXGRP	; BRANCH IF END OF PROGRAM
00688  0022C8  C5 51                   CMP TGRP	; IS GROUP OF NEXT LINE THE SAME?
00689  0022CA  F0 F7                   BEQ WGRPO1	; BRANCH IF YES
00690  0022CC  60            WEXGRP    RTS		; OTHERWISE RETURN
00691  ;
00692  0022CD  20 31 26      WONE      JSR PRNTLN	; OUTPUT THE LINE NUMBER
00693  0022D0  20 92 29      WONEC     JSR GETC	; GET NEXT CHAR
00694  0022D3  20 02 29                JSR PRINTC	; OUTPUT IT
00695  0022D6  C9 0D                   CMP #$0D	; WAS IT THE END OF THE LINE?
00696  0022D8  D0 F6                   BNE WONEC	; LOOP IF NOT
00697  0022DA  A5 67                   LDA ODEV	; YES, ARE WE OUTPUTTING TO A STRING?
00698  0022DC  30 03                   BMI WEOL	; BRANCH IF WE ARE, DON'T FOLLOW WITH $0A
00699  0022DE  20 9E 2D                JSR OUTLF	; NO, THEN FOLLOW WITH A LINEFEED
00700  0022E1  20 D7 26      WEOL      JSR EATCR1	; YES, POINT TO NEXT LINE
00701  0022E4  A4 2A                   LDY TEXTP	; LOAD Y WITH OFFSET
00702  0022E6  B1 28                   LDA (TXTADR),Y	; PICK OF GRP NUMBER OF NEXT LINE
00703  0022E8  C9 FE                   CMP #EOP	; COMPARE TO END-OF-PROGRAM FLAG
00704  0022EA  60            WRET      RTS		; RETURN WITH Z=1 IF END OF PROGRAM
00705  			; RETURN WITH Z=0 IF NOT END OF PROGRAM
00706  0022EB  A5 67         WCRLF     LDA ODEV	; ARE WE OUTPUTTING TO A STRING?
00707  0022ED  30 FB                   BMI WRET	; BRANCH IF WE ARE, DON'T ADVANCE
00708  0022EF  4C 99 2D                JMP CRLF	; * PJMP * ELSE OUTPUT A CRLF AND RETURN
00709  
00710  ; MAIN CONTROL AND TRANSFER: 'GOTO' COMMAND
00711  
00712  0022F2  20 BC 25      GOTO      JSR GETLNS	; GO GET THE LINE NUMBER
00713  0022F5  20 80 26      GOTO1     JSR FINDLN	; NOW GO TRY TO FIND IT
00714  0022F8  B0 02                   BCS GCONT	; BRANCH IF WE FOUND IT
00715  0022FA  00                      BRK	; TRAP
00716            .BYTE $EB	; ?GOTO NON-EXISTANT LINE
00717  0022FC  20 25 27      GCONT     JSR NEWLIN	; GO SET UP THE NEW LINE
00718                          ; * PFALL * INTO PROCESS
00719  0022FF  20 92 29      PROCES    JSR GETC	; GET NEXT CHARACTER
00720  002302  A5 2B         PROC      LDA CHAR	; JUST IN CASE CALLED FROM ELSEWHERE
00721  002304  C9 0D                   CMP #$0D	; 'CR' END OF LINE?
00722  002306  F0 5B                   BEQ PC1	; IF SO, THEN RETURN
00723  002308  20 52 23                JSR GLTEST	; IS CHAR A TERMINATOR?
00724  00230B  F0 F2                   BEQ PROCES	; IF SO, IGNORE IT
00725  00230D  A6 2E                   LDX PRILVL	; GET CURRENT SOFTWARE INTERRUPT PRIO LVL
00726  00230F  A5 6D                   LDA ACTMSK	; GET BYTE THAT INDICATES WHICH CHAN ACTIVE
00727  002311  F0 13                   BEQ PROC1	; NONE ALLOWED TO HAPPEN, PRESS ON
00728  002313  3D 9D 35                AND $359D,X	; MASK OUT ANY NOT ALLOWED TO HAPPEN
00729  002316  F0 0E                   BEQ PROC1	; BRANCH IF NONE PENDING, PRESS ON
00730  002318  25 6E                   AND EVMASK	; NOW SEE IF ANY EVENT PENDING ON CHANNEL
00731  00231A  F0 0A                   BEQ PROC1	; BRANCH IF NONE PENDING, PRESS ON
00732  00231C  A2 08                   LDX #$08	; WE HAVE AN EVENT TO SERVICE (AT LEAST 1)
00733  00231E  DD A6 35      PRILOP    CMP BITTAB,X	; FIND HIGHEST PRIORITY ONE TO SERVICE
00734  002321  B0 43                   BCS EVNTDO	; BRANCH WHEN WE HAVE IT
00735  002323  CA                      DEX		; NOT THIS LEVEL, TRY LOWER
00736  002324  D0 F8                   BNE PRILOP	;   AND LOOP UNTIL WE FIND IT
00737  			; *** SHOULD NEVER FALL OUT THIS END! ***
00738  002326  A5 2B         PROC1     LDA CHAR	; GET CHARACTER WHICH STARTED COMMAND
00739  			;          handwritten note here in ProgExch code:
00740  			;                 " --* JMP EXIT" 
00741  002328  48                      PHA		; TEMPORARILY SAVE COMMAND CHARACTER
00742  002329  20 52 23      PTERM1    JSR GLTEST	; TERMINATOR?
00743  00232C  F0 05                   BEQ PTERM2	; BRANCH IF YES
00744  00232E  20 92 29                JSR GETC	; OTHERWISE, SKIP OVER REST OF COMMAND NAME
00745  002331  10 F6                   BPL PTERM1	; UNCONDITIONAL BRANCH
00746  002333  68            PTERM2    PLA		; GET 1ST CHAR OF CMD NAME BACK AGAIN
00747  002334  A2 00                   LDX #$00	; INIT TABLE OFFSET TO ZERO
00748  002336  BC 49 35      NXTCOM    LDY COMTAB,X	; GET THE COMMAND CHARACTER
00749  002339  F0 26                   BEQ ILLCOM	; ZERO ENDS THE TABLE
00750  00233B  DD 49 35                CMP COMTAB,X	; IS THIS CHARACTER THE COMMAND WE WANT?
00751  00233E  F0 03                   BEQ GOTCOM	; BRANCH IF YES
00752  002340  E8                      INX		; NO, POINT TO NEXT ONE
00753  002341  D0 F3                   BNE NXTCOM	; UNCONDITIONAL LOOP FOR NEXT ONE
00754  002343  BC 6F 35      GOTCOM    LDY COMADL,X	; GET LOW ORDER ADDR OF ROUTINE
00755  002346  8C 50 23                STY $2350     ; SAVE IN DUMMY JUMP (below)
00756  002349  BC 5D 35                LDY COMADH,X	; GET HIGH ORDER ADDR OF ROUTINE
00757  00234C  8C 51 23                STY $2351     ; SAVE IN DUMMY JUMP (next)
00758  00234F  4C 00 00                JMP $0000     ; DISPATCH TO COMMAND ROUTINE
00759  
00760  ; GLTEST EXITS WITH Z SET IF CHARACTER IN THE ACCUMULATOR
00761  ; IS A TERMINATOR (SPACE, COMMA, OR SEMI-COLON).
00762  
00763  002352  C9 20         GLTEST    CMP #$20	; SPACE?
00764  002354  F0 0A                   BEQ RTS2	; RETURN IF YES
00765  002356  C9 2C                   CMP #$2C	; COMMA?
00766  002358  F0 06                   BEQ RTS2	; RETURN IF YES
00767  00235A  C9 3B         TSTEOC    CMP #$3B	; SEMI-COLON?
00768  00235C  F0 02                   BEQ RTS2	; RETURN IF YES
00769  00235E  C9 0D                   CMP #$0D	; CARRIAGE RETURN?
00770  002360  60            RTS2      RTS		; RETURN WITH Z=1 IF ANY OF THESE
00771  002361  00            ILLCOM    BRK		; TRAP
00772            .BYTE $FD	; ?UNRECOGNIZABLE COMMAND
00773  002363  20 4B 28      PC1       JSR POPJ	; EXIT 'PROCESS'
00774    2363              COMMNT = PC1
00775  
00776  ; ROUTINE TO PERFORM A 'DO' OF A SPECIFIED LINE OR GROUP
00777  ; WHEN AN EXTERNAL EVENT HAPPENS ON A SOFTWARE INTERRUPT CHANNEL.
00778  
00779  002366  8A            EVNTDO    TXA		; SAVE X AS IT HAS LVL OF INTERUPT
00780  002367  48                      PHA		;   THEN SET UP RETURN ADDR ON STACK
00781  002368  A9 0C                   LDA #$0C	; label EVRET, def. as =PROCX-1
00782  00236A  20 31 28                JSR PUSHA	; ALA 'PUSHJ'
00783  00236D  A9 23                   LDA #$23	; MSB of EVRET address
00784  00236F  20 31 28                JSR PUSHA
00785  002372  20 B9 20                JSR PUSHDO	; SAVE IMPORTANT STUFF AT THIS LEVEL
00786  002375  68                      PLA		; GET NEW PRIO LEVEL OF GRP OR LN TO 'DO'
00787  002376  AA                      TAX
00788  002377  86 2E                   STX PRILVL	; SET IT AS OUT NEW PRIO LEVEL
00789  002379  BD A6 35                LDA BITTAB,X	; GET BIT MASK FOR THIS NEW LEVEL
00790  00237C  49 FF                   EOR #$FF	; COMPLIMENT TO MAKE 'AND' MASK
00791  00237E  08                      PHP		; SAVE STATE OF 'I' BIT IN CASE IRQS ARE ON
00792  00237F  78                      SEI		; DISABLE IRQ GRANTING
00793  002380  25 6E                   AND EVMASK	;   WHILE WE UPDATE EVENT MASK
00794  002382  85 6E                   STA EVMASK
00795  002384  28                      PLP		; WE CAN ALLOW IRQS AGAIN (IF ON)
00796  002385  BD 8B 35                LDA INTGRP,X	; GET THE GROUP NUMBER TO 'DO'
00797  002388  85 2C                   STA GRPNO
00798  00238A  BD 94 35                LDA INTLIN,X	;   AND THE LINE NUMBER
00799  00238D  85 2D                   STA LINENO
00800  00238F  20 05 26                JSR GOTLNO	; NOW SET FLAGS TO DETERMINE WHAT TO 'DO'
00801  002392  70 05                   BVS EVDALL	; BRANCH IF WE ARE 'DO'ING ALL
00802  002394  F0 03                   BEQ EVDALL	;   OR 'DO' OF A GROUP
00803  002396  4C C2 21                JMP DOONE	; *PJMP * 'DO' 1 LINE, RETURN TO 'EVRET'
00804  002399  4C D7 21      EVDALL    JMP DOGRP	; *PJMP * 'DO' A GROUP, RETURN TO 'EVRET'
00805  ;
00806  ; 'TYPE - ASK COMMAND PROCESSOR'
00807  ;
00808  00239C  20 76 2C      TDUMP     JSR VARINI	; INIT POINTER TO START OF VARIABLE LIST
00809  00239F  20 99 2D      TDNEXT    JSR CRLF	; START ON NEW LINE
00810  0023A2  A0 00                   LDY #$00	; POINT TO VARIABLE NAME
00811  0023A4  84 3B                   STY STRSWT	; MAKE SURE STRING SWITCH IS OFF
00812  0023A6  B1 37                   LDA (VARADR),Y	; PICK UP THE VARIABLE NAME
00813  0023A8  C9 FF                   CMP #EOV	; END OF VARIABLE LIST?
00814  0023AA  F0 52                   BEQ JTASK4	; BRANCH IF END OF VARIABLE LIST
00815  0023AC  C9 FC                   CMP #STRMRK	; STRING VARIABLE?
00816  0023AE  D0 05                   BNE TDCONT	; BRANCH IF NOT, PRESS ON
00817  0023B0  85 3B                   STA STRSWT	; YES, THEN FLAG IT
00818  0023B2  C8                      INY		;   AND MOVE PAST MARKER, POINT TO NAME
00819  0023B3  B1 37                   LDA (VARADR),Y	; AND PICK UP THE NAME
00820  0023B5  20 E7 23      TDCONT    JSR PRTVNM	; PRINT THE VARIABLE'S NAME
00821  0023B8  A5 3B                   LDA STRSWT	; IS THIS VARIABLE A STRING VARIABLE?
00822  0023BA  D0 45                   BNE TPSTR	; BRANCH IF YES, DO SPECIAL OUTPUT
00823  0023BC  A9 28                   LDA #$28	; '(' AND THEN START OF SUBSCRIPT
00824  0023BE  20 02 29                JSR PRINTC
00825  0023C1  A0 01                   LDY #$01	; POINT TO SUBSCRIPT
00826  0023C3  B1 37                   LDA (VARADR),Y	; GET HIGH ORDER SUBSCRIPT
00827  0023C5  85 81                   STA M1	; SAVE IN FAC1
00828  0023C7  C8                      INY		; POINT TO LOW ORDER SUBSCRIPT
00829  0023C8  B1 37                   LDA (VARADR),Y	; GET IT
00830  0023CA  85 82                   STA M1+1
00831  0023CC  20 4D 32                JSR FLT16	; FORM A FLOATING POINT NUMBER
00832  0023CF  20 5E 26                JSR OUTLN0	;   AND OUTPUT IT
00833  0023D2  A9 29                   LDA #$29	; ')' CLOSING PAREN
00834  0023D4  20 02 29                JSR PRINTC
00835  0023D7  A9 3D                   LDA #$3D	; '=' PUT IN AN EQUALS FOR FORM
00836  0023D9  20 02 29                JSR PRINTC
00837  0023DC  20 AE 2C                JSR FETVAR	; GET THE VARIABLE'S VALUE INTO FLAC
00838  0023DF  20 1F 33                JSR FPRNT	; PRINT IT
00839  0023E2  20 7F 2C                JSR NXTVAR	; POINT TO NEXT VARIABLE IN THE LIST
00840  0023E5  D0 B8                   BNE TDNEXT	; UNCONDITIONALLY LOOP FOR MORE
00841  ;
00842  ; ROUTINE TO PRINT OUT A VARIABLE'S NAME
00843  ;
00844  0023E7  48            PRTVNM    PHA		; SAVE COMPOSITE FORM
00845  0023E8  4A                      LSR  		; EXTRACT ALPHA PART
00846  0023E9  4A                      LSR  
00847  0023EA  4A                      LSR  
00848  0023EB  09 40                   ORA #$40	; FORM ASCII
00849  0023ED  C9 46                   CMP #$46	; 'F', ACTUALLY '&', SINCE 'F' IS ILLEGAL
00850  0023EF  D0 02                   BNE TPNAM	; NOT SPECIAL, SO PRINT IT
00851  0023F1  A9 26                   LDA #$26	; '&' PRINT A '&' AS SPECIAL VARIB NAME
00852  0023F3  20 02 29      TPNAM     JSR PRINTC	;   AND PRINT IT
00853  0023F6  68                      PLA		; GET BACK HASH
00854  0023F7  29 07                   AND #$07	; EXTRACT NUMBER
00855  0023F9  09 30                   ORA #$30	; FORM ASCII
00856  0023FB  4C 02 29                JMP PRINTC	; * PJMP * PRINT THE VARIB # THEN RETURN
00857  0023FE  4C D3 24      JTASK4    JMP TASK4	; BRANCH AID
00858  ; *** BEGIN MIKE B'S SECTION
00859  
00860                          ;
00861          ; HERE TO TYPE OUT A STRING VARIABLE
00862                          ;
00863  002401  A9 24         TPSTR   LDA #$24        ; '$' INDICATE IT'S A STRING VARIABLE
00864  002403  20 02 29              JSR PRINTC      ;
00865  002406  A9 3D                 LDA #$3D        ; '=' DON'T PRINT A SUBSCRIPT ON A $ VARIB
00866  002408  20 02 29              JSR PRINTC      ;
00867  00240B  A9 22                 LDA #$22        ; '"' DELIMIT STRING WITH QUOTES
00868  00240D  20 02 29              JSR PRINTC      ;
00869  002410  A0 02                 LDY #$02        ; POINT TO STRING LENGTH
00870  002412  B1 37                 LDA (VARADR),Y  ; PICK UP THE STRING LENGTH
00871  002414  85 3C                 STA VSIZE       ; SAVE IT
00872  002416  C8                    INY             ; POINT TO FIRST BYTE OF STRING
00873  002417  98                    TYA             ; NOW UPDATE 'VARADR' TO BASE ADDR OF $
00874  002418  20 81 2C              JSR UPDVAR      ;
00875  00241B  A0 00                 LDY #$00        ; POINT TO FIRST BYTE OF STRING
00876  00241D  98            TPNXTC  TYA             ; SAVE OFFSET
00877  00241E  48                    PHA             ;
00878  00241F  B1 37                 LDA (VARADR),Y  ; GET BYTE FROM STRING
00879  002421  20 02 29              JSR PRINTC      ; PRINT THE BYTE
00880  002424  68                    PLA             ; RESTORE POINTER
00881  002425  A8                    TAY             ;
00882  002426  C8                    INY             ; POINT TO NEXT BYTE
00883  002427  C4 3C                 CPY VSIZE       ; PRINTED ALL OF STRING YET?
00884  002429  D0 F2                 BNE TPNXTC      ; BRANCH IF MORE TO PRINT
00885  00242B  98                    TYA             ; YES, THEN SKIP OVER STRING BY
00886  00242C  20 81 2C              JSR UPDVAR      ;   UPDATING 'VARADR'
00887  00242F  A9 22                 LDA #$22        ; '"' CLOSE OFF STRING WITH CLOSING QUOTE
00888  002431  20 02 29              JSR PRINTC      ;
00889  002434  4C 9F 23              JMP TDNEXT      ; AND DUMP NEXT VARIABLE
00890                          ;
00891  002437  4C 9C 23      JTDUMP  JMP TDUMP       ; BRANCH AID
00892                          ;
00893          ; 'TYPE - ASK COMMAND PROCESSOR'
00894                          ; 
00895  00243A  20 1C 28      TASK1   JSR PUSHJ       ; GO GET THE VARIABLE
00896          .WORD GETVAR    ; ($1B43 in ww -- mtb)
00897  00243F  20 9B 2C              JSR BOMSTV      ; BOMB OUT IF A $ VARIABLE IS USED IN 'ASK'
00898  002442  A5 2B                 LDA CHAR        ; SAVE DELIMITER
00899  002444  48                    PHA             ;   ON HARDWARE STACK
00900  002445  E6 24                 INC INSW        ; FLAG INPUT FROM KEYBOARD
00901  002447  A2 37         ASKAGN  LDX #VARADR     ; SAVE THE VARIABLE'S ADDRESS
00902  002449  20 69 28              JSR PUSHB2      ;
00903  00244C  20 1C 28              JSR PUSHJ       ; NOW GO GET USER SUPPLIED DATA
00904          .WORD EVALM1    ; ($19F5 in ww -- mtb)
00905                          ;
00906  ;        LDA #$41        ; RESTORE 'ATSW' (SINCE WE MUST BE RECURSIVE!)
00907  ;        STA ATSW        ; (in ww -- mtb)
00908  002451  A2 38                 LDX #VARADR+1   ; RESTORE VARIABLE'S ADDRESS
00909  002453  20 59 28              JSR POPB2       ;
00910  002456  A5 2B                 LDA CHAR        ; GET DELIMITER FROM EVAL
00911  002458  C9 5F                 CMP #LINCHR     ; WAS IT 'LINE-DELETE' CHARACTER?
00912  00245A  D0 0B                 BNE STODAT      ; BRANCH IF NOT, STORE VALUE AWAY
00913  00245C  A5 66                 LDA IDEV        ; YES, IS THE INPUT DEVICE
00914  00245E  C5 6A                 CMP CONDEV      ;   THE CONSOLE?
00915  002460  D0 E5                 BNE ASKAGN      ; BRANCH IF NOT, ASK AGAIN
00916  002462  20 99 2D              JSR CRLF        ; YES, ADVANCE A LINE
00917  002465  10 E0                 BPL ASKAGN      ;   AND ASK AGAIN
00918  002467  20 A1 2C      STODAT  JSR PUTVAR      ; PLACE DATA IN VARIABLE
00919  00246A  C6 24                 DEC INSW        ; FLAG INPUT FROM CORE AGAIN
00920  00246C  68                    PLA             ; GET DELIMITER BACK AGAIN
00921  00246D  85 2B                 STA CHAR        ;
00922  00246F  10 13                 BPL TASK        ; UNCONDITIONALLY CONTINUE PROCESSING
00923                          ;
00924  002471  20 92 29      TFORM   JSR GETC        ; MOVE PAST '%'
00925  002474  20 BC 25              JSR GETLNS      ; GET GG.SS
00926  002477  A5 2C                 LDA GRPNO       ; GET GG
00927  002479  85 8F                 STA M           ; SAVE AS NUMBER BEFORE DECIMAL POINT
00928  00247B  A5 2D                 LDA LINENO      ; GET SS
00929  00247D  85 90                 STA N           ; SAVE AS NUMBER AFTER DECIMAL POINT
00930  00247F  4C 84 24              JMP TASK        ;   AND CONTINUE PROCESSING
00931                          ;
00932  002482  85 22         TYPE    STA ATSW        ; FLAG WHICH ONE IT IS
00933  002484  A9 00         TASK    LDA #$00        ; ENABLE THE TRACE
00934  002486  85 20                 STA DEBGSW      ;
00935  002488  20 B4 29              JSR SPNOR       ; LOOK FOR NEXT NON-BLANK
00936  00248B  C9 24                 CMP #$24        ; '$'
00937  00248D  F0 A8                 BEQ JTDUMP      ; DUMP OUT THE VARIABLE LIST
00938  00248F  C9 25                 CMP #$25        ; '%' FORMAT CONTROL?
00939  002491  F0 DE                 BEQ TFORM       ; BRANCH IF YES
00940  002493  C9 21                 CMP #$21        ; '!' SEE IF SPECIAL
00941  002495  F0 32                 BEQ TCRLF       ; GIVE OUT A CARRIAGE RETURN-LINE FEED
00942  002497  C9 23                 CMP #$23        ; '#'
00943  002499  F0 33                 BEQ TCR         ; CARRIAGE RETURN ONLY
00944  00249B  C9 22                 CMP #$22        ; '"'
00945  00249D  F0 39                 BEQ TQUOT       ; TYPE OUT A QUOTED STRING
00946  00249F  C9 2C                 CMP #$2C        ; ','
00947  0024A1  F0 30                 BEQ TASK4       ; IGNORE IN CASE USER WANTS IT TO LOOK PRETTY
00948  0024A3  C9 3B                 CMP #$3B        ; ';' END OF COMMAND?
00949  0024A5  F0 4A                 BEQ TPROC       ; YES, THEN BRANCH
00950  0024A7  C9 0D                 CMP #$0D        ; 'CR' END OF LINE?
00951  0024A9  F0 3F                 BEQ TPC1        ; YES, THEN GO HANDLE IT
00952  0024AB  A5 22                 LDA ATSW        ; NOT SPECIAL CHAR, GET COMMAND SWITCH
00953  0024AD  C9 41                 CMP #$41        ; 'A' WHICH COMMAND ARE WE DOING?
00954  0024AF  F0 89                 BEQ TASK1       ; BRANCH IF 'ASK', AS IT DIFFERS
00955  0024B1  20 1C 28              JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE THE EXPRESSION
00956          .WORD EVAL      ; ($19F8 in ww -- mtb)
00957  ;        LDA #$54        ; RESTORE 'ATSW' (SINCE WE MUST BE RECURSIVE!)
00958  ;        STA ATSW        ; (in ww -- mtb)
00959  0024B6  20 1F 33              JSR FPRNT       ; GO OUTPUT IT
00960  0024B9  A5 2B                 LDA CHAR        ; GET TERMINATOR FROM 'EVAL'
00961  0024BB  C9 29                 CMP #$29        ; ')' SO "TYPE 3)" DOESN'T DIE!
00962  0024BD  F0 14                 BEQ TASK4       ; FLUSH IF WE DON'T LIKE IT
00963  0024BF  C9 3D                 CMP #$3D        ; '=' ALSO FLUSH OTHER NASTIES
00964  0024C1  F0 10                 BEQ TASK4       ;
00965  0024C3  C9 2E                 CMP #$2E        ; '.'
00966  0024C5  F0 0C                 BEQ TASK4       ;
00967  0024C7  D0 BB                 BNE TASK        ; OTHERWISE, CONTINUE PROCESSING
00968                          ;
00969    2482              ASK     = TYPE          ; ($1488 in ww -- mtb)
00970                          ;
00971  0024C9  20 99 2D      TCRLF   JSR CRLF        ; OUTPUT A CR FOLLOWED BY A LF
00972  0024CC  10 05                 BPL TASK4       ; UNCONDITIONAL BRANCH
00973  0024CE  A9 0D         TCR     LDA #$0D        ; 'CR' OUTPUT A CARRIAGE RETURN
00974  0024D0  20 02 29              JSR PRINTC      ;
00975  0024D3  20 92 29      TASK4   JSR GETC        ; SKIP OVER THIS CHARACTER
00976  0024D6  10 AC                 BPL TASK        ; UNCONDITIONALLY CONTINUE PROCESSING
00977                          ;
00978  0024D8  E6 20         TQUOT   INC DEBGSW      ; DISABLE TRACE SO LITERAL ONLY PRINTS ONCE
00979  0024DA  20 92 29      TQUOT1  JSR GETC        ; GET NEXT CHAR
00980  0024DD  C9 22                 CMP #$22        ; '"' CLOSING QUOTE?
00981  0024DF  F0 F2                 BEQ TASK4       ; BRANCH IF YES
00982  0024E1  C9 0D                 CMP #$0D        ; 'CR' END OF LINE?
00983  0024E3  F0 05                 BEQ TPC1        ; BRANCH IF YES (IT TERMINATES STRING)
00984  0024E5  20 02 29              JSR PRINTC      ; OTHERWISE, PRINT THE CHARACTER
00985  0024E8  10 F0                 BPL TQUOT1      ; UNCONDITIONALLY LOOP UNTIL DONE
00986  0024EA  A9 00         TPC1    LDA #$00        ; ENABLE TRACE JUST IN CASE
00987  0024EC  85 20                 STA DEBGSW      ;
00988  0024EE  4C 63 23      FPC1    JMP PC1         ; EXIT 'PROCESS'
00989  0024F1  4C FF 22      TPROC   JMP PROCES      ; CONTINUE PROCESSING ON THIS LINE
00990                          ;
00991          ; "FOR" LOOP ITERATION COMMAND
00992                          ;
00993  0024F4  20 1C 28      FOR     JSR PUSHJ       ; GO GET THE VARIABLE (mtb)
00994          .WORD GETVAR    ; ($2B51; $1B43 in ww -- mtb)
00995  0024F9  A5 2B                 LDA CHAR        ; GET TERMINATOR
00996  0024FB  C9 3D                 CMP #$3D        ; '=' SIGN?
00997  0024FD  F0 02                 BEQ FOR2        ; BRANCH IF YES
00998  0024FF  00                    BRK             ; NO, TRAP
00999          .BYTE NOEQLS    ; ?NO '=' IN 'FOR' OR 'SET' (#$F3)
01000  002501  A2 37         FOR2    LDX #VARADR     ; SAVE THE ADDRESS OF THE VARIABLE
01001  002503  A0 05                 LDY #$05        ;   AND ITS PROPERTIES
01002  002505  20 6B 28              JSR PUSHB0      ;   ON STACK
01003  002508  20 1C 28              JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE RIGHT HAND
01004          .WORD EVALM1    ;    SIDE OF '=' ($2A03; $19F5 in ww -- mtb)
01005  00250D  A2 3B                 LDX #VARADR+4   ; GET ADDR OF VARIABLE BACK AGAIN
01006  00250F  A0 05                 LDY #$05        ;
01007  002511  20 5B 28              JSR POPB0       ;
01008  002514  20 9B 2C              JSR BOMSTV      ; BOMB OUT IF LOOP COUNTER IS STR. VARIB.
01009  002517  20 A1 2C              JSR PUTVAR      ; NOT A STRING, SO STORE INITIAL VALUE
01010  00251A  A5 2B                 LDA CHAR        ; GET THE EXPRESSION TERMINATOR
01011  00251C  C9 2C                 CMP #$2C        ; ',' COMMA?
01012  00251E  F0 10                 BEQ FINCR       ; BRANCH IF IT'S A 'FOR' COMMAND
01013  002520  00            BTFOR   BRK             ; TRAP
01014          .BYTE FBDTRM    ; ?BAD TERMINATOR IN 'FOR' (#$F2)
01015                          ;
01016          ; "SET" COMMAND
01017                          ;
01018  ;SET1    JSR GETC        ; SKIP OVER COMMA (in ww -- mtb)
01019  002522  20 1C 28      SET     JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE EXPRESSION
01020          .WORD EVALM1    ; 'EVALM1' ($2A03; $19F5 was 'EVAL' $19F8 in ww -- mtb)
01021  002527  A5 2B                 LDA CHAR        ; GET TERMINATOR
01022  002529  C9 2C                 CMP #$2C        ; ',' COMMA?
01023  00252B  F0 F5                 BEQ SET         ; BRANCH IF YES, LOOP FOR ANOTHER EXPRESS (SET1 in ww -- mtb)
01024  00252D  4C 02 23              JMP PROC        ; NO. ALL DONE, CONTINUE ON THIS LINE
01025                          ;
01026  ; there is a handwritten note here: 'Best cmmd exit points $1304'
01027  ; ($2302 in this Aresco version code)
01028                          ;
01029                          ;
01030          ; 'FOR' COMMAND PROCESSING
01031                          ;
01032  002530  A2 37         FINCR   LDX #VARADR     ; SAVE THE ADDR OF THE LOOP VARIABLE ON STACK
01033  002532  20 69 28              JSR PUSHB2      ;
01034  002535  20 1C 28              JSR PUSHJ       ; GO GET THE INCREMENT
01035          .WORD EVALM1    ; ($2A03; $19F5 in ww -- mtb)
01036  00253A  A5 2B                 LDA CHAR        ; GET TERMINATOR
01037  00253C  C9 2C                 CMP #$2C        ; ',' DID WE GET AN INCREMENT?
01038  00253E  F0 16                 BEQ FLIMIT      ; YES, GO GET THE UPPER LIMIT OF LOOP
01039  002540  C9 3B                 CMP #$3B        ; ';' WAS NO INCREMENT SPECIFIED?
01040  002542  F0 06                 BEQ FINCR1      ; BRANCH IF NO INCREMENT GIVEN
01041  002544  C9 0D                 CMP #$0D        ; 'CR' CARRIAGE RETURN?
01042  002546  D0 D8                 BNE BTFOR       ; NO, THEN BAD TERMINATOR
01043  002548  00                    BRK             ; YES, TRAP
01044          .BYTE UFL       ; ?USELESS 'FOR' LOOP (#$F1)
01045  00254A  A2 FB         FINCR1  LDX #$FB        ; GET NEGATIVE OF NUMBER OF BYTES (-5)
01046  00254C  B5 A0         FI1C    LDA FONE+NUMBF,X ; GET NEXT BYTE
01047  00254E  20 31 28              JSR PUSHA       ; PUSH IT ON STACK
01048  002551  E8                    INX             ; POINT TO NEXT ONE
01049  002552  30 F8                 BMI FI1C        ;   AND LOOP UNTIL ALL PUSHED
01050  002554  10 08                 BPL FSHORT      ; UNCONDITIONAL BRANCH
01051  002556  20 79 28      FLIMIT  JSR PHFAC1      ; SAVE INCREMENT ON STACK
01052  002559  20 1C 28              JSR PUSHJ       ; NOW EVALUATE THE UPPER LIMIT
01053          .WORD EVALM1    ; ($2A03; $19F5 in ww -- mtb)
01054  00255E  20 79 28      FSHORT  JSR PHFAC1      ; SAVE UPPER LIMIT ON STACK AND ENTER LOOP
01055                          ;
01056          ; 'LOOP PROCESSOR FOR "FOR" COMMAND'
01057                          ;
01058  002561  20 0A 27      FCONT   JSR PUSHTP      ; NOW SAVE THE TEXT POINTERS ON STACK
01059  002564  A5 26                 LDA PC          ; SAVE PC ACROSS CALL
01060  002566  20 31 28              JSR PUSHA       ;
01061  002569  20 1C 28              JSR PUSHJ       ; NOW EXECUTE THE REST OF THE LINE
01062          .WORD PROCES    ; 'PROCES' ($22FF; $1301 in ww -- mtb)
01063  00256E  20 3F 28              JSR POPA        ; SET PC BACK
01064  002571  85 73                 STA ITEMP1      ; SAVE IT IN TEMPORARY
01065  002573  20 11 27              JSR POPTP       ; SAVE POINTERS FOR POSSIBLE RE-ENTRY
01066  002576  20 A5 28              JSR PLTMP       ; RESTORE UPPER LOOP LIMIT INTO TEMPORARY
01067  002579  20 C3 2C              JSR POPIV       ; RESTORE INCREMENT AND VARIABLE ADDR
01068  00257C  A5 26                 LDA PC          ; GET PC
01069  00257E  C9 FD                 CMP #RETCMD     ; WAS A 'RETURN' COMMAND JUST EXECUTED?
01070  002580  F0 22                 BEQ FORXIT      ; BRANCH IF YES, THEN EXIT THE LOOP NOW!
01071  002582  A5 7C                 LDA M2          ; GET THE SIGN OF THE INCREMENT (+ OR -)
01072  002584  08                    PHP             ; SAVE STATUS ON STACK FOR LATER
01073  002585  20 BB 2C              JSR PUSHIV      ; SAVE AGAIN FOR POSSIBLE REPEAT OF LOOP
01074  002588  20 AE 2C              JSR FETVAR      ; GO GET THE VARIABLE'S CURRENT VALUE
01075  00258B  20 79 32              JSR FADD        ; ADD THE INCREMENT TO FLAC
01076  00258E  20 A1 2C              JSR PUTVAR      ; STORE AS NEW LOOP COUNTER VALUE
01077  002591  20 8F 28              JSR PHTMP       ; SAVE TEMPORARY ON STACK
01078  002594  20 9A 28              JSR PLFAC2      ; PLACE INTO FAC2
01079  002597  20 73 32              JSR FSUB        ; SUBTRACT COUNTER FROM UPPER LIMIT (mtb)
01080  00259A  28                    PLP             ; GET SIGN OF THE INCREMENT
01081  00259B  30 0E                 BMI CNTDWN      ; BRANCH IF NEGATIVE, WE ARE COUNTING DOWN
01082  00259D  A5 81                 LDA FLCSGN      ; GET THE SIGN OF THE NUMBER
01083  00259F  10 10                 BPL MORFOR      ; BRANCH IF REPEAT NECESSARY
01084  0025A1  20 C3 2C      FOREND  JSR POPIV       ; CLEAN UP STACK
01085  0025A4  A5 73         FORXIT  LDA ITEMP1      ; RESTORE PC
01086  0025A6  85 26                 STA PC          ;   IN CASE 'RETURN' ENCOUNTERED
01087  0025A8  20 4B 28              JSR POPJ        ; EXIT 'FOR' COMMAND
01088  0025AB  A5 81         CNTDWN  LDA FLCSGN      ; ARE WE LESS THAN THE LOOP LIMIT?
01089  0025AD  F0 02                 BEQ MORFOR      ; NO, THEN KEEP GOING
01090  0025AF  10 F0                 BPL FOREND      ; YES, THEN THAT'S ALL
01091  0025B1  20 8F 28      MORFOR  JSR PHTMP       ; PLACE UPPER LIMIT BACK ON THE STACK
01092  0025B4  10 AB                 BPL FCONT       ; UNCONDITIOANALLY REPEAT LOOP
01093                          ;
01094          ; LINE NUMBER MANIPULATION ROUTINES
01095                          ;
01096          ; "GETLN" GET A LINE NUMBER FROM PROGRAM TEXT.
01097          ; RETURNS WITH V=1 IF "ALL" (00.00), OTHERWISE
01098          ; IT RETURNS WITH Z=1 IF GROUP NUMBER ONLY (GG.00)
01099          ; AND Z=0 IF INDIVIDUAL LINE NUMBER (GG.LL).
01100                          ;
01101  0025B6  20 27 34      GETLNC  JSR FINP        ; ONLY ALLOW NUMERIC INPUT
01102  0025B9  4C DF 25              JMP GETLN1      ;   AND ENTER REST OF CODE
01103                          ;
01104  0025BC  20 B4 29      GETLNS  JSR SPNOR       ; GET NEXT NON-BLANK
01105  0025BF  A9 00         GETLN   LDA #$00        ; ASSUME LINE NUMBER IS ZERO
01106  0025C1  85 2C                 STA GRPNO       ;
01107  0025C3  85 2D                 STA LINENO      ;
01108  0025C5  A5 2B                 LDA CHAR        ; GET FIRST CHARACTER OF EXPRESSION?
01109  0025C7  C9 2C                 CMP #$2C        ; ',' IS EXPRESSION NULL?
01110  0025C9  F0 3A                 BEQ GOTLNO      ; BRANCH IF YES, THEN WE HAVE THE NUMBER
01111  0025CB  C9 0D                 CMP #$0D        ; 'CR' ANOTHER FORM OF NULL?
01112  0025CD  F0 36                 BEQ GOTLNO      ; BRANCH IF YES, THEN WE HAVE THE NUMBER
01113  0025CF  20 BE 29              JSR TESTN       ; DOES EXPRESSION BEGIN WITH A NUMBER?
01114  0025D2  B0 06                 BCS GETLNX      ; BRANCH IF NOT, THEN MUST BE COMPLEX 
01115  0025D4  20 A3 2D              JSR GETILN      ; CALL INTEGER LINE NUMBER INPUT FOR SPEED
01116  0025D7  4C 05 26              JMP GOTLNO      ; WE NOW HAVE THE LINE NUMBER
01117  0025DA  20 1C 28      GETLNX  JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE EXPRESSION
01118          .WORD EVAL      ; ($2A06; $19F8 in ww -- mtb)
01119  0025DF  20 79 28      GETLN1  JSR PHFAC1      ; SAVE EXPRESSION VALUE ON STACK
01120  0025E2  20 16 26              JSR GETL        ; INTEGERIZE AND RANGE CHECK
01121  0025E5  85 2C                 STA GRPNO       ; SAVE AS GROUP NUMBER
01122  0025E7  20 39 32              JSR FLOAT       ; NOW FLOAT THE GROUP NUMBER
01123  0025EA  20 9A 28              JSR PLFAC2      ; POP FULL GG.SS INTO FAC2
01124  0025ED  20 73 32              JSR FSUB        ; SUBTRACT OFF THE GROUP NUMBER (mtb)
01125  0025F0  20 27 26              JSR GMUL10      ; MULTIPLY BY 100
01126  0025F3  20 27 26              JSR GMUL10      ;
01127  0025F6  A2 96                 LDX #FHALF      ; MOVE CONSTANT .50
01128  0025F8  A0 7B                 LDY #X2         ;
01129  0025FA  20 FF 33              JSR MOVXY       ;
01130  0025FD  20 79 32              JSR FADD        ; NOW ADD IN THE .50 FOR ROUNDING
01131  002600  20 16 26              JSR GETL        ; INTEGERIZE AND RANGE CHECK
01132  002603  85 2D                 STA LINENO      ; SAVE AS LINE NUMBER (STEP NUMBER)
01133  002605  B8            GOTLNO  CLV             ; ASSUME NOT 00.00
01134  002606  A5 2C                 LDA GRPNO       ; GET GROUP NUMBER
01135  002608  05 2D                 ORA LINENO      ; 'OR' IN THE LINE NUMBER
01136  00260A  F0 07                 BEQ GOTALL      ; BRANCH IF BOTH ARE ZERO
01137  00260C  A5 2C                 LDA GRPNO       ; GET GROUP NUMBER AGAIN
01138  00260E  F0 15                 BEQ BADLNO      ; BAD LINE NUMBER IS GROUP ONLY IS ZERO
01139  002610  A5 2D                 LDA LINENO      ; GROUP NUMBER OK, GET LINE (STEP) NO.
01140  002612  60            RTS3    RTS             ; RETURN WITH Z=1 IF GROUP ONLY
01141                          ;
01142  002613  24 6F         GOTALL  BIT BITV1       ; EXIT WITH V=1, (n=1 ??)
01143  002615  60                    RTS             ;
01144                          ;
01145          ; 'LINE NUMBER MANIPULATION ROUTINES'
01146                          ;
01147  002616  20 18 33      GETL    JSR FIX         ; FIX THE NUMBER IN FAC1
01148  002619  A5 81                 LDA M1          ; GET HIGH ORDERS
01149  00261B  05 82                 ORA M1+1        ; SMASH THEM TOGETHER
01150  00261D  D0 06                 BNE BADLNO      ; LINE NUMBER CAN ONLY BE POSITIVE
01151  00261F  A5 83                 LDA M1+2        ;
01152  002621  C9 64                 CMP #$64        ; AND < 100 ?
01153  002623  30 ED                 BMI RTS3        ;
01154  002625  00            BADLNO  BRK             ; TRAP
01155          .BYTE ILLNO     ; ILLEGAL LINE NUMBER (#$FC)
01156  002627  A2 91         GMUL10  LDX #FTEN       ; MOVE 10.0
01157  002629  A0 7B                 LDY #X2         ;   INTO FAC2
01158  00262B  20 FF 33              JSR MOVXY       ;
01159  00262E  4C A0 32              JMP FMUL        ; * PJMP *  FAC1*FAC2=FAC1
01160                          ;
01161          ; 'PRINTLN - PRINT A LINE NUMBER'
01162                          ; 
01163          ; "PRINTLN" PRINT A LINE NUMBER TO OUTPUT DEVICE
01164                          ; 
01165  002631  A4 2A         PRNTLN  LDY TEXTP       ; GET TEXT POINTER
01166  002633  B1 28                 LDA (TXTADR),Y  ; GET GROUP NUMBER
01167  002635  D0 05                 BNE PRNTL1      ; BRANCH IF NOT ZERO
01168  002637  C8                    INY             ; DO NOT PRINT GROUP ZERO LINE NUMBERS
01169  002638  C8                    INY             ;
01170  002639  84 2A                 STY TEXTP       ; POINT TO FIRST CHARACTER IN LINE
01171  00263B  60                    RTS             ;   AND RETURN
01172                          ;
01173  00263C  48            PRNTL1  PHA             ; SAVE THE GROUP NUMBER FOR LATER
01174  00263D  C8                    INY             ; POINT TO THE STEP NUMBER
01175  00263E  B1 28                 LDA (TXTADR),Y  ; GET STEP NUMBER
01176  002640  C8                    INY             ; MOVE PAST IT
01177  002641  84 2A                 STY TEXTP       ; SAVE POINTER
01178  002643  20 77 26              JSR PFLT        ; FLOAT THE STEP NUMBER
01179  002646  20 11 34              JSR DIV10       ; DIVIDE BY 100
01180  002649  20 11 34              JSR DIV10       ;
01181  00264C  20 79 28              JSR PHFAC1      ; SAVE 00.SS FOR LATER
01182  00264F  68                    PLA             ; GET THE GROUP NUMBER BACK
01183  002650  20 77 26              JSR PFLT        ; FLOAT IT
01184  002653  20 9A 28              JSR PLFAC2      ; RESTORE 00.SS INTO FAC2
01185  002656  20 79 32              JSR FADD        ; ADD TOGETHER TO FORM GG.SS
01186                          ; * PFALL * INTO OUTPUT ROUTINE
01187  002659  A9 02                 LDA #$02        ; ASSUME TWO DIGITS BEFORE THE DECIMAL PT.
01188  00265B  AA                    TAX             ;   AND TWO DIGITS AFTER
01189  00265C  D0 04                 BNE OUTLN       ; UNCONDITIONAL BRANCH
01190  00265E  A9 02         OUTLN0  LDA #$02        ; ASSUME TWO DIGITS BEFORE DECIMAL
01191  002660  A2 00         OUTLN1  LDX #$00        ; ASSUME NO DECIMAL POINT (mtb)
01192  002662  A8            OUTLN   TAY             ; SAVE NUMBER BEFORE DECIMAL IN Y REG
01193  002663  A5 8F                 LDA M           ; SAVE OLD FORMAT ON HARDWARE STACK (mtb)
01194  002665  48                    PHA             ; (COULD BE CALLED FROM ERROR TRAP)
01195  002666  A5 90                 LDA N           ;
01196  002668  48                    PHA             ;
01197  002669  84 8F                 STY M           ; STORE NEW FORMAT
01198  00266B  86 90                 STX N           ;
01199  00266D  20 1F 33              JSR FPRNT       ; PRINT NUMBER IN TEMPORARY FORMAT
01200  002670  68                    PLA             ; RESTORE OLD FORMAT
01201  002671  85 90                 STA N           ;
01202  002673  68                    PLA             ;
01203  002674  85 8F                 STA M           ;
01204  002676  60                    RTS             ; AND RETURN
01205                          ;
01206  002677  85 82         PFLT    STA M1+1        ; SAVE IN LOW ORDER
01207  002679  A9 00                 LDA #$00        ; MAKE HIGH ORDER ZERO
01208  00267B  85 81                 STA M1          ;
01209  00267D  4C 4D 32              JMP FLT16       ; * PJMP * AND FLOAT IT
01210                          ;
01211          ; 'FINDLN - FIND A LINE IN THE STORED PROGRAM'
01212                          ; 
01213          ; "FINDLN"  RETURNS WITH C=1 IF THE LINE WAS FOUND.
01214          ;           TXTAD2 POINTS TO THE GROUP NUMBER,
01215          ;           RETURNS WITH C=0 IF THE LINE WAS NOT LOCATED
01216          ;           TXTAD2 POINTS TO THE GROUP NUMBER OF THE NEXT HIGHEST NO.
01217          ;           (I.E., WHERE YOU WOULD INSERT THIS LINE)
01218                          ; 
01219  002680  A5 2C         FINDLN  LDA GRPNO       ; PLACE LINE NUMBER OF LINE WE ARE
01220  002682  85 5A                 STA ITMP2H      ;   LOOKING FOR INTO TEMPORARY
01221  002684  A5 2D                 LDA LINENO      ; STEP PART ALSO
01222  002686  85 59                 STA ITMP2L      ;
01223  002688  A9 00                 LDA #$00        ; SET FLAG INDICATING FIRST SEARCH
01224  00268A  85 3B                 STA FSWIT       ;
01225  00268C  85 2A                 STA TEXTP       ; ALSO RESET TEXT POINTER TO BEGINNING OF
01226  00268E  A5 26                 LDA PC          ;   CURRENT LINE. IS CURR LN DIRECT CMD?
01227  002690  10 05                 BPL CHKLIN      ; NO, THEN START SEARCHING FOR PRESENT POS
01228  002692  20 18 27      FNDINI  JSR TXTINI      ; YES, THEN RESET TEXT POINTERS TO START
01229  002695  E6 3B                 INC FSWIT       ;   OF PROGRAM, INDICATE LAST SEARCH
01230  002697  A4 2A         CHKLIN  LDY TEXTP       ; GET TEXT POINTER
01231  002699  B1 28                 LDA (TXTADR),Y  ; GET THE GROUP NUMBER
01232  00269B  C9 FE                 CMP #EOP        ; END OF TEXT?
01233  00269D  F0 23                 BEQ NOFIND      ; BRANCH IF YES
01234  00269F  85 56                 STA ITMP1H      ; SAVE FOR COMPARISON
01235  0026A1  85 51                 STA TGRP        ; ALSO SAVE IN CASE THIS ONE IS IT
01236  0026A3  C8                    INY             ; POINT TO STEP NUMBER
01237  0026A4  B1 28                 LDA (TXTADR),Y  ; GET IT
01238  0026A6  85 55                 STA ITMP1L      ; SAVE IT FOR COMPARISON
01239  0026A8  85 52                 STA TLINE       ; ALSO SAVE IN CASE THIS IS IT
01240  0026AA  C8                    INY             ; POINT TO FIRST CHAR IN LINE
01241  0026AB  84 2A                 STY TEXTP       ; UPDATE TEXT POINTER
01242  0026AD  38                    SEC             ; SET UP FOR SUBTRACT
01243  0026AE  A5 55                 LDA ITMP1L      ; GET LOW ORDER
01244  0026B0  E5 59                 SBC ITMP2L      ;
01245  0026B2  85 55                 STA ITMP1L      ; SAVE FOR LATER
01246  0026B4  A5 56                 LDA ITMP1H      ; NOW HIGH ORDERS
01247  0026B6  E5 5A                 SBC ITMP2H      ;
01248  0026B8  30 0E                 BMI FNEXT       ; BRANCH IF THE ONE IN THE TEXT AREA IS <
01249  0026BA  05 55                 ORA ITMP1L      ; NOT BIGGER, IS IT EQUAL?
01250  0026BC  F0 0F                 BEQ FOUNDL      ; BRANCH IF WE LOCATE THE LINE
01251  0026BE  A5 3B                 LDA FSWIT       ; LAST SEARCH ATTEMPT?
01252  0026C0  F0 D0                 BEQ FNDINI      ; BRANCH IF NOT, TRY AGAIN FROM START OF
01253                          ;   PROGRAM
01254  0026C2  18            NOFIND  CLC             ; FLAG THE FACT WE DIDN'T FIND IT
01255  0026C3  A0 00         FNEXIT  LDY #$00        ; RESET POINTER TO GROUP NUMBER
01256  0026C5  84 2A                 STY TEXTP       ;
01257  0026C7  60                    RTS             ;
01258  0026C8  20 D0 26      FNEXT   JSR EATCR       ; FLUSH TO START OF NEXT LINE
01259  0026CB  10 CA                 BPL CHKLIN      ; UNCONDITIONALLY LOOP FOR MORE
01260  0026CD  38            FOUNDL  SEC             ; FLAG THE FACT WE FOUND IT
01261  0026CE  B0 F3                 BCS FNEXIT      ;   AND RETURN
01262                          ;
01263          ; UTILITY ROUTINES FOR TEXT MANIPULATION
01264                          ;
01265          ; FLUSH UNTIL A CARRIAGE RETURN
01266                          ;
01267  0026D0  E6 20         EATCR   INC DEBGSW      ; DISABLE TRACE
01268  0026D2  20 92 29      EATCRC  JSR GETC        ; GET NEXT CHAR
01269  0026D5  10 02                 BPL EATCNT      ; UNCONDITIONAL BRANCH
01270  0026D7  E6 20         EATCR1  INC DEBGSW      ; DISABLE TRACE
01271  0026D9  A5 2B         EATCNT  LDA CHAR        ; GET THE CHAR
01272  0026DB  C9 0D                 CMP #$0D        ; 'CR' ?
01273  0026DD  D0 F3                 BNE EATCRC      ; BRANCH IF NOT
01274  0026DF  A5 28                 LDA TXTADR      ; YES, CALCULATE THE START OF NEXT LINE
01275  0026E1  18                    CLC             ;
01276  0026E2  65 2A                 ADC TEXTP       ; ADD IN THE TEXT POINTER
01277  0026E4  85 28                 STA TXTADR      ; SAVE IN POINTER
01278  0026E6  85 33                 STA TXTAD2      ;   AND ALTERNATE POINTER
01279  0026E8  A5 29                 LDA TXTADR+1    ; NOW HIGH ORDER
01280  0026EA  69 00                 ADC #$00        ;
01281  0026EC  85 29                 STA TXTADR+1    ;
01282  0026EE  85 34                 STA TXTAD2+1    ; AND ALTERNATE POINTER
01283  0026F0  A9 00                 LDA #$00        ; AND RESET THE POINTER
01284  0026F2  85 2A                 STA TEXTP       ;
01285  0026F4  85 35                 STA TEXTP2      ;
01286  0026F6  C6 20                 DEC DEBGSW      ; ALLOW TRACE AGAIN
01287  0026F8  60                    RTS             ;   AND RETURN
01288                          ;
01289          ; FLUSH UNTIL END OF COMMAND (SEMI-COLON OR CARRIAGE RETURN)
01290                          ;
01291  0026F9  20 92 29      EATEC1  JSR GETC        ; GET NEXT CHAR
01292  0026FC  10 02                 BPL EATECC      ; UNCONDITIONAL BRANCH
01293  0026FE  E6 20         EATECM  INC DEBGSW      ; TURN OFF TRACE
01294  002700  A5 2B         EATECC  LDA CHAR        ; GET THE CHAR
01295  002702  20 5A 23              JSR TSTEOC      ; GO SEE IF ';' OR CARRIAGE RETURN
01296  002705  D0 F2                 BNE EATEC1      ; BRANCH IF NOT
01297  002707  C6 20                 DEC DEBGSW      ; ENABLE TRACE AGAIN
01298  002709  60                    RTS             ;   AND RETURN
01299                          ;
01300          ; PUSH THE TEXT POINTERS ON THE STACK
01301                          ;
01302  00270A  A2 28         PUSHTP  LDX #TXTADR     ;
01303  00270C  A0 04                 LDY #$04        ; THREE PLUS 'CHAR'
01304  00270E  4C 6B 28              JMP PUSHB0      ; * PJMP *
01305                          ;
01306          ; POP THE TEXT POINTERS OFF THE STACK
01307                          ;
01308  002711  A2 2B         POPTP   LDX #TXTADR+3   ;
01309  002713  A0 04                 LDY #$04        ;
01310  002715  4C 5B 28              JMP POPB0       ; * PJMP *
01311                          ;
01312          ; INIT TEXT POINTER TO BEGINNING OF TEXT
01313                          ;
01314  002718  A5 2F         TXTINI  LDA TXTBEG      ; POINT TO START OF STORED TEXT
01315  00271A  85 28                 STA TXTADR      ;
01316  00271C  A5 30                 LDA TXTBEG+1    ;
01317  00271E  85 29                 STA TXTADR+1    ;
01318  002720  A9 00                 LDA #$00        ; INIT OFFSET TO ZERO
01319  002722  85 2A                 STA TEXTP       ;
01320  002724  60                    RTS             ;
01321                          ;
01322          ; 'NEWLIN' SETUP TEXT POINTERS AND PC FOR NEW LINE NUMBER
01323                          ;
01324  002725  A5 2C         NEWLIN  LDA GRPNO       ; GET THE LINE NUMBER
01325  002727  85 26                 STA PC          ; STORE IN THE PROGRAM COUNTER
01326  002729  A5 2D                 LDA LINENO      ;
01327  00272B  85 27                 STA PC+1        ;
01328  00272D  A0 02                 LDY #$02        ; POINT TO FIRST CHAR 0N LINE
01329  00272F  84 2A                 STY TEXTP       ;
01330  002731  60                    RTS             ; AND RETURN
01331                          ;
01332          ; 'NXTLIN' SETUP TEXT POINTERS AND PC FOR NEXT LINE NUMBER
01333                          ;
01334  002732  A4 2A         NXTLIN  LDY TEXTP       ; GET TEXT POINTER
01335  002734  B1 28                 LDA (TXTADR),Y  ; PICK UP GROUP NUMBER
01336  002736  C9 FE                 CMP #EOP        ; END OF PROGRAM?
01337  002738  F0 0F                 BEQ NONEXT      ; BRANCH IF NO NEXT LINE
01338  00273A  85 26                 STA PC          ; SAVE AS NEW LINE NUMBER
01339  00273C  C8                    INY             ;
01340  00273D  B1 28                 LDA (TXTADR),Y  ; GET STEP NUMBER
01341  00273F  85 27                 STA PC+1        ; STORE IT
01342  002741  C8                    INY             ; POINT TO FIRST CHAR ON THE LINE
01343  002742  84 2A                 STY TEXTP       ;
01344  002744  20 92 29              JSR GETC        ; GET THE FIRST CHAR OF NEW LINE
01345  002747  38                    SEC             ; FLAG THE FACT WE HAVE A NEW LINE
01346  002748  60                    RTS             ;   AND RETURN
01347  002749  18            NONEXT  CLC             ; INDICATE WE HAVE NO NEW LINE
01348  00274A  60                    RTS             ;   AND RETURN
01349                          ;
01350          ; 'DELETE' A LINE OF STORED PROGRAM
01351                          ;
01352  00274B  20 0A 27      DELETE  JSR PUSHTP      ; SAVE TEXT POINTERS
01353  00274E  A0 02                 LDY #$02        ; SKIP OVER LINE NUMBER
01354  002750  84 2A                 STY TEXTP       ;
01355  002752  20 D0 26              JSR EATCR       ; SKIP TO THE CARRIAGE RETURN
01356  002755  20 11 27              JSR POPTP       ; RESTORE POINTER TO START OF LINE TO ZAP
01357  002758  20 0A 27              JSR PUSHTP      ;   BUT KEEP THEM AROUND
01358  00275B  A0 00                 LDY #$00        ; SET OFFSET TO ZERO
01359  00275D  B1 33         DMVLOP  LDA (TXTAD2),Y  ; GET A CHAR
01360  00275F  91 28                 STA (TXTADR),Y  ; MOVE IT DOWN
01361  002761  C9 FE                 CMP #EOP        ; END OF TEXT REACHED YET?
01362  002763  F0 09                 BEQ DELDON      ; BRANCH IF YES
01363  002765  C8                    INY             ; NO, POINT TO NEXT CHAR TO MOVE
01364  002766  D0 F5                 BNE DMVLOP      ; BRANCH IF NO OVERFLOW ON OFFSET
01365  002768  E6 29                 INC TXTADR+1    ; OVERFLOW, BUMP HIGH ORDERS
01366  00276A  E6 34                 INC TXTAD2+1    ;
01367  00276C  D0 EF                 BNE DMVLOP      ; UNCONDITIONALLY MOVE NEXT BYTE
01368  00276E  C8            DELDON  INY             ;
01369  00276F  84 2A                 STY TEXTP       ; SAVE OFFSET
01370  002771  A5 28                 LDA TXTADR      ; GET BASE ADDR
01371  002773  18                    CLC             ;
01372  002774  65 2A                 ADC TEXTP       ; ADD IN THE OFFSET
01373  002776  85 3E                 STA VARBEG      ; SAVE AS START OF VARIABLE LIST
01374  002778  A5 29                 LDA TXTADR+1    ; GET HIGH ORDER
01375  00277A  69 00                 ADC #$00        ; ADD IN THE CARRY
01376  00277C  85 3F                 STA VARBEG+1    ; SAVE IT
01377  00277E  20 0D 28              JSR INSDON      ; FLAG VARIABLE LIST AS EMPTY
01378  002781  4C 11 27              JMP POPTP       ; * PJMP * RESTORE POINTERS TO POINT TO
01379                          ;   WHERE WE WOULD INSERT LINE.
01380                          ;
01381          ; 'INSERT' A LINE IN THE STORED PROGRAM TEXT AREA
01382                          ;
01383  002784  20 0A 27      INSERT  JSR PUSHTP      ; SAVE TEXT POINTERS ACROSS CALL
01384  002787  20 80 26              JSR FINDLN      ; TRY TO LOCATE THE LINE
01385  00278A  90 06                 BCC INSCNT      ; BRANCH IF LINE DOES NOT EXIST
01386  00278C  20 4B 27              JSR DELETE      ; LINE EXISTS, DELETE IT
01387  00278F  20 80 26              JSR FINDLN      ; RE-FIND TO SET UP POINTERS AGAIN
01388  002792  20 11 27      INSCNT  JSR POPTP       ; GET COMBUF POINTERS BACK
01389  002795  C6 2A                 DEC TEXTP       ; POINT TO THE LINE NUMBER DELIMITER
01390  002797  20 0A 27              JSR PUSHTP      ;   BUT KEEP THEM AROUND
01391  00279A  A2 33                 LDX #TXTAD2     ; SAVE POINTER TO PLACE TO INSERT
01392  00279C  A0 04                 LDY #$04        ;   ON STACK
01393  00279E  20 6B 28              JSR PUSHB0      ;
01394  0027A1  A2 02                 LDX #$02        ; SET COUNTER FOR 3 BYTES MINIMUM
01395  0027A3  E8            IFCR    INX             ; COUNT THIS BYTE
01396  0027A4  20 92 29              JSR GETC        ; GET IT FROM COMMAND BUFFER
01397  0027A7  C9 0D                 CMP #$0D        ; 'CR' ?
01398  0027A9  D0 F8                 BNE IFCR        ; NO, KEEP COUNTING
01399  0027AB  86 5F                 STX TEMP1       ; SAVE COUNTER TEMPORARILY
01400  0027AD  A0 00                 LDY #$00        ; OFFSET TO ZERO
01401  0027AF  B1 33                 LDA (TXTAD2),Y  ; GET THE LAST CHAR TO SLIDE DOWN
01402  0027B1  48                    PHA             ; SAVE FOR LATER
01403  0027B2  A9 FD                 LDA #UMARK      ; FLAG THE LOC WITH ALL ONES
01404  0027B4  91 33                 STA (TXTAD2),Y  ;
01405  0027B6  A5 3E                 LDA VARBEG      ; GET ADDR OF START OF VARIABLE LIST
01406  0027B8  85 28                 STA TXTADR      ; SAVE FOR LATER
01407  0027BA  18                    CLC             ;
01408  0027BB  65 5F                 ADC TEMP1       ; ADD IN AMOUNT TO MOVE DOWNWARD
01409  0027BD  85 33                 STA TXTAD2      ; SAVE FOR LATER
01410  0027BF  85 3E                 STA VARBEG      ; SAVE AS NEW START OF VARIABLE LIST
01411  0027C1  A5 3F                 LDA VARBEG+1    ; NOW HIGH ORDER
01412  0027C3  85 29                 STA TXTADR+1    ;
01413  0027C5  69 00                 ADC #$00        ;
01414  0027C7  85 34                 STA TXTAD2+1    ;
01415  0027C9  85 3F                 STA VARBEG+1    ; AND FALL INTO MOVE LOOP
01416  0027CB  B1 28         IMVLOP  LDA (TXTADR),Y  ; PICK UP A BYTE
01417  0027CD  C9 FD                 CMP #UMARK      ; END OF MOVE?
01418  0027CF  F0 0D                 BEQ IMVDON      ; BRANCH IF YES
01419  0027D1  91 33                 STA (TXTAD2),Y  ; NO, THEN SLIDE IT DOWN
01420  0027D3  88                    DEY             ; DECREMENT OFFSET?
01421  0027D4  C0 FF                 CPY #$FF        ; OVERFLOW?
01422  0027D6  D0 F3                 BNE IMVLOP      ; BRANCH IF NOT
01423  0027D8  C6 29                 DEC TXTADR+1    ; OVERFLOW, BUMP HIGH ORDER
01424  0027DA  C6 34                 DEC TXTAD2+1    ;   ADDRESSES
01425  0027DC  D0 ED                 BNE IMVLOP      ; UNCONDITIONALLY LOOP FOR MORE
01426  0027DE  68            IMVDON  PLA             ; GET THE LAST BYTE BACK AGAIN
01427  0027DF  91 33                 STA (TXTAD2),Y  ; STORE IT AWAY
01428  0027E1  20 11 27              JSR POPTP       ; RESTORE POINTERS TO PLACE TO INSERT
01429  0027E4  A2 36                 LDX #TXTAD2+3   ; RESTORE POINTERS TO COMBUF
01430  0027E6  A0 04                 LDY #$04        ;
01431  0027E8  20 5B 28              JSR POPB0       ;
01432  0027EB  A4 2A                 LDY TEXTP       ; GET OFFSET
01433  0027ED  A5 2C                 LDA GRPNO       ; GET THE GROUP NUMBER
01434  0027EF  91 28                 STA (TXTADR),Y  ; STRORE IT IN PROGRAM AREA
01435  0027F1  C8                    INY             ;
01436  0027F2  A5 2D                 LDA LINENO      ; GET THE STEP NUMBER
01437  0027F4  91 28                 STA (TXTADR),Y  ; STRORE IT IN PROGRAM AREA
01438  0027F6  C8                    INY             ; POINT TO WHERE FIRST CHARACTER GOES
01439  0027F7  84 2A                 STY TEXTP       ; SAVE IT FOR LATER
01440  0027F9  A4 35         INSLOP  LDY TEXTP2      ; GET POINTER TO CHAR
01441  0027FB  B1 33                 LDA (TXTAD2),Y  ; PICK IT UP
01442  0027FD  C8                    INY             ; BUMP IT
01443  0027FE  84 35                 STY TEXTP2      ; STORE IT BACK
01444  002800  A4 2A                 LDY TEXTP       ; POINT TO WHERE IT GOES
01445  002802  91 28                 STA (TXTADR),Y  ; PUT IT THERE
01446  002804  C9 0D                 CMP #$0D        ; CARRIAGE RETURN YET?
01447  002806  F0 05                 BEQ INSDON      ; BRANCH IF YES
01448  002808  C8                    INY             ; NO, POINT TO NEXT
01449  002809  84 2A                 STY TEXTP       ; SAVE POINTER
01450  00280B  D0 EC                 BNE INSLOP      ; UNCONDITIONALLY LOOP FOR MORE
01451  00280D  A0 00         INSDON  LDY #$00        ; OFFSET TO ZERO
01452  00280F  A9 FF                 LDA #EOV        ; FLAG VARIABLE LIST AS EMPTY
01453  002811  91 3E                 STA (VARBEG),Y  ;
01454  002813  A5 3E                 LDA VARBEG      ; AND UPDATE 'VAREND'
01455  002815  85 42                 STA VAREND      ;
01456  002817  A5 3F                 LDA VARBEG+1    ;
01457  002819  85 43                 STA VAREND+1    ;
01458  00281B  60                    RTS             ; AND RETURN
01459                          ;
01460  
01461  ; *** BEGIN AZIN67 SECTION (COMPLETED BY DAVE. H)
01462  
01463  ; 
01464  ; 
01465  ;           'SOFTWARE STACK MANIPULATION ROUTINES'
01466  ; 
01467  ; "PUSHJ" - PUSH-JUMP TO A ROUTINE
01468  ; 
01469  ; CALLING SEQUENCE IS:
01470  ; 
01471  ; JSR  PUSHJ	; CALL THIS SUBROUTINE
01472  ; .WORD ROUTINE	; TWO BYTE ADDR OF ROUTINE TO GO TO
01473  ;               ; *** NOTE! THIS WORD CANNOT OVERLAP
01474  ;               ; *** A PAGE BOUNDARY.
01475  ;        <----- ; RETURN IS HERE VIA "POPJ" ROUTINE
01476  ; 
01477  ; *** this routine has self-modifying code at $282F.
01478  ;     (I'm unsure how to write this in 'modern' assembly) --dhh
01479  ; 
01480  00281C  68            PUSHJ     PLA		; GET LOW ORDER RETURN ADDR FROM STACK
01481  00281D  A8                      TAY		; PLACE IN Y REGISTER
01482  00281E  C8                      INY		; INCREMENT TO GET LOW ORDER TO JUMP INDIR
01483  00281F  8C 2F 28                STY PJADR1	; STORE IN JUMP INDIRECT INSTRUCTION
01484  002822  C8                      INY		; BUMP FOR THE RTS IN "POPJ"
01485  002823  98                      TYA		; PLACE IN ACCUMULATOR
01486  002824  20 31 28                JSR PUSHA	; SAVE ON STACK FOR LATER
01487  002827  68                      PLA		; GET HIGH ORDER RETURN ADDR
01488  002828  8D 30 28                STA PJADR1+1	; STORE IN JUMP INDIRECT INSTRUCTION
01489  00282B  20 31 28                JSR PUSHA	; SAVE FOR LATER RETURN VIA "POPJ"
01490    282F              PJADR1 = * + 1
01491  00282E  6C 00 00                JMP ($0000)	; ADDR IS OVERWRITTEN FROM ABOVE CODE
01492              		; THIS JUMP WILL GO TO "ROUTINE".
01493  ; 
01494  ; "PUSHA" - PUSH THE ACCUMULATOR ON THE SOFTWARE STACK
01495  ; 
01496  ; CALLING SEQUENCE IS:
01497  ; JSR  PUSHA
01498  ; 
01499  002831  A4 4E         PUSHA     LDY PDP	; GET THE SOFTWARE STACK POINTER
01500  002833  91 4C                   STA (PDPADR),Y	; STORE THE ACC VIA POINTER
01501  002835  88                      DEY		; DECREMENT THE SOFT STACK POINTER
01502  002836  C0 FF                   CPY #$FF	; IS NEW VALUE $FF ?
01503  002838  D0 02                   BNE PUSHRT	; NO, THEN BASE ADDR IS OK
01504  00283A  C6 4D                   DEC PDPADR+1	; YES, DEC BASE ADDR BY ONE
01505  00283C  84 4E         PUSHRT    STY PDP	; STORE UPDATED POINTER
01506  00283E  60                      RTS		; AND RETURN
01507  ; 
01508  ; "POPA" - POP ITEM OFF SOFTWARE STACK INTO THE ACCUMULATOR
01509  ; 
01510  ; CALLING SEQUENCE IS:
01511  ; JSR  POPA
01512  ; 
01513  00283F  A4 4E         POPA      LDY PDP	; load software stack pointer
01514  002841  C8                      INY		; increment so it points to new item
01515  002842  D0 02                   BNE PHOK	; branch if high-order base addr is OK
01516  002844  E6 4D                   INC PDPADR+1	; if not OK, increment by one page
01517  002846  B1 4C         PHOK      LDA (PDPADR),Y	; get item from soft stack
01518  002848  84 4E                   STY PDP	; store updated pointer
01519  00284A  60                      RTS		; and return
01520  ; 
01521  ; "POPJ" - RETURN TO ADDRESS SAVED BY A CALL TO "PUSHJ"
01522  ; 
01523  ; CALLING SEQUENCE IS:
01524  ; JSR  POPJ
01525  ; 
01526  00284B  BA            POPJ      TSX		; load X w/ hw stack pointer
01527  00284C  20 3F 28                JSR POPA	; get hi order addr to ret to
01528  00284F  9D 02 01                STA STACK+2,X	; overwrite return addr
01529  002852  20 3F 28                JSR POPA	; get lo order byte to ret to
01530  002855  9D 01 01                STA STACK+1,X	; overwrite return addr
01531  002858  60                      RTS		; return to proper place, past
01532                          ;   JSR PUSHJ and .WORD routine
01533                          ; SEQUENCE --->
01534  ; 
01535  ; "POPB0"  pop bytes off of stack into zero page
01536  ; 
01537  002859  A0 02         POPB2     LDY #$02	; entry point when we need 2 bytes only
01538  00285B  84 5F         POPB0     STY TEMP1	; save Y register
01539  00285D  20 3F 28                JSR POPA	; get a byte from stack
01540  002860  95 00                   STA $00,X	; store it in zero page
01541  002862  A4 5F                   LDY TEMP1	; get Y register back
01542  002864  CA                      DEX		; count X down
01543  002865  88                      DEY		; done yet?
01544  002866  D0 F3                   BNE POPB0	; loop for more
01545  002868  60                      RTS		; yes, return
01546  ; 
01547  ; "PUSHB0"  push bytes from page zero onto stack   
01548  ; 
01549  002869  A0 02         PUSHB2    LDY #$02	; entry point, 2 bytes only
01550  00286B  84 5F         PUSHB0    STY TEMP1	; save Y
01551  00286D  B5 00                   LDA $00,X	; get value from Z Pg
01552  00286F  20 31 28                JSR PUSHA	; save on stack
01553  002872  A4 5F                   LDY TEMP1	; get Y back
01554  002874  E8                      INX		; next byte
01555  002875  88                      DEY		; done yet?
01556  002876  D0 F3                   BNE PUSHB0	; loop if >0
01557  002878  60                      RTS		; return
01558  ; 
01559  ; PUSH AND POP F.P. NUMBERS
01560  ; 
01561  ; PUSH FAC1 ONTO STACK
01562  ; 
01563  002879  A2 FB         PHFAC1    LDX #$FB	; get neg of num of bytes to push
01564  00287B  B5 85         PHF1B     LDA $85,X	; get a byte of number
01565  00287D  20 31 28                JSR PUSHA	; push onto software stack
01566  002880  E8                      INX		; point to next one
01567  002881  30 F8                   BMI PHF1B	; loop til all pushed
01568  002883  60                      RTS               
01569  ; 
01570  ; PUSH FAC2 ONTO STACK
01571  ; 
01572  002884  A2 FB         PHFAC2    LDX #$FB	; get neg of num of bytes to push
01573  002886  B5 80         PHF2B     LDA $80,X	; get a byte of number
01574  002888  20 31 28                JSR PUSHA	; etc
01575  00288B  E8                      INX
01576  00288C  30 F8                   BMI PHF2B
01577  00288E  60                      RTS
01578  ; 
01579  ; PUSH F.P. TEMP ONTO STACK
01580  ; 
01581  00288F  A2 FB         PHTMP     LDX #$FB	; get neg of num of bytes to push
01582  002891  B5 A5         PHTB      LDA $A5,X	; get a byte of number
01583  002893  20 31 28                JSR PUSHA	; etc
01584  002896  E8                      INX
01585  002897  30 F8                   BMI PHTB
01586  002899  60                      RTS
01587  ; 
01588  ; POP NUMBER ON STACK INTO FAC2
01589  ; 
01590  00289A  A2 04         PLFAC2    LDX #$04	; point to last byte
01591  00289C  20 3F 28      PLF2B     JSR POPA	; pop item from stack into ACC
01592  00289F  95 7B                   STA X2,X	; store into FAC2
01593  0028A1  CA                      DEX		; point to next byte
01594  0028A2  10 F8                   BPL PLF2B	; loop until all popped 
01595  0028A4  60                      RTS
01596  ; 
01597  ; POP NUMBER ON STACK INTO F.P. TEMP
01598  ; 
01599  0028A5  A2 04         PLTMP     LDX #$04	; point to last byte
01600  0028A7  20 3F 28      PLTB      JSR POPA	; get item from stack into ACC
01601  0028AA  95 A0                   STA $A0,X	; store in temp area
01602  0028AC  CA                      DEX		; point to next byte
01603  0028AD  10 F8                   BPL PLTB	; loop til done
01604  0028AF  60                      RTS
01605  ; 
01606  ;           'CHARACTER MANIPULATING ROUTINES'
01607  ; 
01608  ; READ ONE CHARACTER WITH NO ECHO
01609  ; 
01610  0028B0  A5 6B         RNOECH    LDA ECHFLG	; get echo ctrl flag
01611  0028B2  48                      PHA		; save on stack
01612  0028B3  A9 01                   LDA #$01	; no disable echo
01613  0028B5  85 6B                   STA ECHFLG
01614  0028B7  20 C0 28                JSR READC	; get a char from input device
01615  0028BA  AA                      TAX		; save char into X
01616  0028BB  68                      PLA		; get old echo flag value back
01617  0028BC  85 6B                   STA ECHFLG
01618  0028BE  8A                      TXA		; get the char input
01619  0028BF  60                      RTS
01620  ; 
01621  ; "READC" - READ ONE CHARACTER FROM INPUT DEVICE
01622  ; 
01623  0028C0  A6 66         READC     LDX IDEV	; GET CURRENT INPUT DEVICE NUMBER
01624  0028C2  10 03                   BPL READC1	; BRANCH IF DEVICE NUMBER IS POSITIVE
01625  0028C4  4C CB 30                JMP RSTRNG	; * PJMP * NEG, READ FROM STRING AND RET
01626  0028C7  BD AF 35      READC1    LDA IDSPH,X	; GET HIGH ORDER DISPATCH ADDRESS
01627  0028CA  85 60                   STA TEMP1+1	; STORE IT AWAY
01628  0028CC  BD B4 35                LDA IDSPL,X	; GET LOW ORDER
01629  0028CF  85 5F                   STA TEMP1	; STORE IT AWAY
01630  0028D1  20 5E 00                JSR JSRIND	;   AND CALL THE INPUT ROUTINE
01631  0028D4  90 05                   BCC READCC	; BRANCH IF NO ERRORS
01632  0028D6  20 15 20      IERRI     JSR CLRDEV	; RESET DEVICES ON AN I-O ERROR
01633  0028D9  00                      BRK		; TRAP
01634            .BYTE ERRI	; ?I-O ERROR ON INPUT DEVICE (#$E9)
01635  0028DB  85 2B         READCC    STA CHAR	; SAVE CHAR
01636  0028DD  C9 7F                   CMP #$7F	; here the Aresco code differs from the
01637  0028DF  F0 5F                   BEQ RTS1	; ProgExch/6502Grp original. Was only a
01638  0028E1  C9 5F                   CMP #$5F	; test for CR, but now testing for RUBOUT,
01639  0028E3  F0 5B                   BEQ RTS1	; LF and CXL LINE.
01640  0028E5  C9 0A                   CMP #$0A	;   --dhh
01641  0028E7  F0 57                   BEQ RTS1
01642  0028E9  A5 6B                   LDA ECHFLG	; ECHO FLAG
01643  0028EB  F0 03                   BEQ READCE
01644  0028ED  A5 2B         READCR    LDA CHAR	; GET CHAR BACK
01645  0028EF  60                      RTS
01646  
01647  0028F0  A5 2B         READCE    LDA CHAR	; this is also not in original ProgExch code...
01648  0028F2  20 02 29                JSR PRINTC
01649  0028F5  C9 0D                   CMP #$0D
01650  0028F7  D0 47                   BNE RTS1	; ... to here. Next line was label READCE
01651  0028F9  A9 0A                   LDA #$0A	; FOLLOW CARRIAGE RETS WITH A LINE FEED
01652  0028FB  20 02 29                JSR PRINTC	; PRINT IT
01653  0028FE  10 ED                   BPL READCR	; UNCONDITIONAL BRANCH
01654  ; 
01655  ; PRINTC - PRINT THE CHAR IN ACCUMULATOR OR 'CHAR'
01656  ; 
01657  002900  A9 20         PSPACE    LDA #$20	; OUTPUT A SPACE
01658  002902  29 FF         PRINTC    AND #$FF	; here we're testing for a null ($00),
01659  002904  D0 02                   BNE PRNTC	; otherwise, routine branches to the
01660  002906  A5 2B                   LDA CHAR	; original ProgExch 'PRINTC'
01661  002908  48            PRNTC     PHA		; SAVE THE CHAR IN THE AC
01662  002909  A6 67                   LDX ODEV	; GET CURRENT OUTPUT DEVICE NUMBER
01663  00290B  10 06                   BPL PUSEA1	; BRANCH IF DEVICE NUMBER IS POSITIVE
01664        
01665         ; ProgExch source has a 'patch' here (literally pasted on!)
01666         ; covering the next six bytes:
01667         ; LDY STOPNT   ; get pntr to next char
01668         ; JMP WSTRNG   ; *PJMP* write to string
01669         ; NOP            ; patch fill
01670  
01671  00290D  20 BE 30                JSR WSTRNG     
01672  002910  4C 29 29                JMP PRRET
01673  002913  BD B9 35      PUSEA1    LDA ODSPH,X	; GET HIGH ORDER ADDR OF OUTPUT ROUTINE
01674  002916  85 60                   STA TEMP1+1	; SAVE IT
01675  002918  BD BE 35                LDA ODSPL,X	; GET LOW ORDER ADDR OF OUTPUT ROUTINE
01676  00291B  85 5F                   STA TEMP1	; SAVE IT
01677  00291D  68                      PLA		; GET CHAR BACK
01678  00291E  48                      PHA		; BUT SAVE ACROSS CALL
01679  00291F  20 5E 00                JSR JSRIND	; CALL THE ROUTINE TO DO THE OUTPUT
01680  002922  90 05                   BCC PRRET	; BRANCH IF NO ERRORS
01681  002924  20 15 20      OERRO     JSR CLRDEV	; RESET I-O DEVICES IF ERROR
01682  002927  00                      BRK		; TRAP
01683            .BYTE ERRO	; ?I-O ERROR ON OUTPUT DEVICE (#$DE)
01684  002929  68            PRRET     PLA		; RESTORE THE CHARACTER
01685  00292A  60                      RTS		; AND RETURN
01686  ; 
01687  ; PACKC - PACK A CHAR INTO MEMORY
01688  ; 
01689  00292B  A5 2B         PACKC     LDA CHAR	; get character
01690  00292D  A4 2A         PACKC1    LDY TEXTP	; get text pointer
01691  00292F  C9 7F                   CMP #$7F	; rubout?
01692  002931  F0 10                   BEQ RUB1	; yes, branch
01693  002933  C9 5F                   CMP #LINCHR	; 'line delete' char?
01694  002935  F0 29                   BEQ RUBLIN	; yes, branch
01695  002937  91 28                   STA (TXTADR),Y     ; store char to memory
01696  002939  C8            PCKRUB    INY		; +1 text pointer
01697  00293A  C0 7F                   CPY #$7F	; over max line length?
01698  00293C  10 03                   BPL PBIG	; yes, branch
01699  00293E  84 2A         PCKRET    STY TEXTP	; save text pointer
01700  002940  60            RTS1      RTS		; and return
01701  002941  00            PBIG      BRK		; trap
01702            .BYTE LTL	; ?line too long
01703  ; 
01704  ; ROUTINE TO RUB OUT ONE CHARACTER
01705  ; 
01706  002943  C0 00         RUB1      CPY #$00	; anything to rubout?
01707  002945  F0 F7                   BEQ PCKRET	; nope, branch
01708  002947  A4 6B                   LDY ECHFLG	; has user enabled character echo?
01709  002949  D0 0E                   BNE RUB1CC	; branch if disabled
01710  00294B  A4 6C                   LDY DELSPL	; need special CRT rubout?          
01711  00294D  F0 05                   BEQ RUB1C	; branch if not
01712  00294F  20 7D 29                JSR EATTVC	; yes, eat the char          
01713  002952  10 05                   BPL RUB1CC	; uncond. branch
01714  002954  A9 5C         RUB1C     LDA #$5C	; echo sp char '\' for rubout
01715  002956  20 08 29                JSR PRNTC
01716  002959  A4 2A         RUB1CC    LDY TEXTP	; load Y with text pointer
01717  00295B  88                      DEY		; -1
01718  00295C  10 E0                   BPL PCKRET	; RET if positive
01719  00295E  30 D9                   BMI PCKRUB	; if past beginning, set to 0
01720  ; 
01721  ; ROUTINE TO RUB OUT THE ENTIRE LINE
01722  ; 
01723  ;	*** this routine is visibly patched in the ProgExch code; Aresco code
01724  ;	    below is different.  -dhh
01725  ;
01726  002960  C0 00         RUBLIN    CPY #$00	; anything to rubout?
01727  002962  F0 DA                   BEQ PCKRET	; branch if not
01728  002964  A4 6B                   LDY ECHFLG	; has user enabled char echo?
01729  002966  D0 11                   BNE RUBLR	; branch if disabled
01730  002968  A4 6C                   LDY DELSPL	; need special CRT rubout proc?
01731  00296A  F0 08                   BEQ RUBLC	; branch if not
01732  00296C  20 7D 29      RUBLCL    JSR EATTVC	; eat a char off CRT screen
01733  00296F  C6 2A                   DEC TEXTP	; zap it from buffer
01734  002971  D0 F9                   BNE RUBLCL	; loop til all zapped
01735  002973  60                      RTS     
01736  002974  A9 5F         RUBLC     LDA #$5F	; echo 'line del' character
01737  002976  20 08 29                JSR PRNTC
01738  002979  A0 00         RUBLR     LDY #$00	; reset text pointer
01739  00297B  F0 C1                   BEQ PCKRET	; and RET
01740  ; 
01741  ; EAT A CRT CHAR WITH BS-SPC-BS SEQUENCE
01742  ; 
01743  00297D  20 83 29      EATTVC    JSR BACKSP	; output a BS
01744  002980  20 00 29                JSR PSPACE	; followed by a space
01745  002983  A9 08         BACKSP    LDA #$08	; get BS char
01746  002985  4C 02 29                JMP PRINTC	; * PJMP * output it and return
01747  ; 
01748  ; 'GETC' GET A CHAR FROM MEMORY, ECHO IF TRACE ON
01749  ; 
01750  002988  A4 20         GETCX     LDY DEBGSW	; is trace disabled?
01751  00298A  D0 17                   BNE GETC1	; yes, don't look at flag
01752  00298C  A5 21                   LDA DMPSW	; flip state of the dump switch
01753  00298E  49 FF                   EOR #$FF
01754  002990  85 21                   STA DMPSW	; and store it back
01755  002992  A5 24         GETC      LDA INSW	; where do we get the char from?
01756  002994  F0 03                   BEQ GETCC	; from memory
01757  002996  4C C0 28                JMP READC	; * PJMP * go get from input dev
01758  002999  A4 2A         GETCC     LDY TEXTP	; get text pointer
01759  00299B  E6 2A                   INC TEXTP	; +1 to next char
01760  00299D  B1 28                   LDA (TXTADR),Y	; get it
01761  00299F  C9 3F                   CMP #$3F	; is it '?'
01762  0029A1  F0 E5                   BEQ GETCX	; yes, go handle
01763  0029A3  85 2B         GETC1     STA CHAR	; store away for others
01764  0029A5  A5 20                   LDA DEBGSW	; check to see if we print it
01765  0029A7  05 21                   ORA DMPSW	; for debugging
01766  0029A9  D0 03                   BNE GETRT1	; no
01767  0029AB  20 F0 28                JSR READCE	; print only if both are 0
01768  0029AE  A5 2B         GETRT1    LDA CHAR	; get char back
01769  0029B0  60                      RTS		; and RET
01770  ;
01771      ; the ProgramExchange/6502Group code has a 'patch'
01772      ; over GETC1:
01773      ; GETC1     STA CHAR     ; STORE IT
01774      ;           PHA          ; SAVE ON STACK
01775      ;           LDA DEBGSW     ; DO WE PRINT IT?
01776      ;           ORA DMPSW     ; FOR DEBUGGING
01777      ;           BNE TESTN+7     ; NO
01778      ;           PLA          ; GET CHAR BACK
01779      ;           JSR TRACBG     ; FIX FOR TRACE BUG
01780      ;           RTS          ; CHAR IS RETURNED
01781  ; 
01782  ; 'SPNOR' ROUTINE TO IGNORE LEADING SPACES
01783  ; 
01784  0029B1  20 92 29      GSPNOR    JSR GETC	; CALL GETC FIRST
01785  0029B4  A5 2B         SPNOR     LDA CHAR	; GET THE CHAR
01786  0029B6  C9 20                   CMP #$20	; IS IT A SPACE?
01787  0029B8  F0 F7                   BEQ GSPNOR	; YES, THEN IGNORE
01788  0029BA  60                      RTS		; NO, RETURN
01789  ; 
01790  ; "TESTN"  TESTS TO SEE IF CHARACTER IS A NUMBER
01791  ; 
01792  0029BB  20 B1 29      TESTNS    JSR GSPNOR	; GET NEXT NON-BLANK
01793  0029BE  A5 2B         TESTN     LDA CHAR	; GET CHAR
01794  0029C0  48            TESTN1    PHA		; SAVE CHAR ON STACK
01795  0029C1  49 30                   EOR #$30	; CONVERT TO BCD (IF A NUMBER)
01796  0029C3  C9 0A                   CMP #$0A	; SET C BIT IF GREATER THAN 9
01797  0029C5  68                      PLA		; RETORE CHARACTER TO ACCUMULATOR
01798  0029C6  60                      RTS		; RETURN (C BIT CLEAR IF NUMBER)
01799  ; 
01800  ;           'EVAL' - EXPRESSION EVALUATOR
01801  ; 
01802  ; 'EVAL' - EVALUATE AN EXPRESSION (RECURSIVE)
01803  ; 
01804  0029C7  A9 00         EFUN      LDA #$00	; GET A ZERO
01805  0029C9  0A            EFUNL     ASL		; ROTATE LEFT TO HASH
01806  0029CA  85 65                   STA ETEMP1	; SAVE IT
01807  0029CC  20 92 29                JSR GETC	; GET NEXT CHARACTER OF FUNCTION NAME
01808  0029CF  20 3E 2B                JSR TTERMS	; TERMINATOR?
01809  0029D2  F0 07                   BEQ EFNAME	; BRANCH IF END OF NAME
01810  0029D4  29 1F                   AND #$1F	; KEEP ONLY 5 BITS
01811  0029D6  18                      CLC
01812  0029D7  65 65                   ADC ETEMP1	; ADD IN THE HASH
01813  0029D9  D0 EE                   BNE EFUNL     ; UNCONDITIONALLY LOOP FOR MORE
01814  0029DB  C9 28         EFNAME    CMP #$28	; '(' LEFT PAREN?
01815  0029DD  F0 02                   BEQ EFUNC     ; BRANCH IF YES
01816  0029DF  00                      BRK		; TRAP
01817            .BYTE PFERR	; ?PARENTHESES ERROR IN FUNCTION
01818  0029E1  A5 65         EFUNC     LDA ETEMP1	; GET THE HASH CODE FOR FUNCTION NAME
01819  0029E3  20 31 28                JSR PUSHA     ; SAVE FOR LATER
01820  0029E6  20 1C 28                JSR PUSHJ     ; MOVE PAST PAREN, EVALUATE 1ST ARGUMENT
01821            .BYTE $3,$2A
01822  0029EB  20 3F 28                JSR POPA	; GET THE NAME BACK AGAIN
01823  0029EE  AA                      TAX		; TRANSFER TO X REGISTER
01824  0029EF  20 1C 28                JSR PUSHJ     ; AND GO DO THE FUNCTION
01825            .WORD	FUNC    ; SamCoVT - scan has EVALM1 but binary version
01826                          ; has FUNC here instead
01827  0029F4  4C CD 2A                JMP ERPAR     ; GO SEE IF TERMINATOR IS A RIGHT PAREN.
01828  ; 
01829  ; HERE FOR A QUOTED CONSTANT
01830  ; 
01831  0029F7  20 92 29      ECHAR     JSR GETC	; GET CHARACTER FOLLOWING QUOTE
01832  0029FA  20 41 32                JSR FLT8	; AND MAKE IT A FLOATING POINT NUMBER
01833  0029FD  20 92 29                JSR GETC	; MOVE PAST CHARACTER
01834  002A00  4C 83 2A                JMP OPNEXT	; AND CHECK FOR OPERATOR
01835  ; 
01836  ; *** MAIN ENTRY POINT(S) TO 'EVAL' ***
01837  ; 
01838  002A03  20 92 29      EVALM1    JSR GETC	; ENTER HERE TO GET PAST CURRENT CHARACTER
01839  002A06  A9 00         EVAL      LDA #$00	; ASSUME LOWEST LEVEL ARITHMETIC OPERATION
01840  002A08  85 75                   STA LASTOP
01841  002A0A  85 3B                   STA STRSWT	; MAKE SURE STRING VAR SWITCH IS OFF
01842  002A0C  20 CB 2C                JSR ZRFAC1	; ASSUME VALUE OF EXPRESSION IS ZERO
01843  002A0F  A5 75         ARGNXT    LDA LASTOP	; SAVE LAST OPERATION ON STACK
01844  002A11  20 31 28                JSR PUSHA
01845  002A14  20 3E 2B                JSR TTERMS	; GO SEE IF THIS CHARACTER IS A TERMINATOR
01846  002A17  D0 03                   BNE ECHKC	; BRANCH IF NOT
01847  002A19  4C C4 2A                JMP ETERM1	; YES, THEN HANDLE
01848  002A1C  C9 46         ECHKC     CMP #$46	; 'F' IS IT A FUNCTION?
01849  002A1E  F0 A7                   BEQ EFUN	; BRANCH IF YES
01850  002A20  C9 27                   CMP #$27	; ''' IS IT A CHARACTER CONSTANT?
01851  002A22  F0 D3                   BEQ ECHAR     ; BRANCH IF YES
01852  002A24  C9 2E                   CMP #$2E	; '.' IS IT A FRACTION?
01853  002A26  F0 1C                   BEQ ENUM	; BRANCH IF YES, CALL FLOATING P. ROUTINE
01854  002A28  20 C0 29                JSR TESTN1	; NO, BUT IS IT A NUMBER?
01855  002A2B  B0 28                   BCS EGTVAR	; BRANCH IF NOT A NUMBER
01856                ; *** START OF KLUDGE HACK
01857                ;     TO SPEED THINGS UP ***
01858  002A2D  A5 24                   LDA INSW	; ARE WE INPUTTING FROM INPUT DEVICE?
01859  002A2F  D0 13                   BNE ENUM	; BRANCH IF YES, CALL FLOAT PT ROUTINE
01860  002A31  A2 02                   LDX #$02	; NO, THEN WE CAN LOOK AHEAD TO SEE IF
01861  002A33  A4 2A                   LDY TEXTP     ;   CONSTANT IS IN RANGE 0-99
01862  002A35  B1 28         KLOOP     LDA (TXTADR),Y	; GET NEXT CHAR
01863  002A37  C8                      INY		; BUMP POINTER
01864  002A38  C9 2E                   CMP #$2E	; '.' DOES NUMBER HAVE A FRACTIONAL PART
01865  002A3A  F0 08                   BEQ ENUM	; BRANCH IF IT DOES, CALL F.P. ROUTINE
01866  002A3C  20 C0 29                JSR TESTN1	; IS THIS CHAR A DIGIT 0-9 ALSO?
01867  002A3F  B0 09                   BCS FSTNUM	; BRANCH IF NOT, THEN CALL FAST INPUT
01868  002A41  CA                      DEX		; CAN ONLY HAVE UP TO TWO DIGITS
01869  002A42  D0 F1                   BNE KLOOP     ; LOOK AT NEXT ONE
01870                          ; IF WE FALL OUT OF THE LOOP, WE HAVE TO
01871  002A44  20 27 34      ENUM      JSR FINP	;   CALL FLOAT PT. INPUT ROUTINE (SLOW!)
01872  002A47  4C 83 2A                JMP OPNEXT	; AND LOOP FOR OPERATOR
01873  002A4A  A5 2B         FSTNUM    LDA CHAR	; GET FIRST DIGIT OF NUMBER
01874  002A4C  20 C2 2D                JSR GETIN     ; CALL FAST INPUT ROUTINE FOR #S 0-99
01875  002A4F  20 41 32                JSR FLT8	; CALL FAST ONE-BYTE FLOAT ROUTINE
01876  002A52  4C 83 2A                JMP OPNEXT	;    AND LOOK FOR OPERATOR
01877  		; *** END OF KLUDGE HACK ***
01878  002A55  20 1C 28      EGTVAR    JSR PUSHJ     ; IT MUST BE A VARIABLE, GET VALUE
01879            .WORD GETVAR	; or .WORD GETVAR
01880  002A5A  A5 2B                   LDA CHAR	; GET CHARACTER THAT TERMINATED THE VARIB
01881  002A5C  C9 3D                   CMP #$3D	; '=' DOES HE WANT SUBSTITUTION?
01882  002A5E  D0 23                   BNE OPNEXT	; BRANCH IF NOT, JUST A TERM
01883  002A60  A2 37                   LDX #VARADR	; YES, THEN SAVE THE INFO ABOUT THIS VARIB
01884  002A62  A0 05                   LDY #$05
01885  002A64  20 6B 28                JSR PUSHB0	;   ONTO THE STACK
01886  002A67  20 1C 28                JSR PUSHJ     ; CALL OURSELVES TO EVAL THE EXPRESSION
01887            .WORD EVALM1	; or .WORD EVALM1
01888  002A6C  A2 3B                   LDX #VARADR+4	; RESTORE POINTERS TO VARIABLE
01889  002A6E  A0 05                   LDY #$05
01890  002A70  20 5B 28                JSR POPB0
01891  002A73  A5 3B                   LDA STRSWT	; WAS THE VARIABLE A STRING VARIABLE?
01892  002A75  D0 05                   BNE SETSTR	; BRANCH IF IT WAS
01893  002A77  20 A1 2C                JSR PUTVAR	; NO, THEN STORE EXPRESS VALUE AS VARIB'S
01894  002A7A  F0 07                   BEQ OPNEXT	;   VALUE - IS ALSO VALUE OF THIS TERM
01895  002A7C  20 93 2F      SETSTR    JSR INTGER	; KEEP ONLY 8 BITS FOR VALUE
01896  002A7F  A4 3A                   LDY VSUB+1	; POINT TO POSITION IN STRING
01897  002A81  91 37                   STA (VARADR),Y	; STORE IT INTO $, FALL INTO...
01898  002A83  20 3E 2B      OPNEXT    JSR TTERMS	; GO SEE IF NEXT NON-SPACE IS SPECIAL
01899  002A86  D0 04                   BNE MISOPR	; BRANCH IF NOT
01900  002A88  E0 06                   CPX #$06	; LEFT PAREN?
01901  002A8A  D0 08                   BNE OPNXT1	; NO, THAT'S GOOD AS WE CAN'T HAVE 1 HERE
01902  002A8C  00            MISOPR    BRK		; TRAP TO ERROR HANDLER
01903            .BYTE OPRMIS	; ?OPERATOR MISSING - EVAL
01904  002A8E  4C 0F 2A      JARGN     JMP ARGNXT	; BRANCH AID
01905  002A91  20 4B 28      EVALRT    JSR POPJ	; RETURN FROM CALL TO "EVAL"
01906  
01907  002A94  E0 07         OPNXT1    CPX #$07	; IS THIS A DELIMITER?
01908  002A96  30 02                   BMI OPNXT2	; BRANCH IF NOT
01909  002A98  A2 00                   LDX #$00	; YES, THEN THE OPERATION LEVEL IS LOWEST
01910  002A9A  20 3F 28      OPNXT2    JSR POPA	; GET LAST OPERATION LEVEL
01911  002A9D  85 5F                   STA TEMP1     ; SAVE IT FOR COMPARE
01912  002A9F  E4 5F                   CPX TEMP1     ; IS THIS OPER LVL < OR = TO LAST ONE?
01913  002AA1  30 02                   BMI DOBOP     ; BRANCH IF YES
01914  002AA3  D0 12                   BNE ESTACK	; BRANCH IF NO
01915  002AA5  09 00         DOBOP     ORA #$00	; TO RESET FLAGS AFTER CPX
01916  002AA7  85 75                   STA LASTOP	; YES, THEN GET THE LAST OPERATOR
01917  002AA9  F0 E6                   BEQ EVALRT	; IF LOWEST LEVEL, THEN WE ARE ALL DONE
01918  002AAB  8A                      TXA		; SAVE 'THISOP'
01919  002AAC  48                      PHA		; ON HARDWARE STACK
01920  002AAD  20 9A 28                JSR PLFAC2	; POP PARTIAL RESULT BACK INTO FAC2
01921  002AB0  20 E8 2A                JSR EVBOP     ; AND GO DO THE OPERATION LEAVING THE
01922  			;   RESULT IN FLAC
01923  002AB3  68                      PLA		; GET 'THISOP' BACK
01924  002AB4  AA                      TAX
01925  002AB5  10 E3                   BPL OPNXT2	; UNCOND. BRANCH WITH NEW PARTIAL RESULT.
01926  
01927  002AB7  20 31 28      ESTACK    JSR PUSHA	; SAVE BACK ON STACK FOR LATER COMPUTATION
01928  002ABA  86 75                   STX LASTOP	; NOW UPDATE 'LASTOP' TO 'THISOP'
01929  002ABC  20 79 28                JSR PHFAC1	; SAVE PARTIAL RESULT ON STACK
01930  002ABF  20 92 29                JSR GETC	; SKIP OVER THE OPERATOR
01931  002AC2  10 CA                   BPL JARGN	; UNCOND. BRANCH TO PICK UP NEXT ARGUMENT
01932  002AC4  E0 06         ETERM1    CPX #$06	; LEFT PAREN?
01933  002AC6  D0 12                   BNE ETERM2	; BRANCH IF NOT
01934  002AC8  20 1C 28                JSR PUSHJ	; ENTERING NEW LEVEL OF NESTING, SO CALL
01935            .WORD EVALM1	; OURSELVES TO EVALUATE IT!
01936  002ACD  A5 2B         ERPAR     LDA CHAR	; GET THE DELIMITER THAT ENDED THIS LEVEL
01937  002ACF  48                      PHA		; SAVE IT MOMENTARILY
01938  002AD0  20 92 29                JSR GETC	; MOVE PAST IT
01939  002AD3  68                      PLA		; GET DELIMITER BACK
01940  002AD4  C9 29                   CMP #$29	; ')' RIGHT PAREN?
01941  002AD6  F0 AB                   BEQ OPNEXT	; YES. GO PICK UP NEXT OPERATOR
01942  002AD8  00            EPMISS    BRK		; TRAP TO ERROR HANDLER
01943            .BYTE PMATCH	; ?PARENTHESIS MISMATCH - EVAL
01944  002ADA  E0 07         ETERM2    CPX #$07	; DELIMITER ON RIGHT-HAND SIDE?
01945  002ADC  10 04                   BPL ETERM3	; BRANCH IF YES
01946  002ADE  E0 03                   CPX #$03	; OR UNARY OPERATOR
01947  002AE0  10 04                   BPL MISOPN	; NO, THEN IT CAN'T BE HERE
01948  002AE2  A5 75         ETERM3    LDA LASTOP	; PICK UP OPERATION LEVEL
01949  002AE4  F0 AE                   BEQ OPNXT1	; ONLY ALLOW IF AT LOWEST LEVEL
01950  002AE6  00            MISOPN    BRK		; TRAP TO ERROR HANDLER
01951            .BYTE OPNMIS	; ?OPERAND MISSING - EVAL
01952  
01953  002AE8  A6 75         EVBOP     LDX LASTOP	; GET THE ARITHMETIC OPERATION TO PERFORM
01954  002AEA  BD 80 35                LDA EVDSPH,X	; GET THE HIGH-ORDER ADDR OF ROUTINE
01955  002AED  85 60                   STA TEMP1+1	; STORE IT
01956  002AEF  BD 85 35                LDA EVDSPL,X	; GET THE LOW-ORDER ADDR OF ROUTINE
01957  002AF2  85 5F                   STA TEMP1	; STORE IT
01958  002AF4  6C 5F 00                JMP ($005F)	; * PJMP * TO ROUTINE TO DO THE OPERATION
01959  ; 
01960  ; 
01961  ;           EVALUATE A POWER
01962  ; 
01963  ; *** NOTE: THIS ROUTINE IS CURRENTLY RESTRICTED TO RAISING
01964  ;           THE NUMBER TO AN INTEGER POWER WITHIN THE RANGE
01965  ;           OF + OR - 32,767          (label: EVPOWR)
01966  ; 
01967  002AF7  20 A7 2F      EVPOWR    JSR INTFIX	; GET EXPONENT
01968  002AFA  85 55                   STA ITMP1L	; STORE IT AWAY
01969  002AFC  A5 82                   LDA M1+1	; AS NUMBER OF TIMES TO DO OPERATION
01970  002AFE  85 56                   STA ITMP1H
01971  002B00  A2 9B                   LDX #FONE	; GET THE CONSTANT 1.0 INTO FAC1
01972  002B02  A0 80                   LDY #FAC1
01973  002B04  20 FF 33                JSR MOVXY
01974  002B07  A5 56                   LDA ITMP1H	; RAISING TO A NEGATIVE POWER?
01975  002B09  30 1A                   BMI NPOWR	; BRANCH IF WE ARE
01976  002B0B  A9 FF         POWRLP    LDA #$FF	; POSITIVE POWER, ARE WE DONE YET?
01977  002B0D  C6 55                   DEC ITMP1L
01978  002B0F  C5 55                   CMP ITMP1L
01979  002B11  D0 02                   BNE POWR1	; BRANCH IF HIGH ORDER OK
01980  002B13  C6 56                   DEC ITMP1H	; DECREMENT HIGH ORDER
01981  002B15  C5 56         POWR1     CMP ITMP1H	; DONE YET?
01982  002B17  F0 32                   BEQ TTRET	; YES, THEN RETURN
01983  002B19  20 84 28                JSR PHFAC2	; NO, SAVE FAC2
01984  002B1C  20 A0 32                JSR FMUL	; NUMBER TIMES ITSELF (EXCEPT FIRST TIME)
01985  002B1F  20 9A 28                JSR PLFAC2	; RESTORE NUMBER TO FAC2
01986  002B22  4C 0B 2B                JMP POWRLP	; AND KEEP MULTIPLYING
01987  ; 
01988  ; HERE IF RAISING TO A NEGATIVE POWER
01989  ; 
01990  002B25  A5 56         NPOWR     LDA ITMP1H	; DONE YET?
01991  002B27  F0 22                   BEQ TTRET     ; BRANCH IF ALL DONE
01992  002B29  E6 55                   INC ITMP1L	; NO, THEN COUNT UP SINCE COUNT IS NEG.
01993  002B2B  D0 02                   BNE NPOWR1
01994  002B2D  E6 56                   INC ITMP1H	; INCREMENT HIGH ORDER ALSO
01995  002B2F  20 29 32      NPOWR1    JSR SWAP	; PUT PARTIAL INTO FAC2, 'X' INTO FAC1
01996  002B32  20 79 28                JSR PHFAC1	; SAVE 'X'
01997  002B35  20 CA 32                JSR FDIV	; 1/(X*X*X*X...)
01998  002B38  20 9A 28                JSR PLFAC2	; RESTORE 'X'
01999  002B3B  4C 25 2B                JMP NPOWR     ; AND LOOP TILL DONE
02000  ; 
02001  ;           'ROUTINES USED BY "EVAL" '
02002  ; 
02003  ; TEST TO SEE IF CHARACTER IS A SPECIAL TERMINATOR
02004  ; 
02005  002B3E  20 B4 29      TTERMS    JSR SPNOR     ; IGNORE SPACES, GET NEXT NON-BLANK CHAR
02006  002B41  A2 0C                   LDX #$0C	; GET MAX TABLE OFFSET; 'trmax in ProgExch code'
02007  002B43  DD E8 34      TRMCHK    CMP TRMTAB,X	; MATCH?
02008  002B46  F0 03                   BEQ TTRET	; YES, RETURN WITH Z=1
02009  002B48  CA                      DEX		; POINT TO NEXT ENTRY
02010  002B49  10 F8                   BPL TRMCHK	; AND CHECK IT
02011  002B4B  60            TTRET     RTS		; RETURN (NOTE: Z=0 IF CANNOT FIND)
02012  ; 
02013  ;           'GETVAR' - GET A VARIABLE FROM VARIABLE LIST
02014  ; 
02015  ; "GETVAR" - GET A VARIABLE FROM THE VARIABLE LIST
02016  ;            OTHERWISE CREATE IT AND ASSIGN IT A VALUE OF ZERO
02017  ; 
02018  002B4C  4C D8 2A      GPMISS    JMP EPMISS	; BRANCH AID
02019  002B4F  00            GTERR3    BRK		; TRAP
02020            .BYTE FUNILL	; ?FUNCTION ILLEGAL HERE
02021  002B51  A9 00         GETVAR    LDA #$00	; ASSUME VARIABLE IS NOT A STRING
02022  002B53  85 3B                   STA STRSWT
02023  002B55  20 B4 29                JSR SPNOR	; (DEFENSIVE!) GET THE CHARACTER
02024  002B58  C9 26                   CMP #$26	; '&' IS IT SPECIAL 'FSBR' SCRATCH VARIB?
02025  002B5A  F0 0A                   BEQ VAROK	; YES, THEN NAME IS OK
02026  002B5C  C9 41                   CMP #$41	; 'A' IS IT ALPHABETIC?
02027  002B5E  30 04                   BMI VARBAD	; BRANCH IF NOT
02028  002B60  C9 5B                   CMP #$5B	; '[' Z+1
02029  002B62  30 02                   BMI VAROK     ; BRANCH IF ALPHABETIC
02030  002B64  00            VARBAD    BRK		; NOT ALPHABETIC
02031            .BYTE BADVAR	; ?BAD VARIABLE NAME
02032  002B66  C9 46         VAROK     CMP #$46	; 'F' FUNCTION?
02033  002B68  F0 E5                   BEQ GTERR3	; BRANCH IF YES
02034  002B6A  0A                      ASL 
02035  002B6B  0A                      ASL 
02036  002B6C  0A                      ASL 		; SHIFT ALPHA LEFT 3
02037  002B6D  48                      PHA		; SAVE IT
02038  002B6E  20 92 29                JSR GETC	; GET NEXT CHARACTER
02039  002B71  49 30                   EOR #$30	; CONVERT TO BCD IF A NUMBER
02040  002B73  C9 08                   CMP #$08	; IS IT 0-7?
02041  002B75  B0 09                   BCS VARDUN	; IF NOT, NAME IS ON STACK
02042  002B77  85 3D                   STA VCHAR	; IF YES, SAVE IT
02043  002B79  68                      PLA		; GET BACK ALPHA PART
02044  002B7A  05 3D                   ORA VCHAR	; PUT THE PARTS TOGETHER
02045  002B7C  48                      PHA		; AND STICK ON STACK
02046  002B7D  20 92 29                JSR GETC	; GET A NEW CHARACTER IN CHAR
02047  ; 
02048  ; 
02049  ; X X X X X X X X X X X X X X X X X X X X X X X X X X X
02050  ;
02051  ; *** here begins transcription work done by Nils Andreas (2023)
02052  ; 
02053  ; 
02054  
02055  
02056  002B80  A5 2B         VARDUN    LDA CHAR
02057  002B82  C9 24                   CMP #$24	; '$' STRING VARIABLE?
02058  002B84  D0 05                   BNE VARDN1	;BRANCH IF NOT, PRESS ON
02059  002B86  85 3B                   STA STRSWT	;YES, FLAG THE FACT
02060  002B88  20 92 29                JSR GETC	;AND MOVE TO THE '3'
02061  002B8B  68            VARDN1    PLA		;GET VARIABLE OFF STACK
02062  002B8C  20 31 28                JSR PUSHA	;PUT NAME ON SOFT STACK
02063  002B8F  20 B4 29                JSR SPNOR	;GET NEXT NON-BLANK
02064  002B92  C9 28                   CMP #$28	; '(' LEFT PAREN?
02065  002B94  F0 06                   BEQ VARSUB	;BRANCH IF VARIABLE HAS A SUBSCRIPT
02066  002B96  A9 00                   LDA #$00	;OTHERWISE ASSUME 0
02067  002B98  85 3A                   STA VSUB+1	;ZERO THE SUBSCRIPT
02068  002B9A  F0 21                   BEQ VARSOK	;AND PROCESS IT
02069  002B9C  A5 3B         VARSUB    LDA STRSWT	;SAVE STRING FLAG
02070  002B9E  20 31 28                JSR PUSHA
02071  002BA1  20 1C 28                JSR PUSHJ	;CALL EAVL TO CALCULATE SUBSCRIPT
02072            .WORD EVALM1          
02073  002BA6  20 3F 28                JSR POPA	;RESTORE STRING FLAG
02074  002BA9  85 3B                   STA STRSWT
02075  002BAB  A5 2B                   LDA CHAR	;GET TERMINATOR
02076  002BAD  C9 29                   CMP #$29	; ')' PAREN MATCH?
02077  002BAF  D0 9B                   BNE GPMISS	;BRANCH IF NOT
02078  002BB1  20 92 29                JSR GETC	;MOVE PAST THE RIGHT PAREN (TYPO?)
02079  002BB4  20 18 33                JSR FIX	;MAKE SUBSCRIPT AN INTEGER
02080  002BB7  A5 83                   LDA X1+3	;GET LOW ORDER BYTE
02081  002BB9  85 3A                   STA VSUB+1	;STORE IT
02082  002BBB  A5 82                   LDA X1+2	;GET HIGH ORDER BYYTE (NOTE:16 BIT)
02083  002BBD  85 39         VARSOK    STA VSUB	;SAVE FOR LATER
02084  002BBF  20 3F 28                JSR POPA	;GET THE VARIABLE NAME BACK
02085  002BC2  85 3D                   STA VCHAR	;SAVE IT
02086  002BC4  20 76 2C      FNDVAR    JSR VARINI	;SET ADDR TO START OF VARIABLE LIST
02087  002BC7  A0 00         CHKVAR    LDY #$00	;SET OFFSET TO ZERO
02088  002BC9  B1 37                   LDA(VARADR),Y	;GET THE VARIABLE NAME
02089  002BCB  C9 FF                   CMP #EOV	;IS THIS THE END OF THE VARIABLE LIST?     
02090  002BCD  F0 57                   BEQ NOVAR	;BRANCH IF END OF LIST
02091  002BCF  C9 FC                   CMP #STRMRK	;IS THIS VARIABLE IN THE LIST A STRING VARIABLE?
02092  002BD1  F0 09                   BEQ CHKSTR	;BRANCH IF YES, WE HANDLE DIFFERENTLY
02093  002BD3  C5 3D                   CMP VCHAR	;ARE THE NAMES THE SAME
02094  002BD5  F0 37                   BEQ CHKSUB	;YES, GO SEE IF THE SUBSCRIPTS ARE EQUAL
02095  002BD7  20 7F 2C      NOTVAR    JSR NXTVAR	;POINT TO NEXT VARIABLE IN LIST
02096  002BDA  D0 EB                   BNE CHKVAR	;UNCONDITIONAL BRANCH TO CHECK NEXT VARIABLE
02097  002BDC  A5 3B         CHKSTR    LDA STRSWT	;ARE WE LOOKING FOR A STRING VARIABLE?
02098  002BDE  F0 1E                   BEQ SKPSTR	;BRANCH IF NOT, JUST SKIP OVER THIS STRING VARIB
02099  002BE0  A5 3D                   LDA VCHAR	;YES, THEN GET IT'S NAME
02100  002BE2  C8                      INY		;POINT TO NAME OF STRING VARIABLE IN VAR LIST 
02101  002BE3  D1 37                   CMP(VARADR),Y	;IS THIS THE ONE WE ARE LOOKING FOR?
02102  002BE5  D0 18                   BNE SKPST1	;BRANCH IF NOT, JUST SKIP IT OVER
02103  002BE7  C8                      INY		;YES, THIS IS THE ONE, GET THE SIZE OF THE
02104  002BE8  B1 37                   LDA(VARADR),Y	;STRING
02105  002BEA  85 3C                   STA VSIZE	;STORE FOR THOSE WHO NEED IT
02106  002BEC  C8                      INY		;AND UPDATE
02107  002BED  98                      TYA
02108  002BEE  20 81 2C                JSR UPDVAR	;'VARADR' TO POINT TO BASE ADDR OF STRING
02109  002BF1  A4 3A         GETSTC    LDY VSUB+1	;GET SUBSCRIPT (POSITION) OF BYTE WE WANT
02110  002BF3  B1 37                   LDA(VARADR),Y	;GET THE BYTE WE WANT
02111  002BF5  85 82                   STA M1+1	;STORE AS LOW ORDER 8 BITS
02112  002BF7  A9 00                   LDA #$00
02113  002BF9  85 81                   STA M1	;ZERO HIGH ORDER
02114  002BFB  4C E3 2E                JMP FL16PJ	;*PJMP* FLOAT AND RETURN THE VALUE
02115  002BFE  C8            SKPSTR    INY		;MOVE OVER STRING VARIABLE'S NAME
02116  002BFF  C8            SKPST1    INY		;POINT TO STRING VARIABLE'S LENGTH
02117  002C00  B1 37                   LDA(VARADR),Y	;GET THE STRING LENGTH
02118  002C02  48                      PHA		;SAVE IT
02119  002C03  C8                      INY		;POINT TO FIRST BYTE IN STRING
02120  002C04  98                      TYA		;UPDATE 'VARADR' TO BASE OF STRING
02121  002C05  20 81 2C                JSR UPDVAR               
02122  002C08  68                      PLA		;GET SIZE OF STRING
02123  002C09  20 81 2C                JSR UPDVAR	;UPDATE 'VARADR' BY PROPER AMOUNT
02124  002C0C  D0 B9                   BNE CHKVAR	;AND LOOK FOR NEXT VARIABLE IN LIST
02125  002C0E  A5 3B         CHKSUB    LDA STRSWT	;ARE WE LOOKING FOR A STRING VARIABLE
02126  002C10  D0 C5                   BNE NOTVAR	;BRANCH IF WE ARE, CAN'T BE THIS NUMERIC VARIABLE
02127  002C12  A5 39                   LDA VSUB	;GET HIGH ORDER SUBSCRIPT WE ARE LOOKING FOR
02128  002C14  C8                      INY		;POINT TO SUBSCRIPT IN LIST
02129  002C15  D1 37                   CMP(VARADR),Y	;ARE THEY THE SAME?     
02130  002C17  D0 BE                   BNE NOTVAR	;BRANCH IF THIS ONE IS NOT IT
02131  002C19  A5 3A                   LDA VSUB+1	;ARE LOW ORDERS ALSO THE SAME?
02132  002C1B  C8                      INY
02133  002C1C  D1 37                   CMP(VARADR),Y          
02134  002C1E  D0 B7                   BNE NOTVAR	;BRANCH IF THEY ARE NOT THE SAME
02135  002C20  20 AE 2C      LOCVAR    JSR FETVAR	;GET THE VARIABLE'S VALUE INTO FLAC
02136  002C23  20 4B 28                JSR POPJ	;AND RETURN TO CALLER 
02137  002C26  A5 3B         NOVAR     LDA STRSWT	;IS THIS STRING A VARIABLE 
02138  002C28  D0 21                   BNE NOSTR	;BRANCH IF IT IS A STRING VARIABLE 
02139  002C2A  A5 3D                   LDA VCHAR	;GET THE VARIABLE'S NAME 
02140  002C2C  91 37                   STA (VARADR),Y	;STORE IT IN LIST
02141  002C2E  C8                      INY		;POINT TO NEXT IN LIST
02142  002C2F  A5 39                   LDA VSUB	;GET HIGH ORDER SUBSCRIPT
02143  002C31  91 37                   STA (VARADR),Y	;SAVE IT IN LIST
02144  002C33  C8                      INY		;POINT TO NEXT
02145  002C34  A5 3A                   LDA VSUB+1	;GET LOW ORDER SUBSCRIPT
02146  002C36  91 37                   STA (VARADR),Y	;SAVE IT IN LIST
02147  002C38  A9 00                   LDA #$00	;GET A ZERO
02148  002C3A  A2 06                   LDX #NUMBF+1	;GET COUNT OF NUMBER OF BYTES IN NUMBER
02149  002C3C  C8            ZERVAR    INY		;POINT TO THE NEXT VARIABLE
02150  002C3D  91 37                   STA (VARADR),Y	;ZERO OUT VARIABLES VALUE
02151  002C3F  CA                      DEX		;COUNT THIS BYTE
02152  002C40  D0 FA                   BNE ZERVAR	;LOOP TILL DONE. NOTE: EXTRA ZERO AT END
02153  002C42  A9 FF                   LDA #EOV	;FLAG END OF VARIABLE LIST
02154  002C44  91 37                   STA (VARADR),Y	;FLAG END OF VARIABLE LIST
02155  002C46  20 8D 2C                JSR UPDEND	;UPDATE THE END OF THE VARIABLE LIST
02156  002C49  D0 D5                   BNE LOCVAR	;UNCONDITIONAL BRANCH, AS WE HAVE FOUND
02157  			;THE VARIABLE
02158  
02159  ; *** BEGIN GAVIN D. SECTION
02160  
02161  ;
02162  ; 
02163  ;  HERE WHEN STRING VARIABLE WAS NOT FOUND
02164  ; 
02165  
02166  002C4B  A9 FC         NOSTR     LDA #STRMRK	;ADD A STRING MARKER AT THE END OF VARIABLE LIST
02167  002C4D  91 37                   STA (VARADR),Y
02168  002C4F  C8                      INY
02169  002C50  A5 3D                   LDA VCHAR	;ADD IT'S NAME
02170  002C52  91 37                   STA (VARADR),Y
02171  002C54  C8                      INY
02172  002C55  A5 64                   LDA STRSIZ	;GET DEFAULT STRING SIZE
02173  002C57  91 37                   STA (VARADR),Y	;STORE AS SIZE OF STRING
02174  002C59  85 3C                   STA VSIZE	;ALSO STORE FOR OTHERS WHO NEED TO KNO
02175  002C5B  C8                      INY		;POINT TO FIRST BYTE OF STRING
02176  002C5C  98                      TYA		;UPDATE 'VARADR'
02177  002C5D  20 81 2C                JSR UPDVAR
02178  002C60  A0 00                   LDY #$00	;POINT TO FIRST BYTE OF STRING
02179  002C62  A9 20                   LDA #$20	;GET A BLANK
02180  002C64  91 37         STRINI    STA (VARADR),Y	;SET STRING TO ALL BLANKS
02181  002C66  C8                      INY
02182  002C67  C4 64                   CPY STRSIZ	;DONE YET?
02183  002C69  D0 F9                   BNE STRINI	;NO, LOOP TILL STRING IS ALL BLANKS
02184  002C6B  A9 FF                   LDA #EOV	;GET THE END OF VARIABLE LIST MARKER
02185  002C6D  91 37                   STA (VARADR),Y	;FLAG END OF LIST
02186  002C6F  98                      TYA		;UPDATE 'VARADR'
02187  002C70  20 8F 2C                JSR UBDENV
02188  002C73  4C F1 2B                JMP GETSTC	;GET BYTE FROM STRING AND RETURN
02189  002C76  A5 3E         VARINI    LDA VARBEG	;GET ADDR OF START OF VARIABLE LIST
02190  002C78  85 37                   STA VARADR	;AND SET POINTER
02191  002C7A  A5 3F                   LDA VARBEG+1
02192  002C7C  85 38                   STA VARADR+1
02193  002C7E  60                      RTS		;AND RETURN
02194  
02195  002C7F  A9 08         NXTVAR    LDA #VARSIZ	;ADD IN SIZE OF NUMERIC VARIABLE
02196  002C81  18            UPDVAR    CLC		;SETUP FOR ADDITION
02197  002C82  65 37                   ADC VARADR	;TO 'VARADR'
02198  002C84  85 37                   STA VARADR
02199  002C86  A5 38                   LDA VARADR+1
02200  002C88  69 00                   ADC #$00
02201  002C8A  85 38                   STA VARADR+1
02202  002C8C  60                      RTS
02203  ;
02204  ; ROUTINE TO UPDATE THE END OF THE VARIABLE LIST
02205  ;
02206  002C8D  A9 08         UPDEND    LDA #VARSIZ	;ADD SIZE OF NUMERIC VARIABLE
02207  002C8F  18            UBDENV    CLC
02208  002C90  65 37                   ADC VARADR	;ADD NUMBER IN ACCUMULATOR 'VARADR'
02209  002C92  85 42                   STA VAREND	;AND STORE RESULT IN 'VAREND'
02210  002C94  A5 38                   LDA VARADR+1
02211  002C96  69 00                   ADC #$00	;ADD IN THE CARRY
02212  002C98  85 43                   STA VAREND+1
02213  002C9A  60            BOMSVR    RTS		;AND RETURN
02214  ;
02215  ;ROUTINE TO BOMB OUT IF THE VARIABLE IS A STRING VARIABLE
02216  ;
02217  002C9B  A5 3B         BOMSTV    LDA STRSWT	;GET A STRING FLAG
02218  002C9D  F0 FB                   BEQ BOMSVR	;RETURN IF NOT A STRING
02219  002C9F  00                      BRK		;TRAP
02220            .BYTE SVNA	;?STRING VARIABLE NOT ALLOWED HERE 
02221  ;
02222  ;          'VARIABLE MANIPULATION UTILITIES
02223  ;
02224  ;"PUTVAR" PUT NUMBER IN FAC1 INTO THE VARIABLE
02225  ;
02226  002CA1  A0 03         PUTVAR    LDY #$03	;POINT TO START OF VALUE
02227  002CA3  B9 7D 00      PUTV1     LDA X1-3,Y	;GET A BYTE FROM FAC1
02228  002CA6  91 37                   STA (VARADR),Y	;STORE IT INTO VARIABLE
02229  002CA8  C8                      INY		;POINT TO NEXT BYTE
02230  002CA9  C0 08                   CPY #VARSIZ	;REACHED END OF VARIABLE YET?          
02231  002CAB  D0 F6                   BNE PUTV1	;NO, THEN MOVE SOME MORE
02232  002CAD  60                      RTS		;*** MUST RETURN WITH Z BIT = ! ! ***
02233  
02234  ; "FETVAR" FETCH VARIABLE VALUE INTO FAC1
02235  
02236  002CAE  A0 03         FETVAR    LDY #$03	;POINT TO START OF VALUE
02237  002CB0  B1 37         FETV1     LDA (VARADR),Y	;GET A BYTE FROM VARIABLE
02238  002CB2  99 7D 00                STA X1-3,Y	;PUT IT INTO FAC1
02239  002CB5  C8                      INY		;POINT TO NEXT BATE
02240  002CB6  C0 08                   CPY #VARSIZ	;REACHED THE END OF VARIABLE YET?
02241  002CB8  D0 F6                   BNE FETV1	;NO, THEN MOVE ANOTHER BYTE
02242  002CBA  60                      RTS		;YES, RETURN
02243  
02244  ;"PUSHIV" PUSH INCREMENT AND VARIABLE ADDR ON STACK USED BY "FOR" COMMAND
02245  
02246  002CBB  A2 37         PUSHIV    LDX #VARADR	;POINT TO VARIABLE ADDR
02247  002CBD  20 69 28                JSR PUSHB2	;PUSH IT INTO STACK
02248  002CC0  4C 84 28                JMP PHFAC2	;* PJMP * PUSH FAC2 INTO STACK AND RETURN
02249  
02250  ;"POPIV" POP INCREMENT AND VARIABLE ADDR OFF STACK
02251  
02252  002CC3  20 9A 28      POPIV     JSR PLFAC2	;RESTORE INTO FAC2
02253  002CC6  A2 38                   LDX #VARADR+1	;POINT TO VARIABLE ADDR
02254  002CC8  4C 59 28                JMP POPB2	;* PJMP * RESTORE INTO VARIABLE ADDR AND RETURN
02255  
02256  ;ZERO THE FLOATING POINT ACCUMULATOR FACE1
02257  
02258  002CCB  A2 04         ZRFAC1    LDX #NUMBF-1	;POINT TO LAST BYTE
02259  002CCD  A9 00                   LDA #$00	;LOAD A ZERO
02260  002CCF  95 80         ZRFAC     STA X1,X	;ZERO THE BYTE
02261  002CD1  CA                      DEX		;POINT TO NEXT ONE
02262  002CD2  D0 FB                   BNE ZRFAC	;LOOP TILL ALL OF MANTISSA ZEROED
02263  002CD4  A9 80                   LDA #$80	;NOW SET EXPONENT
02264  002CD6  85 80                   STA X1
02265  002CD8  60                      RTS		;AND RETURN
02266  ;
02267  ;          'INTERRUPT HANDLERS'
02268  ;
02269  002CD9  48            NOTBRK    PHA		;SAVE THE PROCESSOR STATUS          
02270  002CDA  A9 ED                   LDA #UNKINT	;UNKNOWN INTERRUPT
02271  002CDC  48                      PHA		;SAVE CODE ON STACK
02272  002CDD  D0 22                   BNE BERROR	;AND PRINT ERROR CODE
02273  002CDF  EA            NMISRV    NOP		;CURRENTLY PUNT NMI'S AS UNKNOWNS
02274  002CE0  85 71         INTSRV    STA ACSAV	;SAVE ACCUMULATOR
02275  002CE2  68                      PLA		;GET THE PROCESSOR STATUS
02276  002CE3  24 70                   BIT MSKBRK	;IS B BIT ON?
02277  002CE5  F0 F2                   BEQ NOTBRK	;BRANCH TO INTERRUPT SERVICE CHAIN
02278  002CE7  85 72                   STA STATUS	;SAVE OLD PROCESSOR STATUS     
02279  002CE9  68                      PLA		;GET THE LOW ORDER RETURN ADDRESS
02280  002CEA  18                      CLC		;GET READY FOR ADD
02281  002CEB  69 FF                   ADC #$FF	;ADD IN A -1
02282  002CED  85 73                   STA ITEMP1	;STORE IT IN PAGE ZERO
02283  002CEF  68                      PLA		;GET HIGH ORDER RETURN ADDR
02284  002CF0  69 FF                   ADC #$FF	;ADD IN A -1
02285  002CF2  85 74                   STA ITEMP1+1	;STORE IN PAGE ZERO
02286  002CF4  98                      TYA		;GET Y REGISTER
02287  002CF5  48                      PHA		;SAVE ON STACK
02288  002CF6  A0 00                   LDY #$00	;OFFSET OF ZERO
02289  002CF8  B1 73                   LDA (ITEMP1),Y	;GET BRK CODE     
02290  002CFA  48                      PHA		;SAVE ON STACK
02291  002CFB  30 04                   BMI BERROR	;BRANCH IF A SOFTWARE DETECTED ERROR
02292  002CFD  68                      PLA		;POSITIVE ERROR CODE, GET IT BACK
02293  002CFE  A9 EE                   LDA #UNRBRK	;UNRECOGNIZABLE BREAK
02294  002D00  48                      PHA		;SAVE ON STACK
02295  ;
02296  ;          ERROR CODE OUTPUT ROUTINE
02297  ;
02298  002D01  A9 FF         BERROR    LDA #$FF	;GET -1
02299  002D03  85 81                   STA M1	;FOR HIGH ORDER
02300  002D05  68                      PLA		;GET THE NEG ERROR CODE
02301  002D06  85 82                   STA M1+1	;STORE INIC LOW ORDER
02302  002D08  20 4D 32                JSR FLT16	;FLOAT IT
02303  002D0B  20 0D 20                JSR SETUP	;RESET AND INITIALIZE IMPORTANT STUFF
02304  002D0E  20 99 2D                JSR CRLF	;ADVANCE A LINE
02305  002D11  A9 3F                   LDA #$3F	;'?' INDICATE AN ERROR
02306  002D13  20 02 29                JSR PRINTC	;
02307  002D16  20 5E 26                JSR OUTLN0	;OUTPUT IT
02308  002D19  A5 26                   LDA PC	;GET HIGH ORDER FOCAL STATEMENT COUNTER
02309  002D1B  10 04                   BPL BERR1	;BRANCH IF ERROR OCCURED IN A STORED STATEMENT
02310  002D1D  C9 FE                   CMP #STRLIN	;DID ERROR OCCUR WHILE EXECUTING A STRING?
02311  002D1F  D0 32                   BNE BERRC	;NO, THEN ERROR OCCURED IN DIRECT COMMAND
02312  002D21  A9 20         BERR1     LDA #$20	;SPACE FOR LOOKS
02313  002D23  20 02 29                JSR PRINTC	;
02314  002D26  A9 40                   LDA #$40	;NOW AN '@'
02315  002D28  20 02 29                JSR PRINTC          
02316  002D2B  A9 20                   LDA #$20	;ANOTHER SPACE FOR THE LOOKS
02317  002D2D  20 02 29                JSR PRINTC
02318  002D30  20 0A 27                JSR PUSHTP	;SAVE THE TEXTPOINTERS
02319  002D33  A5 26                   LDA PC	;EXECUTING A STRING WHEN ERROR OCCURED?
02320  002D35  10 0C                   BPL BERR2	;BRANCH IF NOT, PRINT STATEMENT NUMBER
02321  002D37  A5 27                   LDA PC+1	;YES, THEN GET THE STRING NAME
02322  002D39  20 E7 23                JSR PRTVNM	;AND PRINT IT
02323  002D3C  A9 24                   LDA #$24	;INDICATE IT'S A STRING
02324  002D3E  20 02 29                JSR PRINTC          
02325  002D41  D0 0D                   BNE BERR3	;AND UNCONDITIONALLY PRESS ON
02326  002D43  A9 26         BERR2     LDA #PC	;GET ADDR OF WHERE PROGRAM COUNTER IS STORED
02327  002D45  85 28                   STA TXTADR	;MAKE TEXT POINTER POINT TO IT
02328  002D47  A9 00                   LDA #$00
02329  002D49  85 29                   STA TXTADR+1	;HIGH ORDER IS ZERO
02330  002D4B  85 2A                   STA TEXTP
02331  002D4D  20 31 26                JSR PRNTLN	;OUTPUT THE LINE NUMBER
02332  002D50  20 11 27      BERR3     JSR POPTP	;RESTORE TEXT POINTERS
02333  			;FALL INTO 'BERRC'
02334  ;
02335  ;          'MORE INTERRUPT HANDLERS'
02336  ;
02337  002D53  20 96 2D      BERRC     JSR CRLF2	;ADVANCE TWO LINES
02338  002D56  A0 00                   LDY #$00	;POINT TO FIRST CHAR IN LINE
02339  002D58  A5 26                   LDA PC	;DIRECT COMMAND OR STRING?
02340  002D5A  30 02                   BMI OUTCMD	;BRANCH IF YES
02341  002D5C  A0 02                   LDY #$02	;NO, THEN POINT PAST LINE NUMBER
02342  002D5E  C4 2A         OUTCMD    CPY TEXTP	;ARE WE AT FRONT OF LINE?
02343  002D60  F0 31                   BEQ BERRET	;BRANCH IF YES, DON'T OUTPUT SPECIAL ERROR AID
02344  002D62  98            OUTCML    TYA		;SAVE Y OUTPUT ACROSS OUTPUT CALL
02345  002D63  48                      PHA
02346  002D64  B1 28                   LDA (TXTADR),Y	;OUTPUT CHAR FROM COMMAND LINE SO USER CAN SEE
02347  002D66  20 02 29                JSR PRINTC
02348  002D69  C9 0D                   CMP #$0D	;REACHED END OF LINE YET?
02349  002D6B  F0 05                   BEQ EREOL	;BRANCH IF YES,
02350  002D6D  68                      PLA		;RESTORE Y REG
02351  002D6E  A8                      TAY
02352  002D6F  C8                      INY		;POINT TO THE NEXT CHAR IN THE COMMAND LINE
02353  002D70  D0 F0                   BNE OUTCML	;AND LOOP TILL ALL OF THE COMMAND LINE HAS BEEN OUTPUT
02354  002D72  68            EREOL     PLA		;ADJUST STACK
02355  002D73  20 9E 2D                JSR OUTLF	;FOLLOW WITH A LINE FEED
02356  002D76  C6 2A         CHKERR    DEC TEXTP	;COUNT DOWN NUMBER OF BYTES TILL ERROR
02357  002D78  A0 00                   LDY #$00	;ASSUME WE COUNT BACK TO ZERO
02358  002D7A  A5 26                   LDA PC	;DIRECT COMMAND OR STRING
02359  002D7C  30 02                   BMI CHKERC	;BRANCH IF YES
02360  002D7E  A0 02                   LDY #$02	;NO, THEN WE ONLY COUNT BACK TO LINE NUMBER
02361  002D80  C4 2A         CHKERC    CPY TEXTP	;HAVE WE OUTPUT ENOUGH SPACES TO GET ERROR BYTE?
02362  002D82  F0 07                   BEQ EARROW	;BRANCH IF YES, OUTPUT UPARROW TO FLAG CHARACTER
02363  002D84  A9 20                   LDA #$20	;NO, THEN ADVANCE ONE SPACE
02364  002D86  20 02 29                JSR PRINTC          
02365  002D89  10 EB                   BPL CHKERR	;AND UNCONDITIONALLY CHECK AGAIN
02366  002D8B  A9 5E         EARROW    LDA #$5E	;OUTPUT UPARROW TO INDICATE WHERE ERROR IS
02367  002D8D  20 02 29                JSR PRINTC
02368  002D90  20 96 2D                JSR CRLF2	;AND ADVANCE FOR LOOKS
02369  002D93  4C 31 20      BERRET    JMP START	;AND RESTART
02370  ;
02371  ;
02372  002D96  20 99 2D      CRLF2     JSR CRLF          ;ADVANCE TWO LINES
02373  002D99  A9 0D         CRLF      LDA #$0D          ;A CARRIAGE RETURN
02374  002D9B  20 02 29                JSR PRINTC
02375  002D9E  A9 0A         OUTLF     LDA #$0A          ;AND A LF
02376  002DA0  4C 02 29                JMP PRINTC          ;* PJMP * TO PRINT ROUTINE
02377  ;
02378  ;          'INTEGER LINE NUMBER INPUT ROUTINE'
02379  ;
02380  ; 'GETLIN' THIS ROUTINE IS CALLED IF THE FIRST CHAR OF A LINE NUMBER
02381  ; IS 0-9 FOR ADDED SPEED, AS THE CALL TO 'EVAL' IS POWERFUL
02382  ; BUT SLOW (SEE 'GETLN').
02383  ;
02384  002DA3  20 C2 2D      GETILN    JSR GETIN	;GET A TWO-DIGIT INTEGER
02385  002DA6  85 2C                   STA GRPNO	;SAVE AS GROUP NUMBER
02386  002DA8  20 3E 2B                JSR TTERMS	;IS TERMINATOR ONE WE RECOGNIZE?
02387  002DAB  F0 31                   BEQ GETIR	;YES, THEN RETURN
02388  002DAD  C9 2E                   CMP #$2E	;NO, IS IT A PERIOD?
02389  002DAF  D0 29                   BNE GETBAD	;NO, THEN A BAD LINE NUMBER
02390  002DB1  20 BB 29                JSR TESTNS	;ANOTHER NUMBER?
02391  002DB4  B0 24                   BCS GETBAD	;NO, THEN ERROR
02392  002DB6  20 C2 2D                JSR GETIN	;YES, THEN GET NEXT NUMBER
02393  002DB9  90 04                   BCC LNOK	;BRANCH, IF TWO-DIGIT OUTPUT
02394  002DBB  AA                      TAX		;MOVE INTO X
02395  002DBC  BD DF 2D                LDA TENS,X	;YES, THEN ASSUME TRAILING ZERO
02396  002DBF  85 2D         LNOK      STA LINENO	;SAVE THE LINE (STEP) NUMBER
02397  002DC1  60                      RTS		;AND RETURN
02398  ;
02399  002DC2  29 0F         GETIN     AND #$0F	;MAKE 0-9
02400  002DC4  48                      PHA		;SAVE ON STACK
02401  002DC5  20 BB 29                JSR TESTNS	;TEST NEXT NON-BLANK
02402  002DC8  68                      PLA		;RESTORE SAVED NUMBER
02403  002DC9  B0 13                   BCS GETIR	;RETURN IF NOT A DIGIT
02404  002DCB  AA                      TAX		;PLACE SAVED NUMBERINTO X
02405  002DCC  A5 2B                   LDA CHAR	;GET NEW DIGIT
02406  002DCE  29 0F                   AND #$0F	;FORM 0-9
02407  002DD0  7D DF 2D                ADC TENS,X	;ADD IN PROPER HIGH ORDER
02408  002DD3  48                      PHA		;SAVE NUMBER ON STACK
02409  002DD4  20 BB 29                JSR TESTNS	;TEST NEXT NON-BLANK
02410  002DD7  68                      PLA		;GET SAVED NUMBER BACK
02411  002DD8  B0 03                   BCS GETIRC	;BRANCH IF NOT A NUMBER
02412  002DDA  4C 25 26      GETBAD    JMP BADLNO	;BAD LINE NUMBER BRANCH AID
02413  002DDD  18            GETIRC    CLC		;INDICATE TWO DIGITS INPUT
02414  002DDE  60            GETIR     RTS		;RETURN
02415  ;
02416  TENS      .BYTE 0
02417            .BYTE 10
02418            .BYTE 20
02419            .BYTE 30
02420            .BYTE 40
02421            .BYTE 50          ; Aresco code has a $15 here, clearly wrong
02422            .BYTE 60                 
02423            .BYTE 70
02424            .BYTE 80             
02425            .BYTE 90                  
02426  ;
02427  ;
02428  ;
02429  ;               FOCAL FUNCTIONS
02430  ;
02431  ;
02432  002DE9  A0 00         FUNC      LDY #$00	; SET OFFSET TO ZERO
02433  002DEB  8A                      TXA		;PLACE HASH CODE INTO ACCUMULATOR
02434  002DEC  BE F5 34      FUNC1     LDX FUNTAB,Y	;GET TABLE VALUE
02435  002DEF  F0 15                   BEQ BADFUN	;END OF TABLE AND NOT FOUND
02436  002DF1  D9 F5 34                CMP FUNTAB,Y	;MATCH YET?
02437  002DF4  F0 03                   BEQ GOTFUN	;YES, WE FOUND IT
02438  002DF6  C8                      INY		;NO, POINT TO NEXT ENTRY
02439  002DF7  D0 F3                   BNE FUNC1	;AND TRY IT
02440  002DF9  B9 2D 35      GOTFUN     LDA FUNADL,Y	;GET LOW ORDER ARRD OFROUTINE TO HANDLE
02441  002DFC  85 5F                   STA TEMP1	;FUNCTION
02442  002DFE  B9 11 35                LDA FUNADH,Y	;GET HIGH ORDER
02443  002E01  85 60                   STA TEMP1+1	;STORE IT
02444  002E03  6C 5F 00                JMP (TEMP1)	;AND GO TO IT (TEMP1)
02445  
02446  002E06  00            BADFUN    BRK		;TRAP
02447            .BYTE UNRFUN	;?UNRECOGNIZABLE FUNCTION NAME
02448  ;
02449  ;     FABS - ABS. VALUE FUNCTION
02450  ;
02451  002E08  20 F7 33      FABS      JSR ABSF1	;TAKE ABSOLUTE VALUE OF FAC1
02452  002E0B  4C 14 2E                JMP FPOPJ	;*PJMP* AND RETURN
02453  ;
02454  ;     FINT & FINR - RETURN INTEGER FUNCTIONS
02455  ;
02456  002E0E  20 A7 2F      FINT      JSR INTFIX	; MAKE FAC1 AN INTEGER
02457  002E11  20 39 32      FLPOPJ    JSR FLOAT	; FLOAT ALL BITS
02458  002E14  20 4B 28      FPOPJ     JSR POPJ	; *FJMP* AND RETURN
02459  ;
02460  ; 'FINR' INTEGERIZE AFTER ROUNDING
02461  ;
02462  002E17  20 93 2F      FINR      JSR INTGER	; FORM ROUNDED INTEGER
02463  002E1A  4C 11 2E                JMP FLPOPJ	;*PJMP*FLOAT AND RETURN
02464  ;
02465  ;              ROUTINES TO CHECK RANGE INPUT AND OUTPUT DEVICE NUMBERS
02466  ;
02467  002E1D  C9 03         CHKODV    CMP #ODEVM	;COMPARE AC AGAINST MAX ALLOWED
02468  002E1F  10 05                   BPL RNGDEV	;BRANCH IF ERROR
02469  002E21  60            CHKRTS    RTS		;RETURN IF OK
02470  002E22  C9 03         CHKIDV    CMP #IDEVM	;COMPARE AGAINST MAX
02471  002E24  30 FB                   BMI CHKRTS	;RETURN IF OK
02472  002E26  C9 FF         RNGDEV    CMP #$FF	;MINUS 1?
02473  002E28  F0 F7                   BEQ CHKRTS	;BRANCH IF YES, ALWAYS IN RANGE
02474  002E2A  00                      BRK		;TRAP
02475  	  .BYTE DEVRNG	;DEVICE NUMBER OUT OF RANGE
02476  ;
02477  ;              "FINI" INITIALIZE INPUT DEVICE 
02478  ;
02479  002E2C  20 93 2F      FINI      JSR INTGER	;MAKE ARGUMENT INTEGER
02480  002E2F  30 06                   BMI INIRET	;IGNORE IF NEGATIVE
02481  002E31  20 22 2E                JSR CHKIDV	;CHECK FOR VALIDITY
02482  002E34  20 8D 2E                JSR INI	;GO CALL APPROPRIATE ROUTINE     
02483  002E37  4C 11 2E      INIRET    JMP FLPOPJ	;NO ERRORS, RETURN
02484  ;
02485  ;            'FINO' INITIALIZE OUTPUT DEVICE
02486  ;
02487  002E3A  20 93 2F      FINO      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02488  002E3D  30 F8                   BMI INIRET	;IGNORE IF NEGATIVE
02489  002E3F  20 1D 2E                JSR CHKODV	;CHECK FOR VALIDITY
02490  002E42  20 A2 2E                JSR INO	;GO CALL APPROPRIATE ROUTINE
02491  002E45  4C 11 2E                JMP FLPOPJ	;NO ERRORS - RETURN
02492  ;
02493  ;            'FCLI' CLOSE INPUT DEVICE
02494  ;
02495  002E48  20 93 2F      FCLI      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02496  002E4B  30 06                   BMI CLIRET	;IGNORE IF NEGATIVE
02497  002E4D  20 22 2E                JSR CHKIDV	;RANGE CHECK THE DEVICE NUMBER
02498  002E50  20 B6 2E                JSR CLI_	;CALL DEVICE DEPENDENT CODE
02499  002E53  4C 11 2E      CLIRET    JMP FLPOPJ	;NO ERRORS - RETURN
02500  ;
02501  ;           "FCLO" CLOSE OUTPUT DEVICE
02502  ;
02503  002E56  20 93 2F      FCLO      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02504  002E59  30 F8                   BMI CLIRET	;IGNORE IF NEGATIVE
02505  002E5B  20 1D 2E                JSR CHKODV	;RANGE CHECK THE DEVICE NUMBER
02506  002E5E  20 C2 2E                JSR CLO	;CALL DEVICE DEPENDENT CODE
02507  002E61  4C 11 2E                JMP FLPOPJ	;NO ERRORS - RETURN
02508  ;
02509  ;           "FCON" SET CONSOLE DEVICE
02510  ;
02511  002E64  20 93 2F      FCON      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02512  002E67  30 11                   BMI RETCON	;BRANCH IF NEGATIVE
02513  002E69  20 22 2E                JSR CHKIDV	;MAKE SURE DEVICE IS IN RANGE FOR BOTH INPUT
02514  002E6C  20 1D 2E                JSR CHKODV	;AND OUTPUT
02515  002E6F  85 6A                   STA CONDEV	;MAKE IT CURRENT CONSOLE     
02516  002E71  20 15 20                JSR CLRDEV	;MAKE CURRENT IO DEVICE
02517  002E74  20 27 20                JSR INIDEV	;INITIALIZE IT FOR INPUT AND OUTPUT
02518  002E77  4C 11 2E                JMP FLPOPJ	;*PJMP* NO ERRORS - RETURN
02519  002E7A  A5 6A         RETCON    LDA CONDEV	;GET THE DEVICE NUMBER OF CONSOLE
02520  002E7C  20 41 32                JSR FLT8	;FLOAT IT
02521  002E7F  4C 14 2E                JMP FPOPJ	;*PJMP* AND RETURN
02522  ;
02523  ;           "FCUR" CONSOLE CURSOR ADDRESSING FUNCTION
02524  ;          NOTE:     THIS FUNCTION IS DEVICE DEPENDENT, AND IS HERE
02525  ;                    PRIMARILY BY POPULAR DEMAND. THE FUNCTION HAS
02526  ;                    TWO ARGUMENTS. THE FIRST IS THE ROW, THE SECOND     
02527  ;                    IS THE COLUMN, OF THE PLACE TO POSITION ON THE CONSOLE
02528  ;                    DEVICE (USUALLY ASSUMED TO BE CRT).
02529  ;
02530    2940              CONCUR = RTS1 ; Device dependant routine location - currently disabled
02531  002E82  20 79 2F      FCUR      JSR FI2ARG	;PICK UP TWO INTEGER ARGS
02532  002E85  20 40 29                JSR CONCUR	;*** CALL THE DEVICE DEPENDENT CODE ***
02533  002E88  B0 29                   BCS JOERRO	;BRANCH IF ERROR HAS OCCURED
02534  002E8A  4C 11 2E                JMP FLPOPJ	;* PJMP * AND RETURN
02535  ;
02536  ;ROUTINES TO DISPATCH TO DEVICE DEPENDENT INITIALIZATION ROUTINE
02537  ;ENTER EACH WITH THE DEVICE NUMBER IN THE ACCUMULATOR
02538  ;THEY WILL RETURN ONLY IF NO ERRORS WERRE ENCOUNTERED
02539  ;
02540  002E8D  AA            INI       TAX		;USE AS OFFSET TO ADDR TABLE
02541  002E8E  BD C3 35                LDA INIAH,X	;GET HIGH ORDER ADDR OF THE ROUTINE TO HANDLE
02542  002E91  85 60                   STA TEMP1+1	;SAVE IT
02543  002E93  BD C8 35                LDA INIAL,X	;GET LOW ORDER ADDR
02544  002E96  85 5F         INIC      STA TEMP1	;SAVE IT
02545  002E98  18                      CLC		;ASSUME SUCCESSS
02546  002E99  20 5E 00                JSR JSRIND	;CALL THE PROPER ROUTINE FOR THIS DEVICE
02547  002E9C  90 03                   BCC IRTS	;RETURN IF NO ERRORS
02548  002E9E  4C D6 28                JMP IERRI	;ERROR, GO COMPLAIN
02549  002EA1  60            IRTS      RTS
02550  
02551  002EA2  AA            INO       TAX		;USE AS OFFSET
02552  002EA3  BD CD 35                LDA INOAH,X	;GET HIGH ORDER OF THE ROUTINE TO HANDLE
02553  002EA6  85 60                   STA TEMP1+1	;SAVE IT
02554  002EA8  BD D2 35                LDA INOAL,X	;GET LOW ORDER OF THE ROUTINE TO HANDLE
02555  002EAB  85 5F         INOC      STA TEMP1	;SAVE IT
02556  002EAD  18                      CLC		;ASSUME SUCCESS
02557  002EAE  20 5E 00                JSR JSRIND	;CALL PROPER ROUTINE FOR THIS DEVICE
02558  002EB1  90 EE                   BCC IRTS	;RETURN IF NO ERRORS
02559  002EB3  4C 24 29      JOERRO    JMP OERRO	;COMPLAIN IF ERRORS
02560  
02561  002EB6  AA            CLI_      TAX		;USE AS OFFSET TO TABLE
02562  002EB7  BD D7 35                LDA CLIAH,X	;GET HIGH ORDER ADDR OF THE DEVICE DEPENDENT CODE
02563  002EBA  85 60                   STA TEMP1+1
02564  002EBC  BD DC 35                LDA CLIAL,X	;GET LOW ORDER ADDR
02565  002EBF  4C 96 2E                JMP INIC	;*PJMP* CALL DEVICE DEPENDENT CODE AND RETURN
02566  
02567  
02568  002EC2  AA            CLO       TAX		;USE AS OFFSET TO TABLE
02569  002EC3  BD E1 35                LDA CLOAH,X	;GET HIGH ORDER ADDR OF THE DEVICE DEPENDENT CODE
02570  002EC6  85 60                   STA TEMP1+1
02571  002EC8  BD E6 35                LDA CLOAL,X	;GET LOW ODER
02572  002ECB  4C AB 2E                JMP INOC	;*PJMP* CALL DEVICE DEPENDENT CODE AND RETURN
02573  ;
02574  ;           "FMEM"  MEMORY EXAMINE-DEPOSIT FUNCTION
02575  ;
02576  002ECE  20 79 2F      FMEM      JSR FI2ARG	;PICK UP TWO INTEGER ARGS
02577  002ED1  A4 2B                   LDY CHAR	;GET THE TERMINATOR
02578  002ED3  C0 2C                   CPY #$2C	;ANOTHER ARG?
02579  002ED5  F0 12                   BEQ FMEMD	;YES, THEN IT'S THE DEPCSIT FUNCTION
02580  002ED7  85 56                   STA ITMP1H	;SAVE HIGH ORDER ARRD TO EXAMINE
02581  002ED9  86 55                   STX ITMP1L	;SAVE THE LOW ORDER ADDR TO EXAMINE               
02582  002EDB  A0 00                   LDY #$00	;FORM OFFSET OF ZERO
02583  002EDD  B1 55                   LDA (ITMP1L),Y	;GET DATA STORED IN THE LOCATION
02584  002EDF  85 82         ST16PJ    STA M1+1	;SAVE IN INTEGER
02585  002EE1  84 81                   STY M1	;HIGH ORDER OF ZERO
02586  002EE3  20 4D 32      FL16PJ    JSR FLT16	;FLOAT A 16 BIT INTEGER
02587  002EE6  4C 14 2E                JMP FPOPJ	;*PJMP* AND RETURN
02588  
02589  002EE9  48            FMEMD     PHA		;SAVE HIGH ORDER
02590  002EEA  8A                      TXA		;
02591  002EEB  48                      PHA		;AND LOW ORDER 
02592  002EEC  20 89 2F                JSR NXIARG	;PICK UP THE NEXT INTEGER ARG
02593  002EEF  A8                      TAY		;SAVE IN Y REGISTER FOR A MOMENT
02594  002EF0  68                      PLA		;GET LOW ORDER ADDR BACK
02595  002EF1  85 55                   STA ITMP1L                         
02596  002EF3  68                      PLA		;GET HIGH ORDER ADDR BACK
02597  002EF4  85 56                   STA ITMP1H     
02598  002EF6  98                      TYA		;GET DATA TO DEPOSIT BACK
02599  002EF7  A0 00                   LDY #$00	;SET OFFSET OF ZERO
02600  002EF9  48                      PHA		;SAVE DATA TO DEPOSIT
02601  002EFA  B1 55                   LDA (ITMP1L),Y	;READ THE LOCATION
02602  002EFC  85 82                   STA M1+1	;SAVE AS INTEGER
02603  002EFE  84 81                   STY M1	;HIGH ORDER OF ZERO
02604  002F00  68                      PLA		;GET DATA TO DEPOSIT BACK AGAIN
02605  002F01  91 55                   STA (ITMP1L),Y	;STORE IN THE ADDR     
02606  002F03  A5 2B                   LDA CHAR	;GET TERMINATOR
02607  002F05  C9 2C                   CMP #$2C	; ',' MORE ARGS?
02608  002F07  D0 DA                   BNE FL16PJ	;* PJMP * NO, FLOAT AND RETURN
02609  002F09  20 1C 28                JSR PUSHJ	;MOVE PAST COMMA,
02610            .WORD EVALM1	;EVALUATE NEXT ARG
02611  002F0E  4C CE 2E                JMP FMEM	;AND TRY AGAIN
02612  ;
02613  ;          "FOUT" OUTPUT ASCII EQUIVALENT
02614  ;
02615  002F11  20 93 2F      FOUT      JSR INTGER	;FORM INTEGER
02616  002F14  20 02 29                JSR PRINTC	;OUTPUT THE CHARACTER
02617  002F17  4C 11 2E                JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02618  ;
02619  ;           "FCHR" RETUNR DECIMAL EQUIVALIENT CF ASCII CHAR INPUT
02620  ;
02621  002F1A  20 20 2F      FCHR      JSR GICHR	;GET A CHAR FROM INPUT DEVICE 
02622  002F1D  4C E3 2E                JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02623  ;
02624  ; ROUTINE TO INPUT ONE CHAR FROM INPUT DEVICE INTO FAC1
02625  ;
02626  002F20  A9 00         GICHR     LDA #$00	;ZERO HIGH ORDER
02627  002F22  85 81                   STA M1	;               
02628  002F24  A5 2B                   LDA CHAR	;SAVE CURRENT HAR
02629  002F26  48                      PHA
02630  002F27  20 C0 28                JSR READC	;NEXT CHAR FROM INPUT DEVICE
02631  002F2A  85 82                   STA M1+1	;STORE IN LOW ORDER
02632  002F2C  68                      PLA		;RESTORE SAVED CHAR
02633  002F2D  85 2B                   STA CHAR          
02634  002F2F  A5 82                   LDA M1+1	;GET CHAR INPUT INTO ACCUMULATOR
02635  002F31  60                      RTS		;AND RETURN
02636  ;
02637  ;           "FECH" SET CHAR ECHO CONTROL
02638  ;
02639  002F32  20 93 2F      FECH      JSR INTGER	;FORM INTEGER
02640  002F35  85 6B                   STA ECHFLG	;SAVE IN FLAG FOR LATER REFERENCE
02641  002F37  4C 11 2E                JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02642      ;
02643  ;           "FIDV" SET INPUT DEVICE FUNCTION
02644  ;
02645  002F3A  A2 44         FIDV      LDX #STIADR	;GET ADDR TO STORE INTO STRING INFORMATION
02646  002F3C  20 5F 2F                JSR GTDEVN	;GET DEVICE NUMBER (POSSIBLY A STRING)
02647  002F3F  20 22 2E                JSR CHKIDV	;RANGE CHECK IT
02648  002F42  A6 66                   LDX IDEV	;SAVE PREVIOUS VALUE FOR POSSIBLE RESTORE
02649  002F44  86 68                   STX IDVSAV	;
02650  002F46  85 66                   STA IDEV	;MAKE IT THE CURRENT INPUT DEVICE
02651  002F48  4C 59 2F                JMP FIODRT	;* PJMP * SET FAC1 TO ZERO, THEN RETURN
02652  ;
02653  ;           "FODV" SET OUTPUT DEVICE FUNCTION
02654  ;
02655  002F4B  A2 48         FODV      LDX #STOADR	;GET SDDR TO STORE STRING INFORMATION
02656  002F4D  20 5F 2F                JSR GTDEVN	;GET DEVICE NUMBER (POSSIBLY A STRING)
02657  002F50  20 1D 2E                JSR CHKODV	;RANGE CHECK IT
02658  002F53  A6 67                   LDX ODEV	;SAVE PREVIOUS VALUE FOR POSSIBLE RESTORE
02659  002F55  86 69                   STX ODVSAV
02660  002F57  85 67                   STA ODEV	;SET AS OUTPUT DEVICE
02661  002F59  20 CB 2C      FIODRT    JSR ZRFAC1	;RETURN A VALUE OF ZERO FOR THE FUNCTION 
02662  002F5C  4C 11 2E                JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02663  ;
02664  ; ROUTINE TO GET A DEVICE NUMBER (POSSIBLY A STRING)
02665  ;
02666  002F5F  A5 3B         GTDEVN    LDA STRSWT	;WAS ARGUMENT A STRING VARIABLE?
02667  002F61  D0 03                   BNE STRDEV	;BRANCH IF YES
02668  002F63  4C 93 2F                JMP INTGER	;* PJMP * NO, JUST TO INTEGRIZE ARG AND RETURN
02669  002F66  A5 37         STRDEV    LDA VARADR	;STORE BASE ADDR OF STRING
02670  002F68  95 00                   STA $00,X	;IN POINTER
02671  002F6A  A5 38                   LDA VARADR+1
02672  002F6C  95 01                   STA $01,X
02673  002F6E  A5 3A                   LDA VSUB+1	;GET SUBSCRIPT OF PLACE TO START
02674  002F70  95 02                   STA $02,X          
02675  002F72  A5 3C                   LDA VSIZE	;AND GET MAX SIZE OF STRING
02676  002F74  95 03                   STA $03,X
02677  002F76  A9 FF                   LDA #$FF	;RETURN DEVICE NUMBER OF -1
02678  002F78  60                      RTS		;AND RETURN
02679  
02680  002F79  A5 2B         FI2ARG    LDA CHAR	;GET TERMINATOR
02681  002F7B  C9 2C                   CMP #$2C	;',' ANOTHER ARG?
02682  002F7D  D0 12                   BNE FARGM	;BRANCH IF ARG IS MISSING
02683  002F7F  20 93 2F                JSR INTGER	;GET A SINGLE BYTE INTEGER
02684  002F82  48                      PHA		;SAVE ACROSS 'EVAL' CALL
02685  002F83  20 89 2F                JSR NXIARG	;GET ANOTHER ARG
02686  002F86  AA                      TAX		;SAVE THE SECOND ARGUMENT
02687  002F87  68                      PLA		;GET THE FIRST ARGUMENT 
02688  002F88  60                      RTS		;AND RETURN
02689  ;
02690  002F89  20 1C 28      NXIARG    JSR PUSHJ	;MOVE PAST COMMA, EVALUATE NEXT ARGUMENT
02691            .WORD EVALM1
02692  002F8E  4C 93 2F                JMP INTGER	;*PJMP* FORM SINGLE BYTE INTEGER AND RETRUN
02693  
02694  002F91  00            FARGM     BRK		;TRAP
02695            .BYTE ARGM	;?ARGUMENT MISSING IN FUNCTION
02696  ;
02697  ;     ROUTINE TO GENERATE A ROUNDED INTEGER
02698  ;
02699  002F93  A2 96         INTGER    LDX #FHALF	;MOVE CONSTANT .50
02700  002F95  A0 7B                   LDY #X2	;INTO FAC2
02701  002F97  20 FF 33                JSR MOVXY
02702  002F9A  20 29 32                JSR SWAP	;PUT .5 IN FAC1
02703  002F9D  A5 7C                   LDA M2	;GET SIGN OF FAC2
02704  002F9F  10 03                   BPL INTG1	;OK IF POSITIVE
02705  002FA1  20 B8 32                JSR FCOMPL	;MAKE -.50
02706  002FA4  20 79 32      INTG1     JSR FADD	;ADD IT IN AS ROUNDING
02707  002FA7  20 18 33      INTFIX    JSR FIX	;AND FORM 23 BIT INTEGER
02708  002FAA  A5 83                   LDA M1+2	;GET LOW ORDER IF CALLER NEEDS IT               
02709  002FAC  60                      RTS		;AND RETURN
02710  ;
02711  ;           "FPIC" SOFTWARE PRIORITY INTERRUPT CONTROL FUNCTION
02712  ;
02713  002FAD  20 1C 28      FPICC     JSR PUSHJ	;CALL 'EVAL' TO PICK UP NEXT ARG
02714            .WORD EVALM1
02715  002FB2  A5 2B         FPIC      LDA CHAR	;GET CHAR WHICH TERMINATED ARGUMENT
02716  002FB4  C9 2C                   CMP #$2C	;IS THERE ANOTHER ARGUMENT TO FOLLOW
02717  002FB6  D0 D9                   BNE FARGM	;BRANCH IF NOT, GO COMPLAIN
02718  002FB8  20 93 2F                JSR INTGER	;YES, PICK UP VALUE OF FIRST
02719  002FBB  F0 27                   BEQ PISET	;BRANCH IF LEVEL TO ENABLE IS 0
02720  002FBD  48                      PHA		;SAVE LEVEL TO ENABLE
02721  002FBE  20 92 29                JSR GETC	;MOVE PAST COMMA
02722  002FC1  20 BC 25                JSR GETLNS	;AND PICK UP THE LINE NUMBER TO 'DO'
02723  002FC4  68                      PLA		;GET LEVEL BACK
02724  002FC5  AA                      TAX		;INTO X REGISTER
02725  002FC6  A5 2C                   LDA GRPNO	;GET GROUP NUMBER OF LINE TO 'DO'
02726  002FC8  9D 8B 35                STA INTGRP,X	;SAVE FOR LATER USE
02727  002FCB  A5 2D                   LDA LINENO	;GET STEP NUMBER OF LINE TO 'DO'
02728  002FCD  9D 94 35                STA INTLIN,X	;SAVE FOR LATER USE
02729  002FD0  A5 6D                   LDA ACTMSK	;GET MASK WHICH INDICATES WITH CHANNELS
02730  002FD2  1D A6 35                ORA BITTAB,X	;SET THE BIT FOR SPECIFIED CHANNELS
02731  002FD5  85 6D                   STA ACTMSK	;MAKING IT ACTIVE NOW
02732  002FD7  A5 2B         ENDPIC    LDA CHAR	;GET CHAR WHICH TERMINATES SECOND ARG
02733  002FD9  C9 2C                   CMP #$2C	;',' ANY MORE ARGS?
02734  002FDB  F0 D0                   BEQ FPICC	;BRANCH IF YES, PICK THEM UP
02735  002FDD  A0 00                   LDY #$00	;NO GET A ZERO
02736  002FDF  A5 6D                   LDA ACTMSK	;AND THE CURRENT ACTIVE MASK
02737  002FE1  4C DF 2E                JMP ST16PJ	;* PJMP * STORE, FLOAT AND RETURN IT AS VALUE
02738  
02739  002FE4  20 89 2F      PISET     JSR NXIARG	;GET NEXT ARG AS NUMBER
02740  002FE7  A5 82                   LDA M1+1	;IS IT NEGATIVE
02741  002FE9  30 EC                   BMI ENDPIC	;YES, THEN THIS CALL IS A NO-OP
02742  002FEB  A5 83                   LDA M1+2	;NO, GET THE INTEGER VALUE (0-255)
02743  002FED  85 6D                   STA ACTMSK	;AND STORE THAT AS NEW ACTIVE MASK
02744  002FEF  4C D7 2F                JMP ENDPIC	;AND CHECK FOR MORE ARGUMENTS BEFORE RETURNING
02745  ;
02746  ;                    'FOCAL STRING FUNCTIONS'
02747  ;
02748  ;           "FISL" INITIALIZE STRING LENGTH
02749  ;
02750  002FF2  20 1C 28      FISLNX    JSR PUSHJ	;PICK UP NEXT ARGUMENT
02751           .WORD EVALM1     
02752  002FF7  A5 64         FISL      LDA STRSIZ	;SAVE DEFAULT STRING SIZE
02753  002FF9  48                      PHA          
02754  002FFA  20 93 2F                JSR INTGER	;GET FIRST ARGUMENT WHICH IS SIZE TO SET
02755  002FFD  85 64                   STA STRSIZ
02756  002FFF  20 0E 30                JSR FGTSV	;GET NEXT ARGUMENT WHICH IS A STRING VARIABLE
02757              ;IF NOT PREVIOUSLY DEFINED IT WILL BE DEFINED
02758              ;WITH SUPPLIED LENGTH.
02759  003002  68                      PLA		;RESTORE WITH LENGTH
02760  003003  85 64                   STA STRSIZ
02761  003005  A5 2B                   LDA CHAR
02762  003007  C9 2C                   CMP #$2C	;',' ANY MORE ARGS?
02763  003009  F0 E7                   BEQ FISLNX	;BRANCH IF YES, PROCESS THEM
02764  00300B  4C 14 2E                JMP FPOPJ	;* PJMP * NO, THEN RETURN
02765  ;
02766  ; ROUTINE TO GET A STRING VARIABLE FROM PROGRAM TEXT
02767  ;
02768  00300E  A5 2B         FGTSV     LDA CHAR	;ANY MORE ARGUMENTS IN FUNCTION CALL?
02769  003010  C9 2C                   CMP #$2C
02770  003012  D0 15                   BNE FSTRBA	;BRANCH IF NOT, ERROR
02771  003014  20 92 29                JSR GETC	;YES, MOVE PAST COMMA
02772  003017  20 1C 28      FGTSV1    JSR PUSHJ	;CALL 'GETVAR' TO GET A VARIABLE
02773            .WORD GETVAR
02774  00301C  A5 3B                   LDA STRSWT	;WAS IT A STRING VARIABLE?
02775  00301E  D0 02                   BNE SVOK	;BRANCH IF IT WAS 
02776  003020  00                      BRK		;TRAP
02777            .BYTE SVRQ	;?STRING VARIABLE REQUIRED HERE
02778  003022  A4 3A         SVOK      LDY VSUB+1	;GET ELEMENT POSITION
02779  003024  A5 37                   LDA VARADR	;AND LOW AND
02780  003026  A6 38                   LDX VARADR+1	;HIGH ORDER BASE ADDR OF STRING
02781  003028  60                      RTS		;AND RETURN
02782  
02783  003029  00            FSTRBA    BRK		;TRAP
02784            .BYTE BASTRF	;?BAD OR MISSING ARGUMENT IN STRING FUNCTION
02785  ;
02786  ;           "FSTI" INPUT A STRING FROM INPUT DEVICE
02787  ;
02788  00302B  20 8D 30      FSTI      JSR SETSIO	;PICK UP ARGS
02789  00302E  20 20 2F      FSTINX    JSR GICHR	;GET A CHARACTER FROM INPUT DEVICE
02790  003031  C5 3D                   CMP VCHAR	;IS THIS THE TERMINATOR?
02791  003033  F0 10                   BEQ SENDIO	;YES, THEN THAT'S ALL FOLKS
02792  003035  A4 3A                   LDY VSUB+1	;GET SUBSCRIPT TO PLACE CHAR
02793  003037  C9 7F                   CMP #RUBCHR	;IS THE CHARACTER A RUBOUT?
02794  003039  F0 15                   BEQ RUBSTI	;BRANCH IF YES, SEE IF WE DO SOMETHING
02795  00303B  91 37         FSTOC     STA (VARADR),Y	;STORE CHAR THERE
02796  00303D  E6 3A                   INC VSUB+1	;POINT TO NEXT
02797  00303F  E6 55                   INC STRCNT	;COUNT THIS CHARACTER
02798  003041  C6 59                   DEC STRMAX	;REACH MAX ALLOWED?
02799  003043  D0 E9                   BNE FSTINX	;BRANCH IF NOT, INPUT MORE
02800  003045  A9 00         SENDIO    LDA #$00	;STORE A ZERO IN HIGH ORDER
02801  003047  85 81                   STA M1               
02802  003049  A5 55                   LDA STRCNT	;GET NUMBER ACTUALLY MOVED
02803  00304B  85 82                   STA M1+1          
02804  00304D  4C E3 2E                JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02805  ;
02806  ;HERE IF RUBOUT SEEN DURING A STRING INPUT
02807  ;
02808  003050  A6 66         RUBSTI    LDX IDEV	;IS THE INPUT DEVICE
02809  003052  E4 6A                   CPX CONDEV	;THE CONSOLE?
02810  003054  D0 E5                   BNE FSTOC	;BRANCH IF NOT, DON'T DO ANYTHING SPECIAL
02811  003056  C4 5D                   CPY STBSAV	;YES, ARE WE TRYING TO RUBOUT PAST STARTING SUBSCRIPT?
02812  003058  F0 D4                   BEQ FSTINX	;BRANCH IF SO, DON'T DO ANYTHING, IGNORE RUBOUT
02813  00305A  A4 6B                   LDY ECHFLG	;DOES USER WANT CHARACTER ECHOING?
02814  00305C  D0 0E                   BNE RUBSC	;BRANCH IF ECHOING DISABLED
02815  00305E  A4 6C                   LDY DELSPL	;DO WE DO FANCY CRT STYLE RUBOUTS?
02816  003060  F0 05                   BEQ RUBS1	;BRANCH IF NOT
02817  003062  20 7D 29                JSR EATTVC	;YES, THEN EAT THE CHAR OFF CRT SCREEN
02818  003065  10 05                   BPL RUBSC	;AND DO COMMON THINGS
02819  003067  A9 5C         RUBS1     LDA #RUBECH	;ECHO PLAIN CHAR TO INDICATE A RUBOUT
02820  003069  20 08 29                JSR PRNTC     ; SamCoVT - scan says PRINTC but binary version 
02821                          ; uses PRNTC, which just skips NULL check
02822  00306C  C6 3A         RUBSC     DEC VSUB+1	;PACK UP ONE BYTE IN THE STRING
02823  00306E  C6 55                   DEC STRCNT	;DON'T COUNT THE CHARACTER RUBBED OUT
02824  003070  E6 59                   INC STRMAX
02825  003072  4C 2E 30                JMP FSTINX	;AND GET NEXT CHARACTER
02826  ;
02827  ;           "FSTO" OUTPUT A STRING TO OUTPUT DEVICE
02828  ;
02829  003075  20 8D 30      FSTO      JSR SETSIO	;GET ARGS
02830  003078  A4 3A         FSTONX    LDY VSUB+1	;GET SUBSCRIPT OF BYTE IN STRING
02831  00307A  B1 37                   LDA(VARADR),Y	;GET THE BYTE
02832  00307C  C5 3D                   CMP VCHAR	;TERMINATOR?
02833  00307E  F0 C5                   BEQ SENDIO	;BRANCH IF YES
02834  003080  20 02 29                JSR PRINTC	;OUTPUT IT
02835  003083  E6 3A                   INC VSUB+1	;POINT TO NEXT BATE
02836  003085  E6 55                   INC STRCNT	;COUNT THIS ONE OUTPUR
02837  003087  C6 59                   DEC STRMAX	;OUTPUT MAX YET?
02838  003089  D0 ED                   BNE FSTONX	;BRANCH IF MORE TO OUTPUT
02839  00308B  F0 B8                   BEQ SENDIO	;BRANCH IF WE HAVE HIT LIMIT
02840  ;
02841  ; ROUTINE TO GET ARGS FOR 'FSTI' AND 'FSTD'
02842  ;
02843  00308D  A9 00         SETSIO    LDA #$00	;GET A ZERO
02844  00308F  85 55                   STA STRCNT	;INIT BYTE COUNT TO ZERO
02845  003091  20 93 2F                JSR INTGER	;GET MAX NUMBER OF CHARACTER TO MOVE
02846  003094  85 59                   STA STRMAX
02847  003096  20 0E 30                JSR FGTSV	;GET THE STRING VARIABLE
02848  003099  48                      PHA		;SAVE NEAT STUFF RETURNED
02849  00309A  8A                      TXA
02850  00309B  48                      PHA
02851  00309C  98                      TYA
02852  00309D  48                      PHA
02853  00309E  A5 2B                   LDA CHAR	;IS THE OPTIONAL TERMINATOR ARG SUPPLIED?
02854  0030A0  C9 2C                   CMP #$2C      
02855  0030A2  F0 04                   BEQ SETS1	;YES, THEN PICK IT UP
02856  0030A4  A9 FF                   LDA #$FF	;NO, THEN SET IT TO $FF
02857  0030A6  D0 08                   BNE SETS2	;AND ENTER COMMON CODE
02858  0030A8  20 1C 28      SETS1     JSR PUSHJ	;MOVE PAST COMMA, PICK UP NEXT ARG
02859            .WORD EVALM1
02860  0030AD  20 93 2F                JSR INTGER	;FORM INTEGER
02861  0030B0  85 3D         SETS2     STA VCHAR	;SAVE TERMINATION CHARACTER
02862  0030B2  68                      PLA		;RESTORE GOOD STUFF
02863  0030B3  85 3A                   STA VSUB+1	;
02864  0030B5  85 5D                   STA STBSAV	;REMEMBER SUBSCRIPT TO BEGIN I-O TO/FROM
02865  0030B7  68                      PLA                    
02866  0030B8  85 38                   STA VARADR+1
02867  0030BA  68                      PLA
02868  0030BB  85 37                   STA VARADR
02869  0030BD  60                      RTS		;AND RETURN
02870  ;
02871  ; ROUTINE TO WRITE A STRING
02872  ;
02873  0030BE  A4 4A         WSTRNG    LDY STOPNT	;new line - not in the 6502 Grp original
02874  
02875              ;original code  	(appears to be a patch
02876              ;WSTRNG CPY STOMAX    in ProgExch code)
02877              ;     BEQ WSRET
02878              ;     STA (STOADR),Y
02879              ;     INC STOPNT
02880              ;WSRET      PLA
02881              ;     RTS
02882  ;                    ; then go on with IOSRET
02883  ;
02884  0030C0  C4 4B                   CPY STOMAX	;BEYOND END OF STRING
02885  0030C2  F0 04                   BEQ IOSRET	;BRANCH IF YES, IGNORE
02886  0030C4  91 48                   STA (STOADR),Y	;NO, STORE CHAR IN STRING
02887  0030C6  E6 4A                   INC STOPNT	;POINT TO NEXT BYTE
02888  
02889  0030C8  A9 0D         IOSRET    LDA #$0D	;RETURN A CR   
02890              ;additional line in original: 
02891                      ;STA CHAR ;also in char
02892  0030CA  60                      RTS		;AND RETURN 
02893  ;
02894  ; ROUTINE TO INPUT FROM A STRING
02895  ;
02896  0030CB  A4 46         RSTRNG    LDY STIPNT	;GET POINTER TO NEXT BYTE
02897  0030CD  C4 47                   CPY STIMAX	;BEYOND END OF STRING?
02898  0030CF  F0 F7                   BEQ IOSRET	;BRANCH IF YES, RETURN A CARRIAGE RETURN
02899  0030D1  B1 44                   LDA (STIADR),Y	;NO, GET BYTE FROM STRING
02900  0030D3  85 2B                   STA CHAR	;SAVE FOR THOSE WHO NEED IT
02901  0030D5  E6 46                   INC STIPNT	;AND POINT TO NEXT
02902  0030D7  60                      RTS		;AND RETURN
02903  ;
02904  ;           FSLK - STRING "LOOK" FUNCTION
02905  ;
02906  0030D8  A5 3B         FSLK      LDA STRSWT	;WAS ARG A STRING VARIABLE
02907  0030DA  D0 02                   BNE FSLK1	;YES, THEN PROCEED
02908  0030DC  00                      BRK		;TRAP
02909            .BYTE BASTRF	;?BAD OR MISSING ARGUMENT IN STRING
02910  0030DE  A5 37         FSLK1     LDA VARADR	;COPY POINTERS INTO STRING1 POINTERS
02911  0030E0  85 55                   STA STRAD1
02912  0030E2  A5 38                   LDA VARADR+1
02913  0030E4  85 56                   STA STRAD1+1
02914  0030E6  A5 3A                   LDA VSUB+1
02915  0030E8  85 57                   STA SBEG1	;STORE BEGINNING POSITION
02916  0030EA  20 0E 30                JSR FGTSV	;GET NEXT STRING PARAMETER
02917  0030ED  84 58                   STY SEND1	;STORE ENDING POSITION
02918  0030EF  20 0E 30                JSR FGTSV	;GET STRING 2 POINTERS
02919  0030F2  85 59                   STA STRAD2	;
02920  0030F4  86 5A                   STX STRAD2+1
02921  0030F6  84 5B                   STY SBEG2
02922  0030F8  20 0E 30                JSR FGTSV	;GET ENDING POSITION 
02923  0030FB  84 5C                   STY SEND2	;STORE IT
02924  0030FD  A9 FF                   LDA #$FF	;ASSUME -1 (STRING NOT FOUND)
02925  0030FF  85 81                   STA M1
02926  003101  85 82                   STA M1+1
02927  ;
02928  ;SEARCH ROUTINE
02929  ;
02930  003103  20 41 31      LKFCHR    JSR CMPCHR	;FIRST CHAR MATCH?
02931  003106  F0 09                   BEQ FCMAT	;BRANCH IF YES
02932  003108  C4 5C         CHKEOS    CPY SEND2	;NO, REACHES END OF STRING2?
02933  00310A  F0 32                   BEQ SNOTF	;BRANCH IF YES, STRING1 NOT FOUND IN STRING2
02934  00310C  E6 5B                   INC SBEG2	;NO, POINT TO NEXT CHAR IN STRING2
02935  00310E  4C 03 31                JMP LKFCHR	;AND TRY TO FIND CHAR MATCH
02936  ;
02937  ;  HERE IF FIRST CHAR IN STRING1 MATCHES A CHAR IN STRING2
02938  ;
02939  003111  20 4A 31      FCMAT     JSR PUSHSP	;SAVE CURRENT POSITION IN BOTH STRINGS
02940  003114  A5 57         NXCMAT    LDA SBEG1	;REACHED END OF  FIRST STRING?
02941  003116  C5 58                   CMP SEND1                              
02942  003118  F0 13                   BEQ SFOUND	;BRANCH IF YES, THEN STRING1 WAS FOUND IN STRING2
02943  00311A  C4 5C                   CPY SEND2	;NO, REACHED END OF STRING2?     
02944  00311C  F0 1D                   BEQ SNOTFP	;BRANCH IF YES, THEN STRING 1 CAN'T BE FOUND IN STRING2
02945  00311E  E6 57                   INC SBEG1	;POINT TO NEXT CHAR IN EACH STRING
02946  003120  E6 5B                   INC SBEG2
02947  003122  20 41 31                JSR CMPCHR	;MATCH?
02948  003125  F0 ED                   BEQ NXCMAT	;BRANCH IF YES, KEEP CHECKING AS LONG AS THEY MATCH
02949  003127  20 56 31                JSR POPSP	;NO, THEN RETURN TO THE POINT OF FIRST CHAR MATCH
02950  00312A  4C 08 31                JMP CHKEOS	;AND TRY AGAIN FOR FIRST CHAR MATCH
02951  00312D  20 56 31      SFOUND    JSR POPSP	;RESTORE POINTERS TO POSITION OF FIRST CHAR MATCH
02952  003130  A9 00                   LDA #$00	;STORE 0 IN HIGH ORDER
02953  003132  85 81                   STA M1                    
02954  003134  A5 5B                   LDA SBEG2	;RETURN SUBSCRIPT WHERE FIRST CHAR MATCHED
02955  003136  85 82                   STA M1+1               
02956  003138  4C E3 2E                JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02957  00313B  20 56 31      SNOTFP    JSR POPSP	;POP OFF SAVED POINTERS
02958  00313E  4C E3 2E      SNOTF     JMP FL16PJ	;FLOAT -1 AND RETURN STRING1 WAS NOT FOUND IN STRING2
02959  ;
02960  ; ROUTINES USED BY 'FSLK'
02961  ;
02962  003141  A4 57         CMPCHR    LDY SBEG1	;GET CHAR FROM STRING1
02963  003143  B1 55                   LDA (STRAD1),Y
02964  003145  A4 5B                   LDY SBEG2	;GET CHAR FROM STRING2
02965  003147  D1 59                   CMP (STRAD2),Y	;COMPARE THEM
02966  003149  60                      RTS		;RETURN WITH Z=1 IF THEY ARE THE SAME
02967  ;
02968  00314A  98            PUSHSP    TYA		;PRESERVE Y REGISTER
02969  00314B  48                      PHA          
02970  00314C  A2 55                   LDX #STRAD1	;SAVE STRING POINTERS ON STACK
02971  00314E  A0 08                   LDY #$08
02972  003150  20 6B 28                JSR PUSHB0
02973  003153  68                      PLA		;RESTORE Y REGISTER
02974  003154  A8                      TAY
02975  003155  60                      RTS		;AND RETURN
02976  ;
02977  003156  98            POPSP     TYA		;PRESERVE Y REGISTER
02978  003157  48                      PHA
02979  003158  A2 5C                   LDX #STRAD1+7	;RESTORE STRING POINTERS
02980  00315A  A0 08                   LDY #$08
02981  00315C  20 5B 28                JSR POPB0
02982  00315F  68                      PLA		;RESTORE Y REGISTER
02983  003160  A8                      TAY
02984  003161  60                      RTS		;AND RETURN
02985  ;
02986  ;            'FSBR' SINGLE VALUED SUBROUTINE CALL
02987  ;
02988  003162  20 DF 25      FSBR      JSR GETLN1	;FINISH EVALUATING GROUP OR LINE TO "DO"
02989  003165  08                      PHP		;SAVE STATUS FLAGS ON STACK
02990  003166  A9 30                   LDA #$30	;GET CODE NAME FOR VARIABLE '&0'
02991  003168  85 3D                   STA VCHAR	;SAVE AS VARIABLE NAME TO LOOK FOR
02992  00316A  A9 00                   LDA #$00	;ALSO SET SUBSCRIPT TO ZERO
02993  00316C  85 39                   STA VSUB
02994  00316E  85 3A                   STA VSUB+1
02995  003170  85 3B                   STA STRSWT	;MAKE SURE STRING VARIABLE FLAG IS OFF
02996  003172  20 1C 28                JSR PUSHJ	;CALL 'FNDVAR' TO LOCATE '&0(0)'
02997            .WORD FNDVAR
02998  003177  20 29 32                JSR SWAP	;PUT CURRENT VALUE OF '&0' INTO FAC2
02999  00317A  20 BB 2C                JSR PUSHIV	;SAVE IT'S VALUE AND ADDR ON STACK
03000  00317D  A5 2B                   LDA CHAR	;GET TERMINATOR
03001  00317F  C9 2C                   CMP #$2C	;',' IS THERE ANOTHER ARGUMENT
03002  003181  F0 02                   BEQ FSBR1	;BRANCH IF YES, PRESS ON
03003  003183  00                      BRK		;NO, TRAP
03004            .BYTE ARGM	;?ARGUMENT MISSING IN FUNCTION
03005  003185  68            FSBR1     PLA		;GET FLAGS FROM 'GETLN' INTO ACCUMULATOR
03006  003186  20 31 28                JSR PUSHA	;SAVE ON STACK
03007  003189  A2 2C                   LDX #GRPNO	;SAVE LINE OR GROUP TO 'DO'
03008  00318B  20 69 28                JSR PUSHB2
03009  00318E  20 1C 28                JSR PUSHJ	;MOVE PAST COMMA, EVALUATE NEXT ARGUMENT
03010            .WORD EVALM1  
03011  003193  A2 2D                   LDX #LINENO	;GET LINE OR GROUP TO 'DO' BACK
03012  003195  20 59 28                JSR POPB2               
03013  003198  20 3F 28                JSR POPA	;GET 'GETLN'FLAGS BACK
03014  00319B  48                      PHA		;SAVE ON STACK FOR LATER 
03015  00319C  20 C3 2C                JSR POPIV	;GET VALUE OF '&0' AND POINTER TO IT
03016  00319F  20 BB 2C                JSR PUSHIV	;SAVE FOR LATER (VALUE IS IN FAC2)
03017  0031A2  20 A1 2C                JSR PUTVAR	;NOW SET '&0' TO ARG VALUE (IN FAC1)
03018  
03019  ; SamCoVT - These next 4 instructions do not appear to be in the original .PTP version          
03020  ;          LDA INSW	;SAVE WHERE INPUT IS COMING FROM
03021  ;          JSR PUSHA	;(PROGRAM OR INPUT DEVICE)
03022  ;          LDA #$00	;AND FORCE IT TO BE PROGRAM
03023  ;          STA INSW          
03024  
03025  0031A5  68                      PLA		;GET STATUS FLAGS RETURNED BY 'GETLN'
03026  0031A6  AA                      TAX		;SAVE IN X REGISTER
03027  0031A7  20 1C 28                JSR PUSHJ	;NOW PERFORM THE 'DO' OF THE LINE OR GROUP
03028            .WORD DO1
03029  0031AC  20 C3 2C                JSR POPIV	;RESTORE WHERE INPUT IS COMMING FROM
03030                   ;AND OLD VALUE IS IN FAC2
03031  0031AF  20 AE 2C                JSR FETVAR	;GET CURRENT VALUE IN FAC1
03032  0031B2  20 29 32                JSR SWAP	;OLD VALUE IN FAC1, CURRENT VALUE IN FAC2
03033  0031B5  20 A1 2C                JSR PUTVAR	;REPLACE OLD VALUE OF '&0' BEFORE CALL
03034  0031B8  20 29 32                JSR SWAP	;GET CURRENT VALUE OF '&0' INTO FAC1
03035  0031BB  4C 14 2E                JMP FPOPJ	;RETURN IT AS THE VALUE OF THE 'FSBR'
03036  ;
03037  ;          "FRAN" RANDOM NUMBER GENERATOR, 
03038  ;          RETURNS A FRACTION BETWEEN 0.00 AND 1.00
03039  ;
03040  0031BE  20 93 2F      FRAN      JSR INTGER	;INTEGRIZE ARGUMENT
03041  0031C1  F0 0F                   BEQ FRANC	;BRANCH IF =0, RETURN NEXT RANDOM NUMBER
03042  0031C3  10 04                   BPL FRSET	;BRANCH IF >0, SET TO REPEATABILITY
03043  0031C5  A5 76                   LDA HASH	;GET THE RANDOM NUMBER HASH VALUE
03044  0031C7  D0 02                   BNE FRNINI	;AND RANDOMITE
03045  0031C9  A9 55         FRSET     LDA #$55	;SET TO ALTERNATING ZEROS AND ONES
03046  0031CB  A2 02         FRNINI    LDX #$02	;SETUP LOOP COUNTER
03047  0031CD  95 77         FRNILP    STA SEED,X	;STORE IN SEED
03048  0031CF  CA                      DEX	;POINT TO NEXT
03049  0031D0  10 FB                   BPL FRNILP	;AND LOOP TILL DONE
03050  0031D2  A9 7F         FRANC     LDA #$7F	;SET EXPONENT OF FAC1
03051  0031D4  85 80                   STA X1
03052  0031D6  18                      CLC		;ADD K TO SEED
03053  0031D7  A5 77                   LDA SEED
03054  0031D9  69 B1                   ADC #$B1
03055  0031DB  85 83                   STA M1+2	;PUT RESULT IN LOW ORDER
03056  0031DD  85 77                   STA SEED	;ALSO THIS PART IN SEED
03057  0031DF  A5 78                   LDA SEED+1
03058  0031E1  69 0C                   ADC #$0C
03059  0031E3  85 82                   STA M1+1	;INTO MIDDLE ORDER
03060  0031E5  A5 79                   LDA SEED+2
03061  0031E7  69 1B                   ADC #$1B
03062  0031E9  29 7F                   AND #$7F	;KILL SIGN BIT
03063  0031EB  85 81                   STA M1
03064  0031ED  A5 83                   LDA M1+2
03065  0031EF  0A                      ASL  	;2^17
03066  0031F0  18                      CLC
03067  0031F1  65 83                   ADC M1+2	;2^16
03068  0031F3  18                      CLC
03069  0031F4  65 81                   ADC M1	;PLUS HIGH ORDER
03070  0031F6  85 79                   STA SEED+2	;NEW SEED
03071  0031F8  18                      CLC
03072  0031F9  A5 83                   LDA M1+2	;2^8 ADDED
03073  0031FB  65 82                   ADC M1+1
03074  0031FD  85 78                   STA SEED+1
03075  0031FF  A5 82                   LDA M1+1
03076  003201  65 79                   ADC SEED+2
03077  003203  85 79                   STA SEED+2	;SEED NOW READY FOR NEXT TIME
03078  003205  A9 00                   LDA #$00	;GET A ZERO
03079  003207  20 55 32                JSR NORM0	;NORMALIZE THE FRACTION
03080  00320A  4C 14 2E                JMP FPOPJ	;* PJMP * and return
03081  
03082  
03083  ; *** BEGIN SamCoVT SECTION
03084     
03085  ;
03086  ;            CENTRAL ROUTINES
03087  ;
03088  00320D  18            ADD       CLC
03089  00320E  A2 03                   LDX #$03	;*INDEX FOR 4 BYTE ADD
03090  003210  B5 81         ADD1      LDA M1,X               
03091  003212  75 7C                   ADC M2,X	;ADD NEXT BYTE
03092  003214  95 81                   STA M1,X
03093  003216  CA                      DEX		;TO NEXT MORE SIG BYTE
03094  003217  10 F7                   BPL ADD1	;DO ALL THREE
03095  003219  60                      RTS
03096  
03097  00321A  06 7A         MD1       ASL SIGN	;CLEAR LSB OF SIGN
03098  00321C  20 1F 32                JSR ABSWAP	;ABS VAL M1, THEN SWAP
03099  00321F  24 81         ABSWAP    BIT M1	;M1 NEG?
03100  003221  10 05                   BPL ABSWP1	;NO JUST SWAP
03101  003223  20 B8 32                JSR FCOMPL	;YES, NEGATE IT
03102  003226  E6 7A                   INC SIGN	;COMPLEMENT SIGN
03103  003228  38            ABSWP1    SEC		;FOR RETURN TO MUL/DIV
03104  ;
03105  ; SWAP FAC1 WITH FAC2
03106  ;
03107  003229  A2 05         SWAP      LDX #$05	;*FIVE BYTES TOTAL
03108  00322B  94 84         SWAP1     STY EM1,X               
03109  00322D  B5 7F                   LDA X1M1,X	;SWAP A BYTE OF FAC1 WITH
03110  00322F  B4 7A                   LDY SIGN,X	;FAC2 AND LEAVE COPY OF
03111  			;$7A is X2M1 and SIGN. 
03112  			;used SIGN, because it is defined!!!
03113  003231  94 7F                   STY X1M1,X	;M1 IN E, E+3 USED
03114  003233  95 7A                   STA SIGN,X
03115  003235  CA                      DEX		;NEXT BYTE
03116  003236  D0 F3                   BNE SWAP1	;UNTIL DONE
03117  003238  60                      RTS
03118  ;
03119  ; ROUTINE TO FLOAT 23 BITS OF MANTISSA
03120  ;
03121  003239  A9 96         FLOAT     LDA #FHALF	;SET EXPONENT TO 22 DECIMAL
03122  00323B  85 80                   STA X1                    
03123  00323D  A9 00                   LDA #$00	;ZERO INTO LOW BYTES
03124  00323F  F0 14                   BEQ NORM0	;* PBE Q* NORMALIZE IT AND RETURN
03125  ;
03126  ; DO A FAST FLOAT OF A 1-BYTE QUANTITY 
03127  ;
03128  003241  85 81         FLT8      STA M1	;STORE THE BYTE
03129  003243  A9 86                   LDA #$86	;ASSUME ALREADY SHIFTED 8 BLACES
03130  003245  85 80                   STA X1                    
03131  003247  A9 00                   LDA #$00	;GET A ZERO
03132  003249  85 82                   STA M1+1	;ZERO OUT BYTE OF MANTISSA
03133  00324B  F0 06                   BEQ FLOATC	;*P BEQ * CLEAR THIRD BYTE, NORMALIZE AND RETURN
03134  ;
03135  ; FLOAT A 16-BUT INTEGER IN M1 & M1+1 TO FAC1
03136  ; FAC2 UNAFFECTED
03137  ;
03138  00324D  A9 8E         FLT16     LDA #$8E
03139  00324F  85 80                   STA X1	;SET EXP TO 14 DEC
03140  003251  A9 00                   LDA #$00	;CLEAR LOW BYTES
03141  003253  85 83         FLOATC    STA M1+2
03142  003255  85 84         NORM0     STA M1+3	;*
03143  			;* PFALL * NORMALIZE IT AND RETURN
03144  003257  20 1E 34      NORM      JSR CHKZER	;* IS MANTISSA ZERO?
03145  00325A  D0 0F                   BNE NORML	;BRANCH IF NOT, THEN DO THE NORMALIZE SHIFTING
03146  00325C  A9 80                   LDA #$80	;YES, THEN AVOID MUCH SHIFTING BY SETTING
03147  00325E  85 80                   STA X1	;THE EXPONENT
03148  003260  60                      RTS		;AND RETURN
03149  003261  C6 80         NORM1     DEC X1
03150  003263  06 84                   ASL M1+3	;* SHIFT 4 BYTES LEFT
03151  003265  26 83                   ROL M1+2
03152  003267  26 82                   ROL M1+1
03153  003269  26 81                   ROL M1
03154  00326B  A5 81         NORML     LDA M1	;NORMALISED CHECK
03155  00326D  0A                      ASL 		;UPPER TWO BYTES UNEQUAL?
03156  00326E  45 81                   EOR M1
03157  003270  10 EF                   BPL NORM1	;NO, LOOP TILL THEY ARE
03158  003272  60            RTSN      RTS
03159  ;
03160  ;FAC2-FAC1 INTO FAC1
03161  ;
03162  003273  20 B8 32      FSUB      JSR FCOMPL	;WILL CLEAR CARRY UNLESS ZERO
03163  003276  20 86 32      SWPALG    JSR ALGNSW	;RIGHT SHIFT M1 OR SWAP ON CARRY
03164  ;
03165  ;FAC1 + FAC2 INTO FAC1
03166  ;
03167  003279  A5 7B         FADD      LDA X2                    
03168  00327B  C5 80                   CMP X1	;EXPONENTS EQUAL?
03169  00327D  D0 F7                   BNE SWPALG	;IF NOT SWAP OR ALIGN
03170  00327F  20 0D 32                JSR ADD	;ADD MANTISSAS
03171  003282  50 D3         ADDEND    BVC NORM	;IF COOL, NORMALIZE
03172  003284  70 05                   BVS RTLOG	;DV: SHIFT RIGHT-CARRY IS COOL
03173  			;SWAP IF CARRY CLEAR, ELSE SHIFT RIGHT ARITHMETICALLY
03174  003286  90 A1         ALGNSW    BCC SWAP
03175  003288  A5 81         RTAR      LDA M1	;SIGN INTO CARRY
03176  00328A  0A                      ASL 		;ARITH SHIFT
03177  00328B  E6 80         RTLOG     INC X1	;COMPENSATE FOR SHIFT
03178  00328D  F0 39                   BEQ OVFL	;EXP OUT OF RANGE
03179  00328F  A2 F8         RTLOG1    LDX #$F8	;* INDEX FOR 8 BYTE RT SHIFT
03180  003291  A9 80         ROR1      LDA #$80
03181  003293  B0 01                   BCS ROR2
03182  003295  0A                      ASL 
03183  003296  56 89         ROR2      LSR E+4,X	;*FAKE RORX E+4
03184  003298  15 89                   ORA E+4,X
03185  00329A  95 89                   STA E+4,X
03186  00329C  E8                      INX		;NEXT BYTE
03187  00329D  D0 F2                   BNE ROR1	;UNTIL DONE
03188  00329F  60                      RTS
03189  ;
03190  ;  FAC1 * FAC2 INTO FAC1
03191  ;
03192  0032A0  20 1A 32      FMUL      JSR MD1	;ABS VAL OF M1,M2
03193  0032A3  65 80                   ADC X1	;ADD EXPONENTS
03194  0032A5  20 FE 32                JSR MD2	;CHECK & PREP FOR NUL
03195  0032A8  18                      CLC
03196  0032A9  20 8F 32      MUL1      JSR RTLOG1	;SHIFT PROD AND MFYR(?) RIGHT
03197  0032AC  90 03                   BCC MUL2	;SKIP PARTIAL PROD
03198  0032AE  20 0D 32                JSR ADD	;ADD IN MCAND
03199  0032B1  88            MUL2      DEY		;NEXT ITERATION
03200  0032B2  10 F5                   BPL MUL1	;LOOP UNTIL DONE
03201  0032B4  46 7A         MDEND     LSR SIGN	;SIGN EVEN OR ODD?
03202  0032B6  90 9F         NORMX     BCC NORM	;IF EVEN NORMALIZE, ELSE COMPARE
03203  0032B8  38            FCOMPL    SEC                    
03204  0032B9  A2 04                   LDX #$04	;*4 BYTE SUBTRACT
03205  0032BB  A9 00         COMPL1    LDA #$00
03206  0032BD  F5 80                   SBC X1,X
03207  0032BF  95 80                   STA X1,X
03208  0032C1  CA                      DEX		;TO MORE SIG BYTE
03209  0032C2  D0 F7                   BNE COMPL1	;UNTIL DONE
03210  0032C4  F0 BC                   BEQ ADDEND	;FIX UP
03211  ;                              
03212  0032C6  10 46         OVCHK     BPL MD3	;IF POSITIVE EXPONENT NO CVF     
03213  0032C8  00            OVFL      BRK		;TRAP
03214            .BYTE FOVFL	;FLOATING POINT OVERFLOW
03215  ;
03216  ; DIVIDE FAC2 BY FAC1 INTO FAC1
03217  ;
03218  0032CA  20 1A 32      FDIV      JSR MD1	;ABS VALUE OF M1, M2
03219  0032CD  E5 80                   SBC X1	;SUBTRACT EXPONENTS
03220  0032CF  20 FE 32                JSR MD2	;SAVE AS RES EXP
03221  0032D2  38            DIV1      SEC
03222  0032D3  A2 03                   LDX #$03	;* FOR 4 BYTES
03223  0032D5  B5 7C         DIV2      LDA M2,X               
03224  0032D7  F5 85                   SBC E,X	;SUBTRACT BYTE OF E FROM M2
03225  0032D9  48                      PHA     
03226  0032DA  CA                      DEX		;NEXT MORE SIG BYTE
03227  0032DB  10 F8                   BPL DIV2	;UNTIL DONE
03228  0032DD  A2 FC                   LDX #$FC	;* FOR 4 BYTE COND MOVE
03229  0032DF  68            DIV3      PLA		;DIFF WAS ON STACK
03230  0032E0  90 02                   BCC DIV4	;IF M2<E DON'T RESTORE
03231  0032E2  95 80                   STA X1,X	;*
03232  0032E4  E8            DIV4      INX		;NEXT LESS SIG BYTE
03233  0032E5  D0 F8                   BNE DIV3	;UNTIL DONE
03234  0032E7  26 84                   ROL M1+3	;*
03235  0032E9  26 83                   ROL M1+2               
03236  0032EB  26 82                   ROL M1+1	;ROLL QUOTIENT LEFT
03237  0032ED  26 81                   ROL M1	;CARRY INTO LSB
03238  0032EF  06 7F                   ASL M2+3	;*
03239  0032F1  26 7E                   ROL M2+2
03240  0032F3  26 7D                   ROL M2+1	;DIVIDEND LEFT
03241  0032F5  26 7C                   ROL M2
03242  0032F7  B0 CF                   BCS OVFL	;OVF IS DUE TO UNNORM DIVISOR
03243  0032F9  88                      DEY		;NEXT ITERATION
03244  0032FA  D0 D6                   BNE DIV1	;UNTIL DONE (23 ITERATIONS)
03245  0032FC  F0 B6                   BEQ MDEND	;NORM QUOTIENT AND FIX SIGN
03246  0032FE  86 84         MD2       STX M1+3	;*
03247  003300  86 83                   STX M1+2
03248  003302  86 82                   STX M1+1	;CLEAR M1
03249  003304  86 81                   STX M1                    
03250  003306  B0 BE                   BCS OVCHK	;CHECK FOR OVFL
03251  003308  30 04                   BMI MD3	;IF NEG NO UNDERFLOW
03252  00330A  68                      PLA		;POP ONE RETURN
03253  00330B  68                      PLA
03254  00330C  90 A8                   BCC NORMX	;CLEAR X1 AND RETURN
03255  00330E  49 80         MD3       EOR #$80	;COMPL. SIGN OF EXPONENT
03256  003310  85 80                   STA X1                    
03257  003312  A0 1F                   LDY #$1F	;COUNT FOR 31 (/), 32 (*) ITERATIONS
03258  003314  60                      RTS
03259  ;
03260  ; FAC1 TO 23 BIT SIGNED INTEGER IN M1 (HIGH), M1+1 (MIDDLE), M1+2 (LOW) 
03261  ;
03262  003315  20 88 32      FIX1      JSR RTAR	;SHIFT MANTISSA, INC EXPONENT
03263  003318  A5 80         FIX       LDA X1	;CHECK EXP
03264  00331A  C9 96                   CMP #FHALF	;IS EXP #22?
03265  00331C  D0 F7                   BNE FIX1	;NO, SHIFT MORE
03266  00331E  60                      RTS	;DONE
03267  ;
03268  ;            FLOATING POINT OUTPUT ROUTINE
03269  ;
03270  00331F  A5 81         FPRNT     LDA M1	;SAVE THE SIGN OF THE NUMBER
03271  003321  85 8A                   STA SIGNP	;FOR LATER REFERENCE
03272  003323  20 F7 33                JSR ABSF1	;DEAL ONLY WITH ABSOLUTE VALUE
03273  003326  20 1E 34                JSR CHKZER	;IS NUMBER = 0?
03274  003329  D0 05                   BNE FPR0	;BRANCH IF NOT, THEN TRY TO DIVIDE DOWN
03275  00332B  85 8D                   STA K		;YES, SOME FLAVOR OF ZERO. INDICATE THAT WE
03276  00332D  48                      PHA		;DID NOT HAVE TO DIVIDE AS ALREADY <1
03277  00332E  F0 43                   BEQ FPR4A	;AND PUNT DIVIDE DOWN AND ROUNDING CODE
03278  003330  A5 80         FPR0      LDA X1	;GET THE EXPONENT
03279  003332  48                      PHA		;SAVE FOR LATER REFERENCE
03280  003333  A9 00                   LDA #$00	;ZERO COUNTER WHICH COUNTS HOW MANY TIMES
03281  003335  85 8D                   STA K		;WE HAD TO DIVIDE TO GET NUMBER <1
03282  003337  24 80         FPR1      BIT X1	;IS NUMBER <1?
03283  003339  10 07                   BPL FPR2	;BRANCH IF YES
03284  00333B  20 11 34                JSR DIV10	;NO, THEN DIVIDE BY 10
03285  00333E  E6 8D                   INC K		;COUNT THE FACT WE DID
03286  003340  10 F5                   BPL FPR1	;AND CHECK AGAIN
03287  003342  20 79 28      FPR2      JSR PHFAC1	;SAVE NUMBER (NOW <1) ON STACK
03288  003345  A2 96                   LDX #FHALF	;GET THE CONSTANT .5
03289  003347  A0 80                   LDY #X1	;INTO FAC1
03290  003349  20 FF 33                JSR MOVXY
03291  00334C  18                      CLC
03292  00334D  A5 8D                   LDA K		;ROUNDING FACTOR IS .5*10^-(K+N)
03293  00334F  65 90                   ADC N
03294  003351  85 8E                   STA L
03295  003353  F0 0F                   BEQ FPR4	;BRANCH IF WE NEED .5*10^0
03296  003355  A9 09                   LDA #$09	;* IS FACTOR BEYOND OUR PRECISSION?
03297  003357  C5 8E                   CMP L
03298  003359  10 02                   BPL FPR3	;BRANCH IF NOT, THEN ROUNDING FACTOR IS OK
03299  00335B  85 8E                   STA L		;YES, THEN APPLY ROUNDING TO LEAST SIG FIG
03300  00335D  20 11 34      FPR3      JSR DIV10	;NOW SHIFT .5 INTO PROPER POSITION
03301  003360  C6 8E                   DEC L
03302  003362  D0 F9                   BNE FPR3
03303  003364  20 9A 28      FPR4      JSR PLFAC2	;GET NUMBER INTO FAC2
03304  003367  20 79 32                JSR FADD	;ADD THE ROUNDING FACTOR
03305  00336A  24 80                   BIT X1	;IS IT STILL <1?
03306  00336C  10 05                   BPL FPR4A	;BRANCH IF IT IS
03307  ;
03308  ;original ProgExch/6502Grp code has more lines here:
03309  ;          pla          ;no then get original exponent
03310  ;          bmi fpr4a    ;branch if original number >1 do nothing
03311  ;          lda x1       ;we gained a sig fig in rounding, get new exp
03312  ;fpr41     pha          ;save exponent for later
03313  ;
03314  00336E  20 11 34                JSR DIV10	;SCALE NUMBER BACK DOWN
03315  003371  E6 8D                   INC K		;AND INDICATE WE HAD TO
03316  003373  38            FPR4A     SEC
03317  003374  A5 8F                   LDA M		;NOW CONSULATE NUMBER OF LEADING BLANKS NEEDED
03318  003376  E5 8D                   SBC K
03319  003378  85 8E                   STA L		;INTO L
03320  00337A  68                      PLA		;GET EXPONENT OF ORIGINAL NUMBER BACK
03321  00337B  48                      PHA		;SAVE AGAIN FOR LATER
03322  00337C  30 02                   BMI FPR4B	;BRANCH IF ORIGINAL NUMBER IS <1?
03323  00337E  C6 8E                   DEC L		;IT WAS <1. LEAVE ROOM FOR LEADINF 0
03324  003380  24 8A         FPR4B     BIT SIGNP	;WAS NUMBER NEGATIVE
03325  003382  10 02                   BPL FPR5	;BRANCH IF NOT
03326  003384  C6 8E                   DEC L		;YES, THEN LEAVE ROOM FOR A MINUS SIGN
03327  003386  A5 8E         FPR5      LDA L		;ANY BLANKS TO OUTPUT?
03328  003388  30 09                   BMI FPR7	;BRANCH IF NOT
03329  00338A  F0 07                   BEQ FPR7	;BRANCH IF NOT
03330  00338C  20 00 29      FPR6      JSR PSPACE	;OUTPUT A BLANK
03331  00338F  C6 8E                   DEC L		;COUNT IT
03332  003391  D0 F9                   BNE FPR6	;AND LOOP TILL ALL HAVE BENN OUTPUT
03333  003393  24 8A         FPR7      BIT SIGNP	;WAS NUMBER NEGATIVE?
03334  003395  10 05                   BPL FPR7A	;BRANCH IF NOT
03335  003397  A9 2D                   LDA #$2D	;YES, OUTPUT A LEADING "-"
03336  003399  20 02 29                JSR PRINTC	;AND FALL INTO NEXT PAGE
03337  00339C  68            FPR7A     PLA		;GET EXPONENT OF THE ORIGINAL NUM BACK AGAIN
03338  00339D  30 03                   BMI FPR8	;BRANCH IF NOT <1
03339  00339F  20 C8 33                JSR PZERO	;YES, THEN GIVE A LEADING ZERO
03340  			;(PEOPLE LIKE IT!)
03341  			;(IT'S ALSO A PAIN TO CHECK FOR!)
03342  ;                                        
03343  ; NOW FOR THE MEAT OF IT
03344  ;
03345  0033A2  A9 09         FPR8      LDA #$09	;* GET MAX NUMBER OF SIG FIGS
03346  0033A4  85 8E                   STA L		;INTO L
03347  0033A6  A5 8D         FPR9      LDA K		;ANY OUTPUT BEFORE DECIMAL?
03348  0033A8  F0 07                   BEQ FPR11	;BRANCH IF NO MORE
03349  0033AA  20 C4 33      FPR10     JSR MDO	;OUTPUT A DIGIT BEFORE DECIMAL
03350  0033AD  C6 8D                   DEC K
03351  0033AF  D0 F9                   BNE FPR10	;AND LOOK TILL ALL DONE
03352  0033B1  A5 90         FPR11     LDA N		;GET NUMBER AFTER DECIMAL POINT
03353  0033B3  85 8D                   STA K		;INTO K
03354  0033B5  F0 0C                   BEQ FPRET	;BRANCH IF NONE TO OUTPUT
03355  0033B7  A9 2E                   LDA #$2E	;THERE ARE SOME TO OUTPUT,
03356  0033B9  20 02 29                JSR PRINTC	;PRINT THE DECIMAL POINT
03357  0033BC  20 C4 33      FPR12     JSR MDO	;OUTPUT A DIGIT AFTER DECIMAL
03358  0033BF  C6 8D                   DEC K		;AND LOOP
03359  0033C1  D0 F9                   BNE FPR12	;TILL ALL OUTPUT
03360  0033C3  60            FPRET     RTS		;RETURN FROM 'FPRNT' FAC1 IS DESTROYED!
03361  ;
03362  ; MPY BY 10, PRINT INTEGER AND SUBTRACT IT
03363  ;
03364  0033C4  C6 8E         MDO       DEC L		;HAVE WE OUTPUT ALL DIGITS OF SIGNIFICANCE?
03365  0033C6  10 05                   BPL MDO1	;BRANCH IF NOT, OUTPUT THIS ONE
03366  0033C8  A9 30         PZERO     LDA #$30	;YES, THEN OUTPUT A ZERO
03367  0033CA  4C 02 29                JMP PRINTC	;* PJMP * AND RETURN
03368  0033CD  A2 91         MDO1      LDX #FTEN               
03369  0033CF  A0 7B                   LDY #X2
03370  0033D1  20 FF 33                JSR MOVXY
03371  0033D4  20 A0 32                JSR FMUL
03372  0033D7  A2 80         FDONE     LDX #X1	;SAVE FAC1
03373  0033D9  A0 A0                   LDY #T
03374  0033DB  20 FF 33                JSR MOVXY
03375  0033DE  20 18 33                JSR FIX
03376  0033E1  A5 83                   LDA M1+2	;MAKE ASCII
03377  0033E3  29 0F                   AND #$0F
03378  0033E5  09 30                   ORA #$30
03379  0033E7  20 02 29                JSR PRINTC
03380  0033EA  20 39 32                JSR FLOAT	;NOW SUBTRACT IT
03381  0033ED  A2 A0                   LDX #T		;RESTORE TO FAC2
03382  0033EF  A0 7B                   LDY #X2
03383  0033F1  20 FF 33                JSR MOVXY
03384  0033F4  4C 73 32                JMP FSUB	;PJUMP
03385  
03386  ;
03387  ;   UTILITIES FOR FPRNT
03388  ;
03389  0033F7  24 81         ABSF1     BIT M1
03390  0033F9  10 03                   BPL ABSFE
03391  0033FB  20 B8 32                JSR FCOMPL
03392  0033FE  60            ABSFE     RTS
03393  0033FF  CA            MOVXY     DEX
03394  003400  8E 0A 34                STX MOV1+1
03395  003403  88                      DEY
03396  003404  8C 0C 34                STY MOV2+1
03397  003407  A2 05                   LDX #$05	;*
03398  003409  B5 00         MOV1      LDA $00,X
03399  00340B  95 00         MOV2      STA $00,X
03400  00340D  CA                      DEX
03401  00340E  D0 F9                   BNE MOV1
03402  003410  60                      RTS
03403  ;
03404  003411  20 29 32      DIV10     JSR SWAP
03405  003414  A2 91                   LDX #FTEN
03406  003416  A0 80                   LDY #X1
03407  003418  20 FF 33                JSR MOVXY
03408  00341B  4C CA 32                JMP FDIV	;*PJMP*
03409  ;
03410  00341E  A5 81         CHKZER    LDA M1	;GET HIGH ORDER MANTISSA
03411  003420  05 82                   ORA M1+1	;'OR' ALL BYTES OF MANTISSA TOGETHER
03412  003422  05 83                   ORA M1+2
03413  003424  05 84                   ORA M1+3	;*
03414  003426  60                      RTS		;RETURN WITH Z=1 IF MANTISSA IS =0.
03415  ;
03416  ;   'FLOATING POINT INPUT ROUTINE'
03417  ;
03418  003427  A9 00         FINP      LDA #$00
03419  003429  85 8A                   STA SIGNP	;SET SIGN +
03420  00342B  85 8B                   STA DPFLG	;RESET DP FLAG
03421  00342D  85 8C                   STA GOTFLG	;NO INPUT YET
03422  00342F  85 8D                   STA K		;NO DIGITS AFTER DECIMAL POINT
03423  003431  85 7B                   STA X2	;ZERO RESULT
03424  003433  85 7C                   STA M2
03425  003435  85 7D                   STA M2+1
03426  003437  85 7E                   STA M2+2
03427  003439  85 7F                   STA M2+3	;*
03428  00343B  A5 2B                   LDA CHAR	;GET CHARACTER
03429  00343D  C9 2B                   CMP #$2B	;IGNORE +'S
03430  00343F  F0 06                   BEQ FINP3               
03431  003441  C9 2D                   CMP #$2D	;'-' FLAG IF NEGATIVE
03432  003443  D0 05                   BNE FINP2
03433  003445  E6 8A                   INC SIGNP
03434  003447  20 92 29      FINP3     JSR GETC	;ANOTHER CHAR
03435  00344A  C9 30         FINP2     CMP #$30	;'0' IS IT A DIGIT?
03436  00344C  90 24                   BCC FINP4	;NO
03437  00344E  C9 3A                   CMP #$3A	;':' MAYBE...
03438  003450  B0 20                   BCS FINP4	;NO
03439  003452  A2 91                   LDX #FTEN
03440  003454  A0 80                   LDY #X1
03441  003456  20 FF 33                JSR MOVXY	;FAC2*10.0=FAC1
03442  003459  20 A0 32                JSR FMUL
03443  00345C  20 29 32                JSR SWAP	;INTO FAC2
03444  00345F  E6 8C                   INC GOTFLG	;YES, WE HAVE INPUT
03445  003461  A5 2B                   LDA CHAR
03446  003463  29 0F                   AND #$0F	;MAKE NUMERIC
03447  003465  20 41 32                JSR FLT8	;AND FLOAT IT
03448  003468  20 79 32                JSR FADD	;ADD TO PARTIAL RESULT
03449  00346B  20 29 32                JSR SWAP	;BACK INTO FAC2
03450  00346E  E6 8D                   INC K		;COUNT DIGITS AFTER DECIMAL POINT
03451  003470  D0 D5                   BNE FINP3	;GET MORE
03452  003472  C9 2E         FINP4     CMP #$2E	;DECIMAL POINT?
03453  003474  D0 0C                   BNE FINP5	;NO, END OF #
03454  003476  A5 8B                   LDA DPFLG	;YES, ALREADY GOT ONE?
03455  003478  D0 08                   BNE FINP5	;THEN END OF #
03456  00347A  E6 8B                   INC DPFLG	;ELSE FLAG GOT ONE
03457  00347C  A9 00                   LDA #$00
03458  00347E  85 8D                   STA K		;RESET K
03459  003480  F0 C5                   BEQ FINP3	;AND GET FRACTION
03460  ;
03461  ; HERE ON END OF NUMBER
03462  ;
03463  003482  20 29 32      FINP5     JSR SWAP	;RESULT TO FAC1
03464  003485  A5 8B                   LDA DPFLG	;ANY DECIMAL POINTS?
03465  003487  F0 0B                   BEQ FINP6	;NO, ITS OK
03466  003489  A5 8D         FINP7     LDA K		;ELSE ADJUST
03467  00348B  F0 07                   BEQ FINP6	;ADJUST DONE
03468  00348D  20 11 34                JSR DIV10	;RESULT/10
03469  003490  C6 8D                   DEC K		;K TIMES
03470  003492  D0 F5                   BNE FINP7
03471  003494  A5 8A         FINP6     LDA SIGNP	;NOW ADD SIGN
03472  003496  F0 03                   BEQ FINP8	;WAS POS
03473  003498  20 B8 32                JSR FCOMPL	;WAS NEG
03474  00349B  4C 57 32      FINP8     JMP NORM	;PJUMP TO NORMALIZE
03475  ;
03476  ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
03477  ;
03478  ;     Here begins (again) code restoration by dhh
03479  ;
03480  ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
03481  ;
03482  ; from here, the Aresco version of V3D code (TTY) completely differs from
03483  ; the ProgramExchange/6502 Group TIM-monitor code upon which it is based.
03484  ; PE code occupies $24A6 to $24D0 (here $349E to $34E7), and seems to be
03485  ; related to video terminal output.  What follows here are KIM-1-specific
03486  ; initialization and I/O routines from the Aresco version of V3D.  -dhh 
03487  ;
03488  00349E  A9 E0         CONINI    LDA #$E0	; init BRK vector as $2CE0
03489  0034A0  8D FE 17                STA $17FE
03490  0034A3  A9 2C                   LDA #$2C
03491  0034A5  8D FF 17                STA $17FF
03492  0034A8  18                      CLC
03493  0034A9  60                      RTS
03494  0034AA  20 A0 1E      TVOUT     JSR $1EA0	; TTY OUTCH in KIM-1 ROM
03495  0034AD  18                      CLC
03496  0034AE  60                      RTS
03497  0034AF  E6 76         KEYIN     INC HASH      ; bump random seed
03498  0034B1  2C 40 17                BIT $1740     ; (R)RIOT I/O register A
03499  0034B4  30 F9                   BMI KEYIN
03500  0034B6  AD 42 17                LDA $1742     ; (R)RIOT I/O register B
03501  0034B9  29 FE                   AND #$FE
03502  0034BB  8D 42 17                STA $1742
03503  0034BE  20 5A 1E                JSR $1E5A     ; GETCH in KIM-1 ROM
03504  0034C1  48                      PHA
03505  0034C2  AD 42 17                LDA $1742     ; the echo defeat
03506  0034C5  29 FE                   AND #$FE
03507  0034C7  09 01                   ORA #$01
03508  0034C9  8D 42 17                STA $1742
03509  0034CC  68                      PLA
03510  0034CD  18                      CLC
03511  0034CE  60                      RTS          ; 
03512  ;
03513  ;  The next bytes do not appear to be used for anything.
03514  ;  Perhaps leftover from Aresco conversion of Prog/Exch
03515  ;  version for KIM-1 (???).
03516  ;
03517          .BYTE $00,$43,$11,$51,$11,$11,$17,$01,$01,$11,$41
03518          .BYTE $53,$01,$51,$51,$11,$53,$EE,$CE,$FE,$EE,$EA
03519          .BYTE $EE,$06,$FE
03520  ;          BRK
03521  ;          ???                ;01000011 'C'
03522  ;          ORA ($51),Y
03523  ;          ORA ($11),Y
03524  ;          ???                ;00010111
03525  ;          ORA ($01,X)
03526  ;          ORA ($41),Y
03527  ;          ???                ;01010011 'S'
03528  ;          ORA ($51,X)
03529  ;          EOR ($11),Y
03530  ;          ???                ;01010011 'S'
03531  ;          INC $FECE
03532  ;          INC $EEEA
03533  ;          ASL $FE
03534  ;
03535  
03536  ;     SPECIAL TERMINATOR CHAR TABLE (see P/E code at $2401)
03537  ;
03538  TRMTAB   .BYTE ' '     ; LEVEL 0 (SPACE)
03539           .BYTE '+'     ; LEVEL 1 '+'
03540           .BYTE '-'     ; LEVEL 2 '-'
03541           .BYTE '/'     ; LEVEL 3 '/'
03542           .BYTE '*'     ; LEVEL 4 '*'
03543           .BYTE '^'     ; LEVEL 5 '^'
03544           .BYTE '('     ; LEVEL 6 '('
03545           .BYTE ')'     ; LEVEL 7 ')'  (START OF DELIMITERS)
03546           .BYTE ','     ; LEVEL 8 ','
03547           .BYTE ';'     ; LEVEL 9 ';'
03548           .BYTE $0D     ; LEVEL 10 'CR'
03549           .BYTE '='     ; LEVEL 11 '=' (TERMINATOR FOR 'SET')
03550           .BYTE LINCHR  ; LEVEL 1 '_'  ('LINE-DELETE IS HERE SO
03551                         ;             'ASK' CAN ALLOW RE-TYPEIN)
03552  ;
03553  ; here TRMAX=12 is defined in the ProgExch code
03554  ;
03555  ;      THESE FUNCTION DISPATCH TABLES MAY BE PATCHED BY A USER
03556  ;      TO CALL HIS OWN FUNCTIONS.
03557  ;
03558  ;      TABLE OF 'HASH CODES' FOR FUNCTION NAMES
03559  ;
03560  FUNTAB    .BYTE HFABS     ; ABSOLUTE VALUE FUNCTION
03561            .BYTE HFOUT     ; CHARACTER OUTPUT FUNCTION
03562            .BYTE HFRAN     ; RANDOM NUMBER FUNCTION
03563            .BYTE HFINT     ; INTEGERIZE FUNCTION
03564            .BYTE HFINR     ; INTEGERIZE WITH ROUNDING FUNCTION
03565            .BYTE HFIDV     ; INPUT DEVICE FUNCTION
03566            .BYTE HFODV     ; OUTPUT DEVICE FUNCTION
03567            .BYTE HFCHR     ; CHARACTER INPUT FUNCTION
03568            .BYTE HFCUR     ; CONSOLE CURSOR ADDRESSING FUNCTION
03569            .BYTE HFECH     ; ECHO CONTROL FUNCTION
03570            .BYTE HFPIC     ; SOFTWARE PRIORITY INTERRUPT FUNCTION
03571            .BYTE HFMEM     ; MEMORY EXAMINE-DEPOSIT FUNCTION
03572            .BYTE HFINI     ; INITIALIZE INPUT DEVICE FUNCTION
03573            .BYTE HFINO     ; INITIALIZE OUTPUT DEVICE FUNCTION
03574            .BYTE HFCLI     ; CLOSE INPUT DEVICE FUNCTION
03575            .BYTE HFCLO     ; CLOSE OUTPUT DEVICE FUNCTION
03576            .BYTE HFCON     ; SET CONSOLE DEVICE FUNCTION
03577            .BYTE HFSBR     ; 'SUBROUTINE' CALL FUNCTION
03578            .BYTE HFISL     ; INITIALIZE STRING LENGTH FUNCTION
03579            .BYTE HFSTI     ; STRING INPUT FUNCTION
03580            .BYTE HFSTO     ; STRING OUTPUT FUNCTION
03581            .BYTE HFSLK     ; STRING "LOOK" FUNCTION
03582            .BYTE 0	  ; SPARE LOCS FOR HACKERS
03583            .BYTE 0
03584            .BYTE 0
03585            .BYTE 0
03586            .BYTE 0
03587            .BYTE 0          ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03588  ;
03589  ;     FUNCTION DISPATCH TABLES - HIGH BYTE
03590  ;
03591  FUNADH     .BYTE >FABS     ; FABS
03592             .BYTE >FOUT     ; FOUT
03593             .BYTE >FRAN     ; FRAN
03594             .BYTE >FINT     ; FINT
03595             .BYTE >FINR     ; FINR
03596             .BYTE >FIDV     ; FIDV
03597             .BYTE >FODV     ; FODV
03598             .BYTE >FCHR     ; FCHR
03599             .BYTE >FCUR     ; FCUR
03600             .BYTE >FECH     ; FECH
03601             .BYTE >FPIC     ; FPIC
03602             .BYTE >FMEM     ; FMEM
03603             .BYTE >FINI     ; FINI
03604             .BYTE >FINO     ; FINO
03605             .BYTE >FCLI     ; FCLI
03606             .BYTE >FCLO     ; FCLO
03607             .BYTE >FCON     ; FCON
03608             .BYTE >FSBR     ; FSBR
03609             .BYTE >FISL     ; FISL
03610             .BYTE >FSTI     ; FSTI
03611             .BYTE >FSTO     ; FSTO
03612             .BYTE >FSLK     ; FSLK
03613             .BYTE $00       ; SPACE FOR HACKERS
03614  L3528      .BYTE 0
03615             .BYTE 0
03616             .BYTE 0
03617             .BYTE 0
03618             .BYTE 0          ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03619  ;
03620  ;     FUNCTION DISPATCH TABLES - LOW ORDER ADDR BYTE
03621  ;
03622  FUNADL     .BYTE <FABS     ; FABS
03623             .BYTE <FOUT     ; FOUT
03624             .BYTE <FRAN     ; FRAN
03625             .BYTE <FINT     ; FINT
03626             .BYTE <FINR     ; FINR
03627             .BYTE <FIDV     ; FIDV
03628             .BYTE <FODV     ; FODV
03629             .BYTE <FCHR     ; FCHR
03630             .BYTE <FCUR     ; FCUR
03631             .BYTE <FECH     ; FECH
03632             .BYTE <FPIC     ; FPIC
03633             .BYTE <FMEM     ; FMEM
03634             .BYTE <FINI     ; FINI
03635             .BYTE <FINO     ; FINO
03636             .BYTE <FCLI     ; FCLI
03637             .BYTE <FCLO     ; FCLO
03638             .BYTE <FCON     ; FCON
03639             .BYTE <FSBR     ; FSBR
03640             .BYTE <FISL     ; FISL
03641             .BYTE <FSTI     ; FSTI
03642             .BYTE <FSTO     ; FSTO
03643             .BYTE <FSLK     ; FSLK
03644  L3543      .BYTE 0             ; SPACE FOR HACKERS
03645             .BYTE 0
03646             .BYTE 0
03647             .BYTE 0
03648             .BYTE 0
03649             .BYTE 0               ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03650  ;
03651  ;     COMMAND DISPATCH TABLES
03652  ;
03653  ;     THESE COMMAND DISPATCH TABLES MAY BE PATCHED BY USER
03654  ;     TO ADD HIS OWN SPECIAL COMMAND HANDLERS
03655  ;
03656  ;     COMMAND CHARACTER TABLE
03657  ;
03658  
03659  COMTAB     .BYTE 'S'     ; 'S' SAVE COMMAND
03660             .BYTE 'I'     ; 'I' IF COMMAND
03661             .BYTE 'D'     ; 'D' DO COMMAND
03662             .BYTE 'O'     ; 'O' ON COMMAND
03663             .BYTE 'G'     ; 'G' GOTO COMMAND
03664             .BYTE 'F'     ; 'F' FOR COMMAND
03665             .BYTE 'R'     ; 'R' RETURN COMMAND
03666             .BYTE 'T'     ; 'T' TYPE COMMAND
03667             .BYTE 'A'     ; 'A' ASK COMMAND
03668             .BYTE 'C'     ; 'C' COMMENT COMMAND
03669             .BYTE 'E'     ; 'E' ERASE COMMAND
03670             .BYTE 'W'     ; 'W' WRITE COMMAND
03671             .BYTE 'M'     ; 'M' MODIFY COMMAND
03672             .BYTE 'Q'     ; 'Q' QUIT COMMAND
03673             .BYTE 0       ; SPACE FOR HACKERS
03674             .BYTE 0
03675             .BYTE 0
03676             .BYTE 0
03677             .BYTE 0
03678             .BYTE 0          ; MUST HAVE ONE ZERO TO END TABLE!
03679  ; 
03680  ;     HIGH ORDER ADDR OF COMMAND HANDLING ROUTINE
03681  ;
03682  COMADH     .BYTE >SET         ; SET    
03683             .BYTE >IF          ; IF     
03684             .BYTE >DO          ; DO     
03685             .BYTE >ON          ; ON     
03686             .BYTE >GOTO        ; GOTO   
03687             .BYTE >FOR         ; FOR    
03688             .BYTE >RETURN      ; RETURN 
03689             .BYTE >TYPE        ; TYPE   
03690             .BYTE >ASK         ; ASK    
03691             .BYTE >COMMNT      ; COMMENT
03692             .BYTE >ERASE       ; ERASE  
03693             .BYTE >WRITE       ; WRITE  
03694             .BYTE >MODIFY      ; MODIFY 
03695             .BYTE >QUIT        ; QUIT   
03696             .BYTE 0            ; SPACE FOR HACKERS
03697             .BYTE 0
03698             .BYTE 0
03699             .BYTE 0          ; MUST HAVE ZERO TO END TABLE!
03700  ;
03701  ;     LOW ORDER ADDR OF COMMAND HANDLING ROUTINE
03702  ;
03703  COMADL     .BYTE <SET         ; SET
03704             .BYTE <IF          ; IF
03705             .BYTE <DO          ; DO
03706             .BYTE <ON          ; ON
03707             .BYTE <GOTO        ; GOTO
03708             .BYTE <FOR         ; FOR
03709             .BYTE <RETURN      ; RETURN
03710             .BYTE <TYPE        ; TYPE
03711             .BYTE <ASK         ; ASK
03712             .BYTE <COMMNT      ; COMMENT
03713             .BYTE <ERASE       ; ERASE
03714             .BYTE <WRITE       ; WRITE
03715             .BYTE <MODIFY      ; MODIFY
03716             .BYTE <QUIT        ; QUIT
03717             .BYTE 0               ; SPACE FOR HACKERS
03718             .BYTE 0
03719             .BYTE 0
03720             .BYTE 0          ; MUST HAVE A ZERO TO END TABLE!
03721  ;
03722  ;     DISPATCH TABLE FOR 'EVBOP' ROUTINE
03723  ;
03724  ; two definitions here in the Prog/Exch code:
03725  ; at $2569 (3580 here) .DEF EVDSPH=.-1  and
03726  ; $256E (3585) .DEF EVDSPL=.-1
03727  ;
03728    3580              EVDSPH = * - 1
03729             .BYTE >FADD       ; FADD  
03730             .BYTE >FSUB       ; FSUB  
03731             .BYTE >FDIV       ; FDIV  
03732             .BYTE >FMUL       ; FMUL  
03733             .BYTE >EVPOWR     ; EVPOWR
03734  ;
03735    3585              EVDSPL = * - 1
03736             .BYTE <FADD       ; FADD
03737             .BYTE <FSUB       ; FSUB
03738             .BYTE <FDIV       ; FDIV
03739             .BYTE <FMUL       ; FMUL
03740             .BYTE <EVPOWR     ; EVPOWR
03741  ;
03742  ;          TABLES USED BY SOFTWARE INTERRUPT SYSTEM
03743  ;
03744  ; TABLE OF GROUP NUMBERS OF LINES TO 'DO' WHEN EVENT HAPPENS
03745  ; ONE ENTRY FOR EACH OF THE 8 PRIORITY CHANNELS
03746  ;
03747  INTGRP     .BYTE 0
03748             .BYTE 0
03749             .BYTE 0
03750             .BYTE 0
03751             .BYTE 0
03752             .BYTE 0
03753             .BYTE 0
03754             .BYTE 0
03755             .BYTE 0
03756  ;
03757  ; TABLE OF STEP NUMBERS OF LINES TO 'DO' WHEN AN EVENT HAPPENS
03758  ;
03759  INTLIN     .BYTE 0
03760             .BYTE 0
03761             .BYTE 0
03762             .BYTE 0
03763             .BYTE 0
03764             .BYTE 0
03765             .BYTE 0
03766             .BYTE 0
03767             .BYTE 0
03768  ;
03769  ; 'AND' MASKS USED TO DISABLE ALL BUT HIGHER PRIO CHANNELS.
03770  ; INDEXED BY CURRENT CHANNEL NUMBER
03771  ;
03772  INTTAB    .BYTE $FF     ; CHANNEL 0 ENABLES THEM ALL
03773            .BYTE $FE
03774            .BYTE $FC
03775            .BYTE $F8
03776            .BYTE $F0
03777            .BYTE $E0
03778            .BYTE $C0
03779            .BYTE $80
03780            .BYTE $00     ; CHANNEL 8 ENABLES NONE
03781  ;
03782  ; BIT TABLE CONTAINING A SINGLE BIT FOR EACH CHANNEL POSITION
03783  ;
03784  BITTAB    .BYTE $00
03785            .BYTE $01
03786            .BYTE $02
03787            .BYTE $04
03788            .BYTE $08
03789            .BYTE $10
03790            .BYTE $20
03791            .BYTE $40
03792            .BYTE $80
03793  ;
03794  ;     DISPATCH TABLE FOR I/O DEVICE NUMBERS
03795  ;
03796  ; handwritten note in P/E source: "READ/WRITE"
03797  ; Two definitions made here:
03798  ;     .DEF IDEWVM=3     .DEF ODEVM=3  ; MAX # OF I/O DEVICES
03799    0003              IDEVM = 3                  ; Original was IDEWVM - changed to IDEVM (Input DEVice Max)
03800    0003              ODEVM = 3
03801      
03802  ;
03803  IDSPH     .BYTE >KEYIN     ; DEVICE 0 - KEYBOARD INPUT ROUTINE
03804            .BYTE 0          ; DEVICE 1 - CASSETTE #0 INPUT ROUTINE
03805            .BYTE 0          ; DEVICE 2 - CASSETTE #1 INPUT ROUTINE
03806            .BYTE 0          ; SPACE FOR HACKERS
03807            .BYTE 0
03808  IDSPL     .BYTE <KEYIN
03809            .BYTE 0
03810            .BYTE 0
03811            .BYTE 0
03812            .BYTE 0
03813  ODSPH     .BYTE >TVOUT     ; DEVICE 0 - TV OUTPUT ROUTINE
03814            .BYTE 0          ; DEVICE 1 - CASSETTE #0 OUTPUT ROUTINE
03815            .BYTE 0          ; DEVICE 2 - CASSETTE #1 OUTPUT ROUTINE
03816            .BYTE 0          ; SPACE FOR HACKERS
03817            .BYTE 0
03818  ODSPL     .BYTE <TVOUT
03819            .BYTE 0
03820            .BYTE 0
03821            .BYTE 0
03822            .BYTE 0
03823  ;
03824  ; handwritten note in P/E source: "INITIALIZE IN/OUT"
03825  ;
03826  INIAH      .BYTE >RTS1     ; DON'T NEED TO INTIALIZE KEYBOARD
03827             .BYTE >RTS1     ; USER MUST PROVIDE ROUTINE
03828             .BYTE >RTS1     ;
03829             .BYTE $00       ; SPACE FOR HACKERS
03830             .BYTE $00
03831  ;
03832  INIAL      .BYTE <RTS1
03833             .BYTE <RTS1
03834             .BYTE <RTS1
03835             .BYTE 0
03836             .BYTE 0
03837  ;
03838  INOAH      .BYTE >CONINI	; USE TO STUFF VECTORS WITH BREAK HANDLERS
03839             .BYTE $29		; USER PROVIDES ROUTINES
03840             .BYTE $29
03841             .BYTE 0
03842             .BYTE 0
03843  ;
03844  INOAL      .BYTE <CONINI
03845             .BYTE $40
03846             .BYTE $40
03847             .BYTE 0
03848             .BYTE 0
03849  ;
03850  ; handwritten note in P/E source: "CLOSE IN/OUT"
03851  ;
03852  CLIAH     .BYTE >RTS1   ; KEYBOARD DOESN'T NEED A CLOSE ROUTINE
03853            .BYTE >RTS1   ; USER PROVIDES ROUTINE
03854            .BYTE >RTS1   ;
03855            .BYTE $00     ; SPACE FOR HACKERS
03856            .BYTE $00     ; SPACE FOR HACKERS
03857  ;
03858  CLIAL     .BYTE <RTS1
03859            .BYTE <RTS1
03860            .BYTE <RTS1
03861            .BYTE 0
03862            .BYTE 0
03863  ;
03864  CLOAH     .BYTE >RTS1	; TV DOESN'T NEED A CLOSE ROUTINE
03865            .BYTE >RTS1	; USER PROVIDES ROUTINE
03866            .BYTE >RTS1	;
03867            .BYTE $00	; SPACE FOR HACKERS
03868            .BYTE $00  
03869  ;                    
03870  CLOAL     .BYTE <RTS1
03871            .BYTE <RTS1
03872            .BYTE <RTS1
03873            .BYTE 0
03874            .BYTE 0
03875  
03876  ; SamCoVT - Zero page initialization routine from focal 6502 user notes
03877  ; patched in here.
03878    0000              ZPAGE = 0
03879    00BF              LENGTH = $BF            ; NUMBER OF BYTES
03880    2000              STARTF = $2000
03881  003F00                        .ORG $3F00
03882  ; CSTART (address $3F00) will now be the new cold start address.
03883  CSTART
03884  003F00  A2 00                 LDX #0          ; INIT THE LOOP COUNTER
03885  ZLOOP
03886  003F02  BD 10 3F              LDA ZSTORE,X    ; START MOVING DATA
03887  003F05  95 00                 STA ZPAGE,X
03888  003F07  E8                    INX
03889  003F08  E0 C0                 CPX #LENGTH+1
03890  003F0A  D0 F6                 BNE ZLOOP
03891  003F0C  4C 00 20              JMP STARTF      ; PAGE IS SET UP
03892                          ; GO TO FOCAL
03893  
03894  003F10                        .ORG $3F10
03895  ZSTORE
03896          .BYTE $53, $53, $4C, $E0, $2C, $4C, $DF, $2C, $00, $00, $00, $00, $00, $00, $00, $00        
03897          .BYTE $00, $62, $7B, $66, $EB, $6B, $3A, $7B, $6A, $6B, $6B, $7B, $FB, $7B, $6B, $6B
03898          .BYTE $00, $00, $00, $00, $00, $00, $FF, $00, $00, $01, $00, $00, $00, $00, $00, $E0
03899          .BYTE $3F, $FE, $3F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $FF, $3F
03900          .BYTE $FF, $3F, $FF, $3F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
03901          .BYTE $00, $00, $00, $00, $5F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $4C, $00
03902          .BYTE $00, $6C, $00, $00, $48, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $C0
03903          .BYTE $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
03904          .BYTE $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05
03905          .BYTE $05, $83, $50, $00, $00, $00, $7F, $40, $00, $00, $00, $80, $40, $00, $00, $00
03906          .BYTE $00, $00, $00, $00, $00, $FF, $1C, $3C, $7C, $5F, $7F, $7C, $3E, $7F, $3E, $FF
03907          .BYTE $94, $DD, $84, $D4, $85, $D4, $95, $04, $DD, $94, $95, $DF, $8C, $15, $1D, $94
03908  
03909  ;
03910  ;      FOCEND - TEXT AREAS AND THE LIKE
03911  ;
03912  ; SamCoVT - Zero page variables have been modified to make room
03913  ; for zero page loading routine (extending FOCAL to take up a full
03914  ; 8KB).  As a result, line 0.0 (below) needs to be moved up to
03915  ; $3FE0.
03916  003FE0                          .ORG $3FE0
03917  PRGBEG    .BYTE 0	; LINE NUMBER OF 00.00
03918            .BYTE 0     
03919            .ASCII  " C FOCAL-65 (V3D) 26-AUG-77"
03920            .BYTE $0D	; 'CR'
03921  
03922  
03923  PBEG     .BYTE EOP     ; START OF PROGRAM TEXT AREA
03924  VEND     .BYTE EOV     ; END OF VARIABLE LIST
03925  
03926           .END     
