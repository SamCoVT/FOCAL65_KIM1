00001  
00002  ; First disassembly by Paul R. Santa-Maria (2004)
00003  ; Initial comments added by Hans Otten, 2022
00004  ;
00005  ; New listing and comments from Wayne Wall's FOCAL-65 v3 (6502-TIM monitor ROM)
00006  ; and v4 (Apple II-specific) painstakingly typed in by Dave Hassler and
00007  ; Nils Andreas, 2023. (WAYNE'S COMMENTS, my/Nils's comments - dhh)
00008  ; v3d TIM source provided by Paul Birkle, v4 by Wayne Wall, both in 2023.
00009  ; Proofreading and corrections by SamCoVT, MIKE B., GAVIN D., AZin67
00010  ;
00011  
00012  ; Zero page block - *must* be loaded before main program executes
00013  
00014  ; SamCoVT - notes from focal 6502 user notes (describing a zero page
00015  ; initialization routine) indicate that only $00-$BF needs to be loaded.
00016  000000                        .ORG $0000
00017  
00018          .BYTE $53, $53, $4C, $E0, $2C, $4C, $DF, $2C, $00, $00, $00, $00, $00, $00, $00, $00        
00019          .BYTE $00, $62, $7B, $66, $EB, $6B, $3A, $7B, $6A, $6B, $6B, $7B, $FB, $7B, $6B, $6B
00020          .BYTE $00, $00, $00, $00, $00, $00, $FF, $00, $00, $01, $00, $00, $00, $00, $00, $EB
00021          .BYTE $35, $09, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $0A, $36
00022          .BYTE $0A, $36, $0A, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00023          .BYTE $00, $00, $00, $00, $5F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $4C, $00
00024          .BYTE $00, $6C, $00, $00, $48, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $C0
00025          .BYTE $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00026          .BYTE $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05
00027          .BYTE $05, $83, $50, $00, $00, $00, $7F, $40, $00, $00, $00, $80, $40, $00, $00, $00
00028          .BYTE $00, $00, $00, $00, $00, $FF, $1C, $3C, $7C, $5F, $7F, $7C, $3E, $7F, $3E, $FF
00029          .BYTE $94, $DD, $84, $D4, $85, $D4, $95, $04, $DD, $94, $95, $DF, $8C, $15, $1D, $94
00030  
00031  ;        .BYTE $00, $D3, $E0, $C1, $80, $90, $D3, $C0, $C2, $A3, $00, $C0, $81, $82, $C3, $80
00032  ;        .BYTE $62, $6A, $FB, $6B, $6A, $6A, $02, $FF, $5A, $4B, $E3, $10, $EB, $62, $62, $4B
00033  ;        .BYTE $7F, $6C, $7F, $7D, $3F, $7F, $2E, $7F, $7F, $7E, $7F, $36, $5F, $7E, $3E, $7F
00034  ;        .BYTE $94, $00, $FF, $FF, $84, $A7, $19, $83, $00, $00, $DF, $10, $A9, $FF, $C7, $01
00035  
00036  ; ZERO PAGE USE:
00037  
00038  ; 00	= unused
00039  ; 02	= JMP INTSRV	- on IRQ
00040  ; 05	= JMP NMISRV	- on NMI
00041  ;    -- I have *no* idea what's going on with $10-$1F... dhh)
00042  
00043    0020              DEBGSW	= $20		; TRACE FLAG
00044    0021              DMPSW	= $21		; 'DUMP SWITCH'
00045    0022              ATSW	= $22		; ASK-TYPE CMDS FLAG
00046    0023              IFONSW	= $23		; IF-ON CMDS FLAG
00047    0024              INSW	= $24		; INPUT INDICATOR
00048    0025              MSCHAR	= $25		; 'MODIFY' SEARCH CHAR
00049  
00050  		; *** FOLLOWING MUST BE CONTIGUOUS ***
00051    0026              PC	= $26		; PROG COUNTER
00052    0028              TXTADR	= $28		; CHAR ADDR
00053    002A              TEXTP	= $2A		; TEXT POINTER
00054    002B              CHAR	= $2B		; CURRENT CHARACTER
00055    002C              GRPNO	= $2C		; GROUP NUMBER
00056    002D              LINENO	= $2D		; LINE (STEP) NUMBER
00057    002E              PRILVL	= $2E		; CURRENT S/W INTERUPT PRIORITY
00058  		; *** END OF MUST BE CONTIGUOUS ***
00059  
00060    002F              TXTBEG	= $2F		; POINTER TO BEGINNING OF STORED PROGRAM
00061    0031              PBADR	= $31		; ADDR OF START OF USER PROGRAM
00062    0033              TXTAD2	= $33
00063    0035              TEXTP2	= $35		; COUNTERPART TO 'CHAR,' ABOVE
00064  
00065  		; POINTERS TO VARIABLE LIST - *** MUST BE CONTIGUOUS ***
00066  
00067    0037              VARADR	= $37		; POINTER TO CURRENT VAR IN LIST
00068    0039              VSUB	= $39		; LOCATION TO HOLD SUBSCRIPT DURING VAR SEARCH
00069    003B              STRSWT 	= $3B		; FLAG IF CURR VAR IS $ (also label FSWIT)
00070    003B              FSWIT   = $3B
00071    003C              VSIZE	= $3C		; SIZE OF CURR STRING VAR (GETVAR)
00072    003D              VCHAR	= $3D		; PLACE TO HOLD VAR NAME DURING SEARCH (also TCHAR)
00073    003E              VARBEG	= $3E		; POINTER BEGINNING VAR LIST
00074    0040              VARST	= $40		; POINTS TO END OF VARS ON 'E ALL' COMMAND
00075    0042              VAREND	= $42		; POINTS TO END OF VAR LIST
00076  
00077  		; POINTERS FOR STRING I/O
00078  
00079    0044              STIADR	= $44		; HOLDS ADDR POINTER TO INPUT STRING
00080    0046              STIPNT	= $46		; OFFSET POINTER
00081    0047              STIMAX	= $47		; HOLDS SIZE OF INPUT STRING
00082    0048              STOADR	= $48		; HOLDS ADDR POINTER TO OUTPUT STRING
00083    004A              STOPNT	= $4A		; OFFSET POINTER
00084    004B              STOMAX	= $4B		; HOLDS SIZE OF OUTPUT STRING
00085  
00086  		; SOFTWARE PUSHDOWN LIST
00087  
00088    004C              PDPADR	= $4C		; ADDR TO LIST (software stack)
00089    004E              PDP	= $4E		; OFFSET POINTER TO LIST
00090    004F              PDPTMP	= $4F		; TEMP LOC. FOR 'ROOMCK'
00091    0051              TGRP	= $51		; HOLDS TEMPORARY GROUP NUMBER FOR SOME
00092    0052              TLINE	= $52		;   OPERATIONS. TEMP LINE # HERE
00093  
00094    0053              PDLIST	= $53		; STARTING ADDR OF SOFTWARE PDL
00095  			; ** effectively, the last page of FOCAL's user RAM.
00096  			;    Change to what suits your system. - dhh
00097    0055              STRAD1  = $55           ; DEFINE POINTERS TO STRING 1 IN 'FSLK'
00098    0055              STRCNT  = $55           ; TEMP COUNTER FOR SOME STRING OPERATIONS
00099    0055              ITMP1L	= $55		; TEMP1 LOW BYTE
00100    0056              ITMP1H	= $56		; TEMP1 HIGH BYTE (this is also STRCNT)
00101    0057              SBEG1	= $57		; START POS. OF STRING 1
00102    0058              SEND1	= $58		; END POS. STRING 1
00103  
00104    0059              STRAD2  = $59           ; DEFINE POINTERS TO STRING 2 IN 'FSLK'
00105    0059              STRMAX  = $59           ; TEMP FOR SOME STRING OPERATIONS
00106    0059              ITMP2L	= $59		; TEMP2 LOW BYTE
00107    005A              ITMP2H	= $5A		; TEMP2 HIGH BYTE (this is also STRMAX)
00108    005B              SBEG2	= $5B		; START POS. OF STRING 2
00109    005C              SEND2	= $5C		; END POS. STRING 2
00110    005D              STBSAV	= $5D		; PLACE TO SAVE BEGINNING SUBSCRIPT
00111    005E              JSRIND	= $5E		; JSR OPCODE ($4C) FOR 'JSRIND' - *MUST* BE PLACED
00112  			;   JUST BEFORE 'TEMP1'.
00113    005F              TEMP1	= $5F		;   *** VERY TEMPORARY STORAGE! NOT NECESSARILY
00114  			;   PRESERVED ACROSS SUBROUTINE CALLS!
00115    0061              JMPIND	= $61		; OPCODE FOR 'JMP INDIRECT' ($6C)
00116    0062              PJMPL	= $62		; LOW ORDER ADDR FOR 'JMPIND'
00117    0063              PJMPH	= $63		; HIGH ORDER BYTE
00118  
00119    0064              STRSIZ	= $64		; HOLDS DEFAULT STRING SIZE ($48)
00120    0065              ETEMP1	= $65		; TEMP USED BY 'EVAL'
00121    0066              IDEV	= $66		; SPECIFIES INPUT DEVICE
00122    0067              ODEV	= $67		; SPECIFIES OUTPUT DEVICE
00123    0068              IDVSAV	= $68		; SAVE INP DEV #
00124    0069              ODVSAV	= $69		; SAVE OUTPUT DEV #
00125    006A              CONDEV	= $6A		; SPECIFIES DEVICE # OF CONSOLE
00126    006B              ECHFLG	= $6B		; ECHO FLAG
00127    006C              DELSPL	= $6C		; SPECIAL DELETE FOR CRT
00128    006D              ACTMSK	= $6D		; MASK TO INDICATE WHICH S/W INTERRUPT CH ARE ACTIVE
00129    006E              EVMASK	= $6E		; HOLDS EVENT BITS SET BY EXTERNAL ROUTINES
00130  			;   WHEN THEY WANT FOCAL'S ATTENTION
00131    006F              BITV1	= $6F		; USED TO SET V=1, N=1 (#$C0)
00132    0070              MSKBRK	= $70		; BIT TEST MASK FOR BREAK (#$10)
00133    0071              ACSAV	= $71		; PLACE WHERE ACC IS SAVED ON INTERRUPT
00134    0072              STATUS	= $72		; PLACE WHERE PROC STATUS IS SAVED ON INTERRUPT
00135    0073              ITEMP1	= $73		; PLACE WHERE RET ADDR IS KEPT ON INTERRUPT
00136  
00137    0075              LASTOP	= $75		; USED BY 'EVAL'
00138    0076              HASH	= $76		; LOADED WITH A RANDOM HASH VALUE
00139  			;   *** NOTE: SOME ROUTINE IN YOUR SPECIFIC
00140  			;             COMPUTER SYSTEM SHOULD LOAD THIS
00141  			;	      LOC. WITH A PSEUDO-RANDOM 8-BIT VALUE.
00142    0077              SEED	= $77		; 3 BYTES. HOLDS A 23-BIT RANDOM # SEED - SEE 'FRAN'
00143  
00144  		; FLOATING POINT ROUTINES Z PG USE
00145  
00146    007A              SIGN	= $7A		; (also X2M1)
00147  
00148    007B              X2	= $7B		; FAC2 EXPONENT (also the *beginning of 'FAC2'*)
00149    007C              M2	= $7C		; FAC2 MANTISSA (3 bytes)
00150    007F              X1M1	= $7F
00151  
00152    0080              X1	= $80		; FAC1 EXPONENT (also the *beginning of 'FAC1'*)
00153    0080              FAC1    = $80
00154    0081              M1	= $81		; FAC1 MANTISSA (3 bytes, also 'FLCSGN')
00155    0081              FLCSGN  = $81
00156    0084              EM1	= $84
00157    0085              E	= $85		; SCRATCH AREA
00158    0089              EP4	= $89		; add'l scratch RAM alluded to elsewhere
00159  
00160  		; FLOATING POINT I/O ROUTINES
00161  
00162    008A              SIGNP	= $8A		; TEMPORARY SIGN
00163    008B              DPFLG	= $8B		; SAW DECIMAL POINT
00164    008C              GOTFLG	= $8C		; IF NON ZERO, WE ACTUALLY INPUT A NUMBER
00165    008D              K	= $8D		; MISC COUNTER
00166    008E              L	= $8E		; TEMP
00167    008F              M	= $8F		; # OF PLACES BEFORE DECIMAL POINT
00168    0090              N	= $90		; # OF PLACES AFTER DECIMAL POINT
00169  
00170    0091              FTEN	= $91		; CONSTANT 10.00
00171    0096              FHALF	= $96		; CONSTANT 2.50
00172    009B              FONE	= $9B		; CONSTANT 1.00
00173    00A0              T	= $A0		; TEMP (5 bytes)
00174  		; FLAG END OF OUR PAGE ZERO USAGE
00175  		; FOR ANYONE WHO NEEDS TO KNOW
00176  
00177  ;	$A5 = SAVYR  save for Y register (was $7F in v3 - RUBOUT)
00178    00A5              SAVYR   = $A5
00179  ;	also, end of zero page usage
00180  ;	TIM I/O package not in the Aresco version of v3d.
00181  
00182  		;		FOCAL SYMBOL DEFINITIONS
00183  		; 
00184  		; ALL POSSIBLE SYMBOLIC EQUATES SHOULD BE KEPT IN THIS MODULE
00185  		;
00186  		; FOCAL ERROR CODES - NEGATIVE
00187  		;
00188  
00189    00DB              BASTRF	= $DB		; -37 BAD OR MISSING ARGUMENT IN A STRING FUNCTION
00190    00DC              SVRQ	= $DC		; -36 STRING VARIABLE REQUIRED HERE
00191    00DD              SVNA	= $DD		; -35 STRING VARIABLE NOT ALLOWED HERE
00192    00DE              ERRO	= $DE		; -34 I-O ERROR ON OUTPUT DEVICE
00193    00DF              ARGM	= $DF		; -33 ARGUMENT MISSING IN FUNCTION
00194    00E0              XNU32	= $E0		; -32 CURRENTLY NOT USED
00195    00E1              WNEXG	= $E1		; -31 "WRITE" OF NON-EXISTANT GROUP
00196    00E2              UNRFUN	= $E2		; -30 UNRECOGNIZABLE FUNCTION NAME
00197    00E3              PFERR	= $E3		; -29 PARENTHESES ERROR IN FUNCTION
00198    00E4              MNEXL	= $E4		; -28 "MODIFY" OF NON-EXISTANT LINE
00199    00E5              DONEXG	= $E5		; -27 "DO" OF NON-EXISTANT GROUP
00200    00E6              DONEXL	= $E6		; -26 "DO" OF NON-EXISTANT LINE
00201    00E7              IFSYN	= $E7		; -25 SYNTAX ERROR IN "IF" OR "ON" COMMAND
00202    00E8              ENEXL	= $E8		; -24 "ERASE" OF NON-EXISTANT LINE
00203    00E9              ERRI	= $E9		; -23 I-O ERROR ON INPUT DEVICE
00204    00EA              WNEXL	= $EA		; -22 "WRITE" OF NON-EXISTANT LINE
00205    00EB              GONEXL	= $EB		; -21 "GOTO" NON-EXISTANT LINE
00206    00EC              BADLI	= $EC		; -20 BAD LINE NUMBER ON INPUT
00207    00ED              UNKINT	= $ED		; -19 UNKNOWN INTERRUPT REQUEST
00208    00EE              UNRBRK	= $EE		; -18 UNRECOGNIZABLE TRAP CODE
00209    00EF              RESBRK	= $EF		; -17 RESET BUTTON PRESSED
00210    00F0              DEVRNG	= $F0		; -16 DEVICE NUMBER OUT OF RANGE
00211    00F1              UFL	= $F1		; -15 USELESS "FOR" LOOP
00212    00F2              FBDTRM	= $F2		; -14 BAD TERMINATOR IN "FOR"
00213    00F3              NOEQLS	= $F3		; -13 NO "=" IN "FOR"
00214    00F4              BADVAR	= $F4		; -12 BAD VARIABLE NAME
00215    00F5              FUNILL	= $F5		; -11 FUNCTION ILLEGAL HERE
00216    00F6              XNU10	= $F6		; -10 NOT USED AT THIS TIME
00217    00F7              XNU9	= $F7		; -9 NOT USED AT THIS TIME
00218    00F8              FOVFL	= $F8		; -8 FLOATING POINT OVERFLOW
00219    00F9              OPNMIS	= $F9		; -7 OPERAND MISSING - EVAL
00220    00FA              PMATCH	= $FA		; -6 PARENTHESES MISMATCH - EVAL
00221    00FB              OPRMIS	= $FB		; -5 OPERATOR MISSING - EVAL
00222    00FC              ILLNO	= $FC		; -4 ILLEGAL LINE NUMBER
00223    00FD              BADCOM	= $FD		; -3 UNRECOGNIZABLE COMMAND
00224    00FE              EILLG0	= $FE		; -2 ILLEGAL GROUP ZERO USAGE
00225    00FF              LTL	= $FF		; -1 LINE TOO LONG
00226  
00227  		;
00228  		; FUNCTION HASH CODE DEFINITIONS
00229  		;
00230    0036              HFABS	= $36		; ABSOLUTE VALUE FUNCTION
00231    00F4              HFOUT	= $F4		; OUTPUT FUNCTION
00232    00B0              HFRAN	= $B0		; RANDOM NUMBER FUNCTION
00233    00A8              HFINT	= $A8		; INTERGERIZE FUNCTION
00234    00A4              HFINR	= $A4		; INTEGERIZE AFTER ROUNDING FUNCTION
00235    0084              HFIDV	= $84		; SET INPUT DEVICE FUNCTION
00236    00B4              HFODV	= $B4		; SET OUTPUT DEVICE FUNCTION
00237    005C              HFCHR	= $5C		; SINGLE ALPHA CHAR INPUT FUNCTION
00238    0090              HFCUR	= $90		; SPECIAL CLRSCR ADDRESSING FUNCTION
00239    0044              HFECH	= $44		; ECHO CONTROL FUNCTION
00240    00AA              HFPIC	= $AA		; PRIORITY INTERRUPT CONTROL FUNCTION
00241    0096              HFMEM	= $96		; MEMORY EXAMINE-DEPOSIT FUNCTION
00242    0092              HFINI	= $92		; INITIALIZE INPUT DEVICE FUNCTION
00243    009E              HFINO	= $9E		; INITIALIZE OUTPUT DEVICE FUNCTION
00244    005A              HFCLI	= $5A		; CLOSE INPUT DEVICE FUNCTION
00245    0066              HFCLO	= $66		; CLOSE OUTPUT DEVICE FUNCTION
00246    0070              HFCON	= $70		; SET CONSOLE DEVICE FUNCTION
00247    00C4              HFSBR	= $C4		; 'SUBROUTINE' CALL FUNCTION
00248    00AC              HFISL	= $AC		; INITIALIZE STRING LENGTH FUNCTION
00249    00FA              HFSTI	= $FA		; STRING INPUT FUNCTION
00250    0006              HFSTO	= $06		; STRING OUTPUT FUNCTION
00251    00DE              HFSLK	= $DE		; STRING "LOOK" FUNCTION
00252  
00253  		; MORE DEFINITIONS
00254  
00255    0005              NUMBF	= 5		; # BYTES IN A F.P. #
00256    0008              VARSIZ	= 3+NUMBF	; 1 BYTE FOR NAME, 2 BYTES SUBSCRIPT, THEN VALUE
00257    007F              LINEL	= 127		; MAX LENGTH FOCAL LINE +1; MUST NOT >127 (SEE 'PACKC')
00258    00FF              EOV	= $FF		; END OF VAR MARKER
00259    00FE              EOP	= $FE		; END OF PROG MARKER
00260    00FD              UMARK	= $FD		; ANOTHER UNIQUE MARKER
00261    00FC              STRMRK	= $FC		; MARKS A STRING VAR IN VAR LIST
00262    0048              STRLEN	= 72		; DEF STRING LENGTH
00263  
00264    005C              RUBECH	= $5C	; '\' ECHOED FOR RUBOUT (unused here for modern tty emu)
00265    005F              LINCHR	= $5F	; '_' ECHOED FOR LINE DELETE
00266    001B              ALTCHR	= $1B	; 'ESC' CHAR USED FOR 'ALTMODE' - MAY REQUIRE CHANGE
00267    007F              RUBCHR  = $7F
00268  
00269    00FF              DIRLIN	= $FF
00270    00FE              STRLIN	= $FE
00271    00FD              RETCMD	= $FD
00272  
00273    0100              STACK	= $0100
00274  
00275  ; self modifying code locations: (P.R.S-M)
00276  ;                H2350   EQU $2350
00277  ;                H2351   EQU $2351
00278  ;                H282F   EQU $282F
00279  ;                H2830   EQU $2830
00280  ;                H340A   EQU $340A
00281  ;                H340C   EQU $340C
00282  
00283  ;			***** 'FOCINT - FOCAL CODE INTERPRETER
00284  ;
00285  ;		THIS IS WHERE THE HEART OF FOCAL LIES.  INPUT PROCESSING,
00286  ;	COMMAND DECODING, CONTROL FLOW, AND EXECUTION ARE PERFORMED
00287  ;	IN THIS MODULE.
00288  ;		
00289  
00290  002000                       .ORG $2000
00291  
00292  ;	'FOCAL' COMES HERE ON A 'RESET' (PANIC RESTART)
00293  
00294  002000  78            FOCAL     SEI		; MAKE SURE INTERRUPTS ARE DISABLED
00295  002001  D8                      CLD		; AND DICIMAL MODE IS OFF
00296  002002  A2 FF                   LDX #$FF	; INIT STACK POINTER
00297  002004  9A                      TXS
00298  002005  20 0D 20                JSR SETUP	; SET UP SOME INITIAL PARAMETERS
00299  002008  20 27 20                JSR INIDEV	; INIT CONSOLE DEVICE
00300  00200B  00                      BRK		; ENTER FOCAL VIA TRAP
00301            .BYTE $EF	; A DATA BYTE - INDICATE 'RESET' PRESSED
00302  00200D  A2 FF         SETUP     LDX #$FF	; INIT SOFTWARE PUSHDOWN LIST
00303  00200F  20 1C 20                JSR PDPINI     
00304  002012  E8                      INX		; FORM A ZERO IN X
00305  002013  86 6B                   STX ECHFLG	; TURNS ECHOING ON
00306  002015  A5 6A         CLRDEV    LDA CONDEV	; SET CONSOLE AS BOTH IN AND OUT DEVICES
00307  002017  85 66                   STA IDEV
00308  002019  85 67                   STA ODEV
00309  00201B  60                      RTS
00310  ; 
00311  ; ROUTINE TO INIT SOFTWARE PUSHDOWN LIST POINTER
00312  ; 
00313  00201C  86 4E         PDPINI    STX PDP	; ASSUMED TO CONTAIN '$FF' IN X REGISTER
00314  00201E  A5 53                   LDA PDLIST	; RESET ADDR POINTER
00315  002020  85 4C                   STA PDPADR
00316  002022  A5 54                   LDA PDLIST+1
00317  002024  85 4D                   STA PDPADR+1
00318  002026  60                      RTS
00319  ; 
00320  ; ROUTINE TO INIT I/O DEVICES
00321  ; 
00322  002027  A5 66         INIDEV    LDA IDEV	; INIT INPUT DEVICE
00323  002029  20 8D 2E                JSR INI     
00324  00202C  A5 67                   LDA ODEV	; INIT OUTPUT DEVICE
00325  00202E  4C A2 2E                JMP INO	; * PJMP * AND RETURN
00326  ; 
00327  002031  A2 FF         START     LDX #$FF	; warm entry point. FOCAL comes here
00328  002033  9A                      TXS		; on an internal restart. INIT STACK
00329  002034  86 21                   STX DMPSW	; FLAG THE TRACE OFF
00330  002036  86 26                   STX PC	; INDICATE PROC. A DIRECT COMMAND
00331  002038  E8                      INX		; GET A ZERO
00332  002039  86 20                   STX DEBGSW	; ALLOW TRACE TO BE ENABLED
00333  00203B  86 28                   STX TXTADR	; INIT TEXT POINTERS TO CMD BUFFER
00334  00203D  86 2A                   STX TEXTP	; RESET OFFSET POINTER TO TEXT LINE
00335  00203F  86 6D                   STX ACTMSK	; INDICATE ALL S/W INTER. CHNLS INACTIVE
00336  002041  86 6E                   STX EVMASK	; CLEAR ANY EXT. EVENT FLAGS
00337  002043  86 2E                   STX PRILVL	; SET TO LOWEST PRIORITY LEVEL
00338  002045  E8                      INX		; GET A 1
00339  002046  86 29                   STX TXTADR+1	; CMD BUFFER IS IN STACK AREA
00340  002048  A9 2A                   LDA #$2A	; LOAD PROMPT CHARACTER '*'
00341  00204A  20 02 29                JSR PRINTC	;   AND ANNOUNCE OUR PRESENCE
00342  00204D  20 C0 28      NEXTIC    JSR READC	; GO INPUT A CHAR FROM INPUT DEVICE
00343  002050  C9 0A                   CMP #$0A	; LF?
00344  002052  F0 F9                   BEQ NEXTIC	; YES, IGNORE LF ON COMMAND INPUT
00345  002054  20 2D 29                JSR PACKC1	; NO, STORE CHAR IN CMD BUFFER
00346  002057  C9 0D                   CMP #$0D	; CR?
00347  002059  D0 F2                   BNE NEXTIC	; IF NOT, GET ANOTHER
00348  ; 
00349  ; COMMAND/INPUT PROCESSOR
00350  ; 
00351  00205B  A2 00         IRETN     LDX #$00	; RESET TEXT POINTER
00352  00205D  86 2A                   STX TEXTP
00353  00205F  86 24                   STX INSW	; FLAG TEXT CHAR TO COME FROM MEMORY
00354  002061  CA                      DEX		; SET TO $FF
00355  002062  20 1C 20                JSR PDPINI	; INIT SOFTWARE PDL POINTER
00356  002065  20 B1 29                JSR GSPNOR	; IGNORE LEADING BLANKS
00357  002068  20 C0 29                JSR TESTN1	; HAVE A NUMBER?
00358  00206B  90 06                   BCC GOTNUM	; YES, BRANCH
00359  00206D  C9 2E                   CMP #$2E	; NO, TEST '.'
00360  00206F  D0 13                   BNE INPX1	; NOT # OR '.', MUST BE DIRECT CMD
00361  002071  00                      BRK		; TRAP
00362           .BYTE $FE	; CODE FOR ILL. GROUP 0 USEAGE
00363  002073  E6 20         GOTNUM    INC DEBGSW	; A DIGIT; DISABLE TRACE FOR PACKING
00364  002075  20 B6 25                JSR GETLNC	; GET THE LINE # FROM COMBUF
00365  002078  70 08                   BVS IBADL	; 00.00 IS A BAD LINE NUMBER
00366  00207A  F0 06                   BEQ IBADL	; GG.00 IS A BAD LINE NUMBER
00367  00207C  20 84 27      REPLIN    JSR INSERT	; GO INSERT THIS LINE IN THE TEXT AREA
00368  00207F  4C 31 20      RSTART    JMP START	; AND START OVER FOR NEXT DIR. CMD
00369  002082  00            IBADL     BRK		; TRAP
00370           .BYTE $EC	; ?BAD LINE # ON INPUT
00371  
00372  002084  20 1C 28      INPX1     JSR PUSHJ	; PROCESS COMMAND
00373            .WORD PROC	; $2302
00374  002089  A5 26                   LDA PC	; GET PROGRAM LINE NUMBER
00375  00208B  30 A4                   BMI START     ; START OVER IF DIRECT CMD
00376  00208D  20 D7 26                JSR EATCR1	; EAT TO END OF LINE
00377  002090  20 32 27                JSR NXTLIN	; GO SET UP POINTERS TO NEXT LINE
00378  002093  B0 EF                   BCS INPX1     ; BRANCH IF MORE TO DO
00379  002095  90 9A                   BCC START     ; BRANCH IF END OF PROGRAM
00380  ; 
00381  ; ROUTINE TO 'DO' CODE STORED IN A STRING
00382  ; 
00383  ; THIS ROUTINE ALLOWS THE EXECUTION OF CODE STORED IN A
00384  ; STRING VARIABLE.  IF ONE PLACES CHARACTERS INTO A STRING
00385  ; VARIABLE, AND ENDS THEM WITH A CARRIAGE RETURN, THEN A
00386  ; 'DO' COMMAND CAN BE USED TO PERFORM THE LINE STORED IN THE
00387  ; STRING VARIABLE.
00388  ; 
00389  002097  20 B9 20      DOSTR     JSR PUSHDO	; SAVE CURRENT GOODIES ON STACK
00390  00209A  A5 37                   LDA VARADR	; POINT TO SPEC. CHAR IN STRING
00391  00209C  85 28                   STA TXTADR	;   WITH TEXT POINTERS
00392  00209E  A5 38                   LDA VARADR+1
00393  0020A0  85 29                   STA TXTADR+1
00394  0020A2  A5 3A                   LDA VSUB+1	; GET CHAR POSITION IN STRING
00395  0020A4  85 2A                   STA TEXTP     
00396  0020A6  A9 FE                   LDA #STRLIN	; FLAG THIS SO 'FNDLIN' WILL ALWAYS LOOK
00397  0020A8  85 26                   STA PC	;   FROM BEGINNING OF PROGRAM TEXT
00398  0020AA  A5 3D                   LDA VCHAR	; STORE THE STRING VARIABLE'S NAME FOR
00399  0020AC  85 27                   STA PC+1	;   ERROR MSG PRINT ROUTINE (BERROR)
00400  0020AE  20 1C 28                JSR PUSHJ	; NOW 'DO' THE STRING (SHUD HAVE CR!)
00401            .WORD PROCES	; $22FF
00402  0020B3  20 C0 20                JSR POPDO	; RESTORE CURRENT GOODIES
00403  0020B6  20 4B 28                JSR POPJ	;   AND RETURN FROM 'DO'
00404  ; 
00405  ; ROUTINE TO SAVE NEEDED INFO ON STACK.  USED BY 'DO'
00406  ; 
00407  0020B9  A2 26         PUSHDO    LDX #$26	; GET ADDR OF START OF SAVE AREA
00408  0020BB  A0 09                   LDY #$09	;   AND # OF BYTES TO SAVE
00409  0020BD  4C 6B 28                JMP PUSHB0	; * PJMP * PUSH THEM ON STACK & RET.
00410  ; 
00411  ; ROUTINE TO RESTORE NEEDED INFO AFTER THE 'DO'
00412  ; 
00413  0020C0  A2 2E         POPDO     LDX #$2E	; GET BASE ADDR TO PUT INFO BACK INTO
00414  0020C2  A0 09                   LDY #$09	;   AND # OF BYTES TO RESTORE
00415  0020C4  4C 5B 28                JMP POPB0	; * PJMP * POP THEM OFF AND RETURN
00416  ; 
00417  ; 'IF' COMMAND PROCESSOR (CONDITIONAL GOTO)
00418  ; THROW IN THE 'QUIT' COMMAND HERE ALSO
00419  ; 
00420    2031              QUIT     = START
00421  
00422  ON
00423  ; 
00424  ; in WW source of '77, JSR PUSHA is here; not in Aresco binary --dhh
00425  ; 
00426  0020C7  85 23         IFON      STA $23	; not in Aresco code
00427  0020C9  20 B1 29                JSR GSPNOR	; MOVE TO NEXT NON-BLANK
00428  0020CC  C9 28                   CMP #$28	; '('
00429  0020CE  F0 02                   BEQ IFCNT1	; YES, BRANCH
00430  0020D0  00                      BRK		; NO, TRAP
00431            .BYTE $E7	; SYNTAX ERROR IN 'IF' OR 'ON' CMD (IFSYN)
00432  0020D2  20 1C 28      IFCNT1    JSR PUSHJ	; NOW EVALUATE WHAT'S IN PARENS
00433            .WORD EVALM1
00434  0020D7  A5 2B                   LDA CHAR	; GET TERMINATOR
00435  0020D9  C9 29                   CMP #$29	; ')'
00436  0020DB  F0 02                   BEQ IFCNT2	; YES, CONTINUE
00437  0020DD  00                      BRK		;NO, TRAP
00438            .BYTE PMATCH	; ?PARENTHESIS MISMATCH
00439  0020DF  20 92 29      IFCNT2    JSR GETC	; MOVE PAST RIGHT PAREN
00440  0020E2  A5 81                   LDA FLCSGN	; GET THE SIGN OF THE EXPRESSION
00441  0020E4  30 2B                   BMI IFXCT	; IF NEGATIVE, GO DO IT NOW
00442  0020E6  10 03                   BPL IF3	; OTHERWISE, LOOK FOR COMMA
00443  0020E8  20 92 29      IFCOM     JSR GETC	; GET A CHAR
00444  0020EB  A5 2B         IF3       LDA CHAR
00445  0020ED  C9 2C                   CMP #$2C	; ','
00446  0020EF  F0 0B                   BEQ IF1	; BRANCH IF YES
00447  0020F1  C9 3B                   CMP #$3B	; ';'
00448  0020F3  F0 31                   BEQ IFNOP	; YES, CONTINUE WITH NEXT CMD ON THIS LINE
00449  0020F5  C9 0D                   CMP #$0D	; CR?
00450  0020F7  D0 EF                   BNE IFCOM	; NO, KEEP LOOKING ('JSR POPA' in betw. orig)
00451  0020F9  20 4B 28                JSR POPJ	; YES, THEN EXIT 'PROCESS'
00452  0020FC  20 92 29      IF1       JSR GETC	; MOVE PAST THE COMMA
00453  0020FF  A9 00                   LDA #$00	;          from here, the Aresco code is wildy
00454  002101  A2 03                   LDX #$03	; different from the original Program Exchange.  ...
00455  002103  15 81         L2103     ORA $81,X	; (left generic label from disassembly here)
00456  002105  CA                      DEX		;
00457  002106  10 FB                   BPL L2103	;
00458  002108  09 00                   ORA #$00	; ... to here.  --dhh
00459  00210A  F0 05                   BEQ IFXCT	; BRANCH IF FAC1=0
00460  00210C  20 CB 2C                JSR ZRFAC1	; SET IT TO ZERO, THIS TIME FOR SURE
00461  00210F  30 DA                   BMI IF3 	; UNCONDITIONAL BRANCH
00462  002111  20 BC 25      IFXCT     JSR GETLNS	; GO GET THE LINE NUMBER
00463  002114  08                      PHP		; SAVE PROCESSOR FLAGS
00464  002115  20 FE 26                JSR EATECM	; NOW EAT UNTIL THE END OF A COMMAND
00465  002118  28                      PLP		; GET FLAGS BACK
00466  002119  70 0B                   BVS IFNOP	; BRANCH IF NO LINE NUMBER GIVEN
00467  00211B  08                      PHP		; SAVE THEM AGAIN
00468  00211C  A5 23                   LDA IFONSW	;   is 'JSR POPA' in orig.
00469  00211E  C9 4F                   CMP #$4F	; 'O'
00470  002120  F0 07                   BEQ IFDO1	; YES, GO 'DO' THE LINE
00471  002122  28                      PLP		; ADJUST STACK
00472  002123  4C F5 22                JMP GOTO1	; NO, 'IF' CMD, THEN 'GOTO' LINE
00473  002126  4C 02 23      IFNOP     JMP PROC	; ADJUST STACK (then 'JMP PROC' in orig...)
00474  002129  68            IFDO1     PLA		; GET STATUS SAVED AFTER 'GETLN' CALL
00475  00212A  AA                      TAX 		; SAVE IN THE X REGISTER
00476  00212B  20 1C 28                JSR PUSHJ	; NOW PERFORM THE 'DO' OF THE LINE OR GROUP
00477            .WORD DO1	; $21B6
00478  002130  4C 02 23                JMP PROC	; AND THEN CONTINUE PROCESSING ON THIS LINE
00479  
00480    20C7              IF     = ON		; BOTH COMMANDS HAVE COMMON ENTRY POINT
00481  
00482  ; MODIFY CMD PROCESSOR: 'MODIFY' A LINE OF THE USER'S PROGRAM
00483  
00484  002133  20 BC 25      MODIFY    JSR GETLNS	; GET THE LINE NUMBER SPECIFIED
00485  002136  70 02                   BVS BADMOD	; BRANCH IF 00.00
00486  002138  D0 02                   BNE MODNOK	; BRANCH IF GG.LL
00487  00213A  00            BADMOD    BRK		; TRAP
00488       	 .BYTE MNEXL	; ?MODIFY OF NON-EXISTANT LINE (#$E4)
00489  00213C  20 80 26      MODNOK    JSR FINDLN	; TRY TO FIND THE LINE
00490  00213F  90 F9                   BCC BADMOD	; BRANCH IF COULD NOT FIND
00491  002141  20 99 2D             	  JSR CRLF	; OUTPUT A BLANK LINE
00492  002144  20 31 26                JSR PRNTLN	; PRINT THE LINE NUMBER
00493  002147  A0 02                   LDY #$02	; SET OFFSET TO FIRST CHAR ON LINE
00494  002149  84 35                   STY TEXTP2
00495  00214B  A9 00                   LDA #$00
00496  00214D  85 28                   STA TXTADR	; INIT POINTERS TO COMBUF
00497  00214F  85 2A                   STA TEXTP	; 
00498  002151  A9 01                   LDA #$01
00499  002153  85 29                   STA TXTADR+1
00500  002155  20 B0 28      MNXTC     JSR RNOECH	; GO WAIT FOR THE GUY TO TYPE A CHAR
00501  002158  C9 0A                   CMP #$0A	; LINE FEED?
00502  00215A  F0 25                   BEQ MLOOK1	; YES, THEN GO FEED TO END OF LINE
00503  00215C  C9 1B                   CMP #ALTCHR	; ALTMODE?
00504  00215E  F0 1E                   BEQ MLOOK	; YES, THEN PICK UP SEARCH CHAR
00505  002160  C9 7F                   CMP #RUBCHR	; RUBOUT
00506  002162  F0 07                   BEQ MNOECH	; YES, THEN DON'T ECHO
00507  002164  C9 5F                   CMP #LINCHR	; WAS CHAR THE 'LINE-DELETE' CHAR?
00508  002166  F0 03                   BEQ MNOECH	; BRANCH IF IT IS, DO NOT ECHO
00509  002168  20 02 29                JSR PRINTC	; ECHO THE CHARACTER
00510  00216B  20 2D 29      MNOECH    JSR PACKC1	; PACK CHAR INTO COMBUF
00511  00216E  C9 0D                   CMP #$0D	; WAS CHAR A CARRIAGE RETURN?
00512  002170  D0 E3                   BNE MNXTC	; NO, THEN PICK UP NEXT CNE
00513  002172  20 9E 2D      MENDL     JSR OUTLF	; FOLLOW WITH A LINE FEED
00514  002175  A9 01                   LDA #$01	; SET COMBUF OFFSET
00515  002177  85 2A                   STA TEXTP	; FOR 'INSERT'
00516  002179  E6 20                   INC DEBGSW	; DISABLE TRACE FOR INSERT
00517  00217B  4C 7C 20                JMP REPLIN	; AND GO REPLACE OLD LINE WITH EDITED LINE
00518  
00519  00217E  20 B0 28      MLOOK     JSR RNOECH	; SILENTLY GET THE SEARCH CHAR
00520  002181  85 25         MLOOK1    STA MSCHAR	; STORE SEARCH CHAR
00521  002183  A4 35         MLOOK2    LDY TEXTP2	; GET POINTER TO TEXT IN MEMORY
00522  002185  B1 33                   LDA (TXTAD2),Y	; GET CHAR
00523  002187  C8                      INY		; POINT TO NEXT
00524  002188  84 35                   STY TEXTP2	; 
00525  00218A  20 2D 29                JSR PACKC1	; PACK THE CHAR
00526  00218D  20 02 29                JSR PRINTC	; ECHO IT
00527  002190  C5 25                   CMP MSCHAR	; WAS IT THE SEARCH CHAR?
00528  002192  F0 C1                   BEQ MNXTC	; BRANCH IF YES
00529  002194  C9 0D                   CMP #$0D	; CR?
00530  002196  F0 DA                   BEQ MENDL	; YES, THEN THAT'S IT
00531  002198  D0 E9                   BNE MLOOK2	; NO, THEN KEEP LOOKING
00532  ;
00533  ;        'DO' RECURSIVE OPERATE, EXECUTE, OR CALL
00534  ;
00535  00219A  20 1C 28      DO        JSR PUSHJ	; CALL THE 'DO' SUBROUTINE
00536            .WORD DOX	; $21A2
00537  00219F  4C 02 23                JMP PROC	; AND CONTINUE PROCESSING
00538  0021A2  A9 00         DOX       LDA #$00	; ZERO OUT THE STRING VARIABLE SWITCH
00539  0021A4  85 3B                   STA STRSWT
00540  0021A6  20 BC 25                JSR GETLNS	; GO GET THE LINE NUMBER TO 'DO'
00541  0021A9  08                      PHP		; SAVE FLAGS FROM 'GETLNS'
00542  0021AA  A5 3B                   LDA STRSWT	; WAS EXPRESSION A STRING VARIABLE?
00543  0021AC  F0 04                   BEQ DOX1	; BRANCH IF NOT, PRESS ON
00544  0021AE  28                      PLP		; YES, THEN ADJUST STACK
00545  0021AF  4C 97 20                JMP DOSTR	; * PJMP * DO CODE STORED IN STRING, RET
00546  0021B2  28            DOX1      PLP		; RESTORE FLAGS FROM 'GETLNS'
00547  0021B3  4C B9 21                JMP DO2	;   AND ENTER ROUTINE
00548  0021B6  8A            DO1       TXA		; ENTER HERE WITH STATUS FROM 'GETLN' IN X
00549  0021B7  48                      PHA		; SAVE ON STACK
00550  0021B8  28                      PLP		; MAKE CURRENT PROCESSOR STATUS
00551  0021B9  08            DO2       PHP		; SAVE PROCESSOR STATUS ACROSS THE SAVE
00552  0021BA  20 B9 20                JSR PUSHDO	; SAVE IMPORTANT STUFF ON STACK FOR LATER
00553  0021BD  28                      PLP		; GET THE FLAGS BACK
00554  0021BE  70 17                   BVS DOGRP	; BRANCH IF "DO ALL"
00555  0021C0  F0 15                   BEQ DOGRP	; OR "DO" IS A GROUP
00556  0021C2  20 80 26      DOONE     JSR FINDLN	; TRY TO FIND THE LINE TO "DO"
00557  0021C5  B0 02                   BCS DOCNT1	; BRANCH IF WE FOUND IT
00558  0021C7  00                      BRK		; TRAP
00559           .BYTE DONEXL	; ?"DO" OF NON-EXISTANT LINE (#$E6)
00560  0021C9  20 25 27      DOCNT1    JSR NEWLIN	; SET UP THE NEW LINE
00561  0021CC  20 1C 28                JSR PUSHJ	; AND EXECUTE IT
00562            .WORD PROCES	; $22FF
00563  0021D1  20 C0 20      DOCONT    JSR POPDO	; NOW RESTORE IMPORTANT STUFF AS IT WAS
00564  0021D4  20 4B 28                JSR POPJ	; AND RETURN
00565  ;
00566  ;        'DO' COMMAND PROCESSOR
00567  ;
00568  0021D7  20 80 26      DOGRP     JSR FINDLN	; TRY TO LOCATE SMALLEST LINE OF THE GRP
00569  0021DA  A5 51                   LDA TGRP	; IS IT THE SAME GRP WE'RE LOOKING FOR?
00570  0021DC  C5 2C                   CMP GRPNO     
00571  0021DE  F0 02                   BEQ DOGRP1	; BRANCH IF YES
00572  0021E0  00                      BRK	; TRAP
00573           .BYTE DONEXG	; ?"DO" OF NON-EXISTANT GROUP (#$E5)
00574  0021E2  A5 51         DOGRP1    LDA TGRP	; GET THE GROUP NUMBER WE ARE 'DO'ING
00575  0021E4  20 31 28                JSR PUSHA	; SAVE ON STACK
00576  0021E7  20 32 27      DOGRPC    JSR NXTLIN	; SET UP POINTERS FOR NEXT LINE
00577  0021EA  90 1C                   BCC ENDGRP	; BRANCH IF END OF PROGRAM
00578  0021EC  20 3F 28                JSR POPA	; GET GROUP NUMBER WE ARE 'DO'ING
00579  0021EF  20 31 28                JSR PUSHA	; SAVE IT AGAIN
00580  0021F2  09 00                   ORA #$00	; ARE WE DOING GROUP ZERO (ALL)?
00581  0021F4  F0 04                   BEQ DONEXT	; YES, THEN ANY LINE IS OK
00582  0021F6  C5 26                   CMP PC	; IS THIS LINE OF THE SAME GROUP?
00583  0021F8  D0 0E                   BNE ENDGRP	; BRANCH IF NOT
00584  0021FA  20 1C 28      DONEXT    JSR PUSHJ	; YES, THEN PROCESS THIS LINE
00585            .WORD PROCES	; $22FF
00586  0021FF  20 D7 26                JSR EATCR1	; EAT UNTIL A CARRIAGE RETURN
00587  002202  A5 26                   LDA PC	; GET THE CURRENT LINE NUMBER
00588  002204  C9 FD                   CMP #RETCMD	; 'RETURN' COMMAND SEEN?
00589  002206  D0 DF                   BNE DOGRPC	; BRANCH IF NOT, CONTINUE
00590  002208  20 3F 28      ENDGRP    JSR POPA	; ADJUST STACK
00591  00220B  4C D1 21                JMP DOCONT	; AND RETURN FROM "DO"
00592  
00593  ; "RETURN" AND "RESTORE" COMMANDS
00594  
00595  00220E  20 B4 29      RETURN    JSR SPNOR	; GET NEXT NON-BLANK
00596  002211  C9 49                   CMP #$49	; 'I' IS THIS A 'RESTORE INPUT' (R I)?
00597  002213  F0 0B                   BEQ RESINP	; BRANCH IF YES
00598  002215  C9 4F                   CMP #$4F	; 'O' IS THIS A 'RESTORE OUTPUT' (R O)?
00599  002217  F0 0E                   BEQ RESOUT	; BRANCH IF YES
00600  002219  A9 FD                   LDA #RETCMD	; NO, THEN IT MUST BE A "RETURN"
00601  00221B  85 26                   STA PC	; SET PC TO SPECIAL VALUE
00602  00221D  20 4B 28                JSR POPJ	; AND EXIT "PROCESS"
00603  
00604  002220  A5 68         RESINP    LDA IDVSAV	; RESTORE INPUT DEVICE # TO WHAT IT WAS
00605  002222  85 66                   STA IDEV	;   BEFORE LAST STRING INPUT
00606  002224  4C FF 22                JMP PROCES	;   AND CONTINUE EXECUTING ON THIS LINE
00607  002227  A5 69         RESOUT    LDA ODVSAV	; RESTORE OUTPUT DEVICE # TO WHAT IT WAS
00608  002229  85 67                   STA ODEV	;   BEFORE LAST STRING OUTPUT
00609  00222B  4C FF 22                JMP PROCES	;   AND CONTINUE EXECUTING ON THIS LINE
00610  
00611  ; "ERASE" COMMAND PROCESSOR
00612  
00613  00222E  20 B4 29      ERASE     JSR SPNOR	; GO GET NEXT NON-BLANK
00614  002231  A0 00                   LDY #$00	; this is not in the 6502 Group/ProgExch
00615  002233  C9 41                   CMP #$41	; 'A'   source code of 13-Oct-77   --dhh
00616  002235  F0 23                   BEQ EALL	;       occurs later at $225A
00617  002237  20 BF 25                JSR GETLN	; NO, GO GET THE LINE NUMBER TO ERASE
00618  00223A  08                      PHP		; SAVE FLAGS
00619  00223B  20 0A 27                JSR PUSHTP	; SAVE TEXT POINTERS
00620  00223E  28                      PLP		; GET FLAGS BACK
00621  00223F  70 0F                   BVS EVAR	; BRANCH IF JUST 'ERASE' WITH NO LINE NO.
00622  002241  F0 2C                   BEQ EGRP	; BRANCH IF WE ERASE A GROUP
00623  002243  20 80 26                JSR FINDLN	; NOW TRY AND LOCATE THE SPECIFIED LINE
00624  002246  B0 02                   BCS ERCONT	; BRANCH IF WE FOUND IT
00625  002248  00                      BRK	; TRAP
00626            .BYTE ENEXL	; ?ERASE OF NON-EXISTANT LINE (#$E8)
00627  00224A  20 4B 27      ERCONT    JSR DELETE	; GO ZAP THE LINE
00628  00224D  4C 31 20      ERDON     JMP START	; AND GO TO DIRECT COMMAND MODE
00629  002250  A9 FF         EVAR      LDA #EOV	; ERASE ALL THE VARIABLES
00630  002252  91 3E                   STA (VARBEG),Y	; BY FLAGGING LIST AS EMPTY
00631  002254  20 11 27                JSR POPTP	; RESTORE TEXT POINTERS
00632  002257  4C 02 23                JMP PROC	; AND CONTINUE PROCESSING THIS LINE
00633  00225A  A9 FE         EALL      LDA #EOP	; ERASE PROGRAM TEXT
00634  00225C  91 31                   STA (PBADR),Y	; EXCEPT GROUP ZERO
00635  00225E  A5 40                   LDA VARST	; UPDATE VARBEG
00636  002260  85 3E                   STA VARBEG
00637  002262  A5 41                   LDA VARST+1
00638  002264  85 3F                   STA VARBEG+1
00639  002266  A9 FF                   LDA #EOV
00640  002268  91 3E                   STA (VARBEG),Y	; FLAG VARIABLE LIST AS EMPTY
00641  00226A  D0 E1                   BNE ERDON	; AND START OVER
00642  00226C  20 4B 27      ELINE     JSR DELETE	; DELETE THE LINE
00643  00226F  20 18 27      EGRP      JSR TXTINI	; RESET TEXT POINTER TO START OF PROGRAM
00644  002272  20 80 26                JSR FINDLN	; TRY TO FIND THE GROUP
00645  002275  A5 51                   LDA TGRP	; GET GROUP NUMBER OF LINE FOUND
00646  002277  C5 2C                   CMP GRPNO     ; IS IT OF THE GROUP WE ARE DELETING?
00647  002279  F0 F1                   BEQ ELINE     ; BRANCH IF YES, GO DELETE IT
00648  00227B  D0 D0                   BNE ERDON     ; AND RETURN IF ALL LINES IN GRP DELETED
00649  
00650  ; WRITE CMD PROCESSOR: 'WRITE' OUT PARTS OF THE PROGRAM TEXT
00651  
00652  00227D  20 BC 25      WRITE     JSR GETLNS	; GO GET THE GROUP TO WRITE
00653  002280  08                      PHP		; SAVE CONDITION CODES
00654  002281  20 0A 27                JSR PUSHTP	; SAVE POSITION ON THIS LINE
00655  002284  E6 20                   INC DEBGSW	; DISABLE TRACE
00656  002286  28                      PLP		; GET CONDITION CODES AFTER 'GETLN'
00657  002287  70 2B                   BVS WALL	; BRANCH IF 'WRITE ALL'
00658  002289  D0 19                   BNE WLINE	; BRANCH IF WE WRITE A SINGLE LINE
00659  00228B  20 80 26      WGRP      JSR FINDLN	; TRY TO FIND THE GROUP
00660  00228E  A5 51                   LDA TGRP	; GET THE GROUP LOCATED IN MEMORY
00661  002290  C5 2C                   CMP GRPNO	; IS IT THE ONE WE ARE LOOKING FOR?
00662  002292  F0 02                   BEQ WGRP1	; BRANCH IF YES     
00663  002294  00                      BRK		; TRAP
00664            .BYTE WNEXG	; ?'WRITE' OF NON-EXISTANT GROUP (#$E1)
00665  002296  20 C0 22      WGRP1     JSR WGRPO	; OUTPUT THE GROUP
00666  002299  20 EB 22      WEXIT     JSR WCRLF	; BLANK LINE
00667  00229C  C6 20                   DEC DEBGSW	; ENABLE TRACE AGAIN
00668  00229E  20 11 27                JSR POPTP	; RESTORE TEXT POINTERS
00669  0022A1  4C 02 23                JMP PROC	;   AND CONTINUE PROCESSING ON THIS LINE
00670  0022A4  20 80 26      WLINE     JSR FINDLN	; TRY TO FIND THE LINE
00671  0022A7  B0 02                   BCS WLINE1	; BRANCH IF WE FOUND IT
00672  0022A9  00                      BRK		; TRAP
00673            .BYTE WNEXL	; ?'WRITE' OF NON-EXISTANT LINE (code #$EA)
00674  0022AB  20 EB 22      WLINE1    JSR WCRLF	; OUTPUT BLANK LINE
00675  0022AE  20 CD 22                JSR WONE	; OUTPUT THE SINGLE LINE
00676  0022B1  4C 99 22                JMP WEXIT	;   THEN EXIT 'WRITE' 
00677  0022B4  20 80 26      WALL      JSR FINDLN	; GO FIND GROUP ZERO (ALWAYS WINS)
00678  0022B7  20 C0 22      WALL1     JSR WGRPO	; OUTPUT THIS GROUP
00679  0022BA  F0 DD                   BEQ WEXIT	; BRANCH IF END OF PROGRAM
00680  0022BC  85 51                   STA TGRP	; MAKE EXIT GROUP THE GROUP TO OUTPUT
00681  0022BE  D0 F7                   BNE WALL1	;    AND GO OUTPUT IT
00682  0022C0  20 EB 22      WGRPO     JSR WCRLF	; OUTPUT BLANK LINE
00683  0022C3  20 CD 22      WGRPO1    JSR WONE	; OUTPUT THIS LINE
00684  0022C6  F0 04                   BEQ WEXGRP	; BRANCH IF END OF PROGRAM
00685  0022C8  C5 51                   CMP TGRP	; IS GROUP OF NEXT LINE THE SAME?
00686  0022CA  F0 F7                   BEQ WGRPO1	; BRANCH IF YES
00687  0022CC  60            WEXGRP    RTS		; OTHERWISE RETURN
00688  ;
00689  0022CD  20 31 26      WONE      JSR PRNTLN	; OUTPUT THE LINE NUMBER
00690  0022D0  20 92 29      WONEC     JSR GETC	; GET NEXT CHAR
00691  0022D3  20 02 29                JSR PRINTC	; OUTPUT IT
00692  0022D6  C9 0D                   CMP #$0D	; WAS IT THE END OF THE LINE?
00693  0022D8  D0 F6                   BNE WONEC	; LOOP IF NOT
00694  0022DA  A5 67                   LDA ODEV	; YES, ARE WE OUTPUTTING TO A STRING?
00695  0022DC  30 03                   BMI WEOL	; BRANCH IF WE ARE, DON'T FOLLOW WITH $0A
00696  0022DE  20 9E 2D                JSR OUTLF	; NO, THEN FOLLOW WITH A LINEFEED
00697  0022E1  20 D7 26      WEOL      JSR EATCR1	; YES, POINT TO NEXT LINE
00698  0022E4  A4 2A                   LDY TEXTP	; LOAD Y WITH OFFSET
00699  0022E6  B1 28                   LDA (TXTADR),Y	; PICK OF GRP NUMBER OF NEXT LINE
00700  0022E8  C9 FE                   CMP #EOP	; COMPARE TO END-OF-PROGRAM FLAG
00701  0022EA  60            WRET      RTS		; RETURN WITH Z=1 IF END OF PROGRAM
00702  			; RETURN WITH Z=0 IF NOT END OF PROGRAM
00703  0022EB  A5 67         WCRLF     LDA ODEV	; ARE WE OUTPUTTING TO A STRING?
00704  0022ED  30 FB                   BMI WRET	; BRANCH IF WE ARE, DON'T ADVANCE
00705  0022EF  4C 99 2D                JMP CRLF	; * PJMP * ELSE OUTPUT A CRLF AND RETURN
00706  
00707  ; MAIN CONTROL AND TRANSFER: 'GOTO' COMMAND
00708  
00709  0022F2  20 BC 25      GOTO      JSR GETLNS	; GO GET THE LINE NUMBER
00710  0022F5  20 80 26      GOTO1     JSR FINDLN	; NOW GO TRY TO FIND IT
00711  0022F8  B0 02                   BCS GCONT	; BRANCH IF WE FOUND IT
00712  0022FA  00                      BRK	; TRAP
00713            .BYTE $EB	; ?GOTO NON-EXISTANT LINE
00714  0022FC  20 25 27      GCONT     JSR NEWLIN	; GO SET UP THE NEW LINE
00715                          ; * PFALL * INTO PROCESS
00716  0022FF  20 92 29      PROCES    JSR GETC	; GET NEXT CHARACTER
00717  002302  A5 2B         PROC      LDA CHAR	; JUST IN CASE CALLED FROM ELSEWHERE
00718  002304  C9 0D                   CMP #$0D	; 'CR' END OF LINE?
00719  002306  F0 5B                   BEQ PC1	; IF SO, THEN RETURN
00720  002308  20 52 23                JSR GLTEST	; IS CHAR A TERMINATOR?
00721  00230B  F0 F2                   BEQ PROCES	; IF SO, IGNORE IT
00722  00230D  A6 2E                   LDX PRILVL	; GET CURRENT SOFTWARE INTERRUPT PRIO LVL
00723  00230F  A5 6D                   LDA ACTMSK	; GET BYTE THAT INDICATES WHICH CHAN ACTIVE
00724  002311  F0 13                   BEQ PROC1	; NONE ALLOWED TO HAPPEN, PRESS ON
00725  002313  3D 9D 35                AND $359D,X	; MASK OUT ANY NOT ALLOWED TO HAPPEN
00726  002316  F0 0E                   BEQ PROC1	; BRANCH IF NONE PENDING, PRESS ON
00727  002318  25 6E                   AND EVMASK	; NOW SEE IF ANY EVENT PENDING ON CHANNEL
00728  00231A  F0 0A                   BEQ PROC1	; BRANCH IF NONE PENDING, PRESS ON
00729  00231C  A2 08                   LDX #$08	; WE HAVE AN EVENT TO SERVICE (AT LEAST 1)
00730  00231E  DD A6 35      PRILOP    CMP BITTAB,X	; FIND HIGHEST PRIORITY ONE TO SERVICE
00731  002321  B0 43                   BCS EVNTDO	; BRANCH WHEN WE HAVE IT
00732  002323  CA                      DEX		; NOT THIS LEVEL, TRY LOWER
00733  002324  D0 F8                   BNE PRILOP	;   AND LOOP UNTIL WE FIND IT
00734  			; *** SHOULD NEVER FALL OUT THIS END! ***
00735  002326  A5 2B         PROC1     LDA CHAR	; GET CHARACTER WHICH STARTED COMMAND
00736  			;          handwritten note here in ProgExch code:
00737  			;                 " --* JMP EXIT" 
00738  002328  48                      PHA		; TEMPORARILY SAVE COMMAND CHARACTER
00739  002329  20 52 23      PTERM1    JSR GLTEST	; TERMINATOR?
00740  00232C  F0 05                   BEQ PTERM2	; BRANCH IF YES
00741  00232E  20 92 29                JSR GETC	; OTHERWISE, SKIP OVER REST OF COMMAND NAME
00742  002331  10 F6                   BPL PTERM1	; UNCONDITIONAL BRANCH
00743  002333  68            PTERM2    PLA		; GET 1ST CHAR OF CMD NAME BACK AGAIN
00744  002334  A2 00                   LDX #$00	; INIT TABLE OFFSET TO ZERO
00745  002336  BC 49 35      NXTCOM    LDY COMTAB,X	; GET THE COMMAND CHARACTER
00746  002339  F0 26                   BEQ ILLCOM	; ZERO ENDS THE TABLE
00747  00233B  DD 49 35                CMP COMTAB,X	; IS THIS CHARACTER THE COMMAND WE WANT?
00748  00233E  F0 03                   BEQ GOTCOM	; BRANCH IF YES
00749  002340  E8                      INX		; NO, POINT TO NEXT ONE
00750  002341  D0 F3                   BNE NXTCOM	; UNCONDITIONAL LOOP FOR NEXT ONE
00751  002343  BC 6F 35      GOTCOM    LDY COMADL,X	; GET LOW ORDER ADDR OF ROUTINE
00752  002346  8C 50 23                STY $2350     ; SAVE IN DUMMY JUMP (below)
00753  002349  BC 5D 35                LDY COMADH,X	; GET HIGH ORDER ADDR OF ROUTINE
00754  00234C  8C 51 23                STY $2351     ; SAVE IN DUMMY JUMP (next)
00755  00234F  4C 00 00                JMP $0000     ; DISPATCH TO COMMAND ROUTINE
00756  
00757  ; GLTEST EXITS WITH Z SET IF CHARACTER IN THE ACCUMULATOR
00758  ; IS A TERMINATOR (SPACE, COMMA, OR SEMI-COLON).
00759  
00760  002352  C9 20         GLTEST    CMP #$20	; SPACE?
00761  002354  F0 0A                   BEQ RTS2	; RETURN IF YES
00762  002356  C9 2C                   CMP #$2C	; COMMA?
00763  002358  F0 06                   BEQ RTS2	; RETURN IF YES
00764  00235A  C9 3B         TSTEOC    CMP #$3B	; SEMI-COLON?
00765  00235C  F0 02                   BEQ RTS2	; RETURN IF YES
00766  00235E  C9 0D                   CMP #$0D	; CARRIAGE RETURN?
00767  002360  60            RTS2      RTS		; RETURN WITH Z=1 IF ANY OF THESE
00768  002361  00            ILLCOM    BRK		; TRAP
00769            .BYTE $FD	; ?UNRECOGNIZABLE COMMAND
00770  002363  20 4B 28      PC1       JSR POPJ	; EXIT 'PROCESS'
00771    2363              COMMNT = PC1
00772  
00773  ; ROUTINE TO PERFORM A 'DO' OF A SPECIFIED LINE OR GROUP
00774  ; WHEN AN EXTERNAL EVENT HAPPENS ON A SOFTWARE INTERRUPT CHANNEL.
00775  
00776  002366  8A            EVNTDO    TXA		; SAVE X AS IT HAS LVL OF INTERUPT
00777  002367  48                      PHA		;   THEN SET UP RETURN ADDR ON STACK
00778  002368  A9 0C                   LDA #$0C	; label EVRET, def. as =PROCX-1
00779  00236A  20 31 28                JSR PUSHA	; ALA 'PUSHJ'
00780  00236D  A9 23                   LDA #$23	; MSB of EVRET address
00781  00236F  20 31 28                JSR PUSHA
00782  002372  20 B9 20                JSR PUSHDO	; SAVE IMPORTANT STUFF AT THIS LEVEL
00783  002375  68                      PLA		; GET NEW PRIO LEVEL OF GRP OR LN TO 'DO'
00784  002376  AA                      TAX
00785  002377  86 2E                   STX PRILVL	; SET IT AS OUT NEW PRIO LEVEL
00786  002379  BD A6 35                LDA BITTAB,X	; GET BIT MASK FOR THIS NEW LEVEL
00787  00237C  49 FF                   EOR #$FF	; COMPLIMENT TO MAKE 'AND' MASK
00788  00237E  08                      PHP		; SAVE STATE OF 'I' BIT IN CASE IRQS ARE ON
00789  00237F  78                      SEI		; DISABLE IRQ GRANTING
00790  002380  25 6E                   AND EVMASK	;   WHILE WE UPDATE EVENT MASK
00791  002382  85 6E                   STA EVMASK
00792  002384  28                      PLP		; WE CAN ALLOW IRQS AGAIN (IF ON)
00793  002385  BD 8B 35                LDA INTGRP,X	; GET THE GROUP NUMBER TO 'DO'
00794  002388  85 2C                   STA GRPNO
00795  00238A  BD 94 35                LDA INTLIN,X	;   AND THE LINE NUMBER
00796  00238D  85 2D                   STA LINENO
00797  00238F  20 05 26                JSR GOTLNO	; NOW SET FLAGS TO DETERMINE WHAT TO 'DO'
00798  002392  70 05                   BVS EVDALL	; BRANCH IF WE ARE 'DO'ING ALL
00799  002394  F0 03                   BEQ EVDALL	;   OR 'DO' OF A GROUP
00800  002396  4C C2 21                JMP DOONE	; *PJMP * 'DO' 1 LINE, RETURN TO 'EVRET'
00801  002399  4C D7 21      EVDALL    JMP DOGRP	; *PJMP * 'DO' A GROUP, RETURN TO 'EVRET'
00802  ;
00803  ; 'TYPE - ASK COMMAND PROCESSOR'
00804  ;
00805  00239C  20 76 2C      TDUMP     JSR VARINI	; INIT POINTER TO START OF VARIABLE LIST
00806  00239F  20 99 2D      TDNEXT    JSR CRLF	; START ON NEW LINE
00807  0023A2  A0 00                   LDY #$00	; POINT TO VARIABLE NAME
00808  0023A4  84 3B                   STY STRSWT	; MAKE SURE STRING SWITCH IS OFF
00809  0023A6  B1 37                   LDA (VARADR),Y	; PICK UP THE VARIABLE NAME
00810  0023A8  C9 FF                   CMP #EOV	; END OF VARIABLE LIST?
00811  0023AA  F0 52                   BEQ JTASK4	; BRANCH IF END OF VARIABLE LIST
00812  0023AC  C9 FC                   CMP #STRMRK	; STRING VARIABLE?
00813  0023AE  D0 05                   BNE TDCONT	; BRANCH IF NOT, PRESS ON
00814  0023B0  85 3B                   STA STRSWT	; YES, THEN FLAG IT
00815  0023B2  C8                      INY		;   AND MOVE PAST MARKER, POINT TO NAME
00816  0023B3  B1 37                   LDA (VARADR),Y	; AND PICK UP THE NAME
00817  0023B5  20 E7 23      TDCONT    JSR PRTVNM	; PRINT THE VARIABLE'S NAME
00818  0023B8  A5 3B                   LDA STRSWT	; IS THIS VARIABLE A STRING VARIABLE?
00819  0023BA  D0 45                   BNE TPSTR	; BRANCH IF YES, DO SPECIAL OUTPUT
00820  0023BC  A9 28                   LDA #$28	; '(' AND THEN START OF SUBSCRIPT
00821  0023BE  20 02 29                JSR PRINTC
00822  0023C1  A0 01                   LDY #$01	; POINT TO SUBSCRIPT
00823  0023C3  B1 37                   LDA (VARADR),Y	; GET HIGH ORDER SUBSCRIPT
00824  0023C5  85 81                   STA M1	; SAVE IN FAC1
00825  0023C7  C8                      INY		; POINT TO LOW ORDER SUBSCRIPT
00826  0023C8  B1 37                   LDA (VARADR),Y	; GET IT
00827  0023CA  85 82                   STA M1+1
00828  0023CC  20 4D 32                JSR FLT16	; FORM A FLOATING POINT NUMBER
00829  0023CF  20 5E 26                JSR OUTLN0	;   AND OUTPUT IT
00830  0023D2  A9 29                   LDA #$29	; ')' CLOSING PAREN
00831  0023D4  20 02 29                JSR PRINTC
00832  0023D7  A9 3D                   LDA #$3D	; '=' PUT IN AN EQUALS FOR FORM
00833  0023D9  20 02 29                JSR PRINTC
00834  0023DC  20 AE 2C                JSR FETVAR	; GET THE VARIABLE'S VALUE INTO FLAC
00835  0023DF  20 1F 33                JSR FPRNT	; PRINT IT
00836  0023E2  20 7F 2C                JSR NXTVAR	; POINT TO NEXT VARIABLE IN THE LIST
00837  0023E5  D0 B8                   BNE TDNEXT	; UNCONDITIONALLY LOOP FOR MORE
00838  ;
00839  ; ROUTINE TO PRINT OUT A VARIABLE'S NAME
00840  ;
00841  0023E7  48            PRTVNM    PHA		; SAVE COMPOSITE FORM
00842  0023E8  4A                      LSR  		; EXTRACT ALPHA PART
00843  0023E9  4A                      LSR  
00844  0023EA  4A                      LSR  
00845  0023EB  09 40                   ORA #$40	; FORM ASCII
00846  0023ED  C9 46                   CMP #$46	; 'F', ACTUALLY '&', SINCE 'F' IS ILLEGAL
00847  0023EF  D0 02                   BNE TPNAM	; NOT SPECIAL, SO PRINT IT
00848  0023F1  A9 26                   LDA #$26	; '&' PRINT A '&' AS SPECIAL VARIB NAME
00849  0023F3  20 02 29      TPNAM     JSR PRINTC	;   AND PRINT IT
00850  0023F6  68                      PLA		; GET BACK HASH
00851  0023F7  29 07                   AND #$07	; EXTRACT NUMBER
00852  0023F9  09 30                   ORA #$30	; FORM ASCII
00853  0023FB  4C 02 29                JMP PRINTC	; * PJMP * PRINT THE VARIB # THEN RETURN
00854  0023FE  4C D3 24      JTASK4    JMP TASK4	; BRANCH AID
00855  ; *** BEGIN MIKE B'S SECTION
00856  
00857                          ;
00858          ; HERE TO TYPE OUT A STRING VARIABLE
00859                          ;
00860  002401  A9 24         TPSTR   LDA #$24        ; '$' INDICATE IT'S A STRING VARIABLE
00861  002403  20 02 29              JSR PRINTC      ;
00862  002406  A9 3D                 LDA #$3D        ; '=' DON'T PRINT A SUBSCRIPT ON A $ VARIB
00863  002408  20 02 29              JSR PRINTC      ;
00864  00240B  A9 22                 LDA #$22        ; '"' DELIMIT STRING WITH QUOTES
00865  00240D  20 02 29              JSR PRINTC      ;
00866  002410  A0 02                 LDY #$02        ; POINT TO STRING LENGTH
00867  002412  B1 37                 LDA (VARADR),Y  ; PICK UP THE STRING LENGTH
00868  002414  85 3C                 STA VSIZE       ; SAVE IT
00869  002416  C8                    INY             ; POINT TO FIRST BYTE OF STRING
00870  002417  98                    TYA             ; NOW UPDATE 'VARADR' TO BASE ADDR OF $
00871  002418  20 81 2C              JSR UPDVAR      ;
00872  00241B  A0 00                 LDY #$00        ; POINT TO FIRST BYTE OF STRING
00873  00241D  98            TPNXTC  TYA             ; SAVE OFFSET
00874  00241E  48                    PHA             ;
00875  00241F  B1 37                 LDA (VARADR),Y  ; GET BYTE FROM STRING
00876  002421  20 02 29              JSR PRINTC      ; PRINT THE BYTE
00877  002424  68                    PLA             ; RESTORE POINTER
00878  002425  A8                    TAY             ;
00879  002426  C8                    INY             ; POINT TO NEXT BYTE
00880  002427  C4 3C                 CPY VSIZE       ; PRINTED ALL OF STRING YET?
00881  002429  D0 F2                 BNE TPNXTC      ; BRANCH IF MORE TO PRINT
00882  00242B  98                    TYA             ; YES, THEN SKIP OVER STRING BY
00883  00242C  20 81 2C              JSR UPDVAR      ;   UPDATING 'VARADR'
00884  00242F  A9 22                 LDA #$22        ; '"' CLOSE OFF STRING WITH CLOSING QUOTE
00885  002431  20 02 29              JSR PRINTC      ;
00886  002434  4C 9F 23              JMP TDNEXT      ; AND DUMP NEXT VARIABLE
00887                          ;
00888  002437  4C 9C 23      JTDUMP  JMP TDUMP       ; BRANCH AID
00889                          ;
00890          ; 'TYPE - ASK COMMAND PROCESSOR'
00891                          ; 
00892  00243A  20 1C 28      TASK1   JSR PUSHJ       ; GO GET THE VARIABLE
00893          .WORD GETVAR    ; ($1B43 in ww -- mtb)
00894  00243F  20 9B 2C              JSR BOMSTV      ; BOMB OUT IF A $ VARIABLE IS USED IN 'ASK'
00895  002442  A5 2B                 LDA CHAR        ; SAVE DELIMITER
00896  002444  48                    PHA             ;   ON HARDWARE STACK
00897  002445  E6 24                 INC INSW        ; FLAG INPUT FROM KEYBOARD
00898  002447  A2 37         ASKAGN  LDX #VARADR     ; SAVE THE VARIABLE'S ADDRESS
00899  002449  20 69 28              JSR PUSHB2      ;
00900  00244C  20 1C 28              JSR PUSHJ       ; NOW GO GET USER SUPPLIED DATA
00901          .WORD EVALM1    ; ($19F5 in ww -- mtb)
00902                          ;
00903  ;        LDA #$41        ; RESTORE 'ATSW' (SINCE WE MUST BE RECURSIVE!)
00904  ;        STA ATSW        ; (in ww -- mtb)
00905  002451  A2 38                 LDX #VARADR+1   ; RESTORE VARIABLE'S ADDRESS
00906  002453  20 59 28              JSR POPB2       ;
00907  002456  A5 2B                 LDA CHAR        ; GET DELIMITER FROM EVAL
00908  002458  C9 5F                 CMP #LINCHR     ; WAS IT 'LINE-DELETE' CHARACTER?
00909  00245A  D0 0B                 BNE STODAT      ; BRANCH IF NOT, STORE VALUE AWAY
00910  00245C  A5 66                 LDA IDEV        ; YES, IS THE INPUT DEVICE
00911  00245E  C5 6A                 CMP CONDEV      ;   THE CONSOLE?
00912  002460  D0 E5                 BNE ASKAGN      ; BRANCH IF NOT, ASK AGAIN
00913  002462  20 99 2D              JSR CRLF        ; YES, ADVANCE A LINE
00914  002465  10 E0                 BPL ASKAGN      ;   AND ASK AGAIN
00915  002467  20 A1 2C      STODAT  JSR PUTVAR      ; PLACE DATA IN VARIABLE
00916  00246A  C6 24                 DEC INSW        ; FLAG INPUT FROM CORE AGAIN
00917  00246C  68                    PLA             ; GET DELIMITER BACK AGAIN
00918  00246D  85 2B                 STA CHAR        ;
00919  00246F  10 13                 BPL TASK        ; UNCONDITIONALLY CONTINUE PROCESSING
00920                          ;
00921  002471  20 92 29      TFORM   JSR GETC        ; MOVE PAST '%'
00922  002474  20 BC 25              JSR GETLNS      ; GET GG.SS
00923  002477  A5 2C                 LDA GRPNO       ; GET GG
00924  002479  85 8F                 STA M           ; SAVE AS NUMBER BEFORE DECIMAL POINT
00925  00247B  A5 2D                 LDA LINENO      ; GET SS
00926  00247D  85 90                 STA N           ; SAVE AS NUMBER AFTER DECIMAL POINT
00927  00247F  4C 84 24              JMP TASK        ;   AND CONTINUE PROCESSING
00928                          ;
00929  002482  85 22         TYPE    STA ATSW        ; FLAG WHICH ONE IT IS
00930  002484  A9 00         TASK    LDA #$00        ; ENABLE THE TRACE
00931  002486  85 20                 STA DEBGSW      ;
00932  002488  20 B4 29              JSR SPNOR       ; LOOK FOR NEXT NON-BLANK
00933  00248B  C9 24                 CMP #$24        ; '$'
00934  00248D  F0 A8                 BEQ JTDUMP      ; DUMP OUT THE VARIABLE LIST
00935  00248F  C9 25                 CMP #$25        ; '%' FORMAT CONTROL?
00936  002491  F0 DE                 BEQ TFORM       ; BRANCH IF YES
00937  002493  C9 21                 CMP #$21        ; '!' SEE IF SPECIAL
00938  002495  F0 32                 BEQ TCRLF       ; GIVE OUT A CARRIAGE RETURN-LINE FEED
00939  002497  C9 23                 CMP #$23        ; '#'
00940  002499  F0 33                 BEQ TCR         ; CARRIAGE RETURN ONLY
00941  00249B  C9 22                 CMP #$22        ; '"'
00942  00249D  F0 39                 BEQ TQUOT       ; TYPE OUT A QUOTED STRING
00943  00249F  C9 2C                 CMP #$2C        ; ','
00944  0024A1  F0 30                 BEQ TASK4       ; IGNORE IN CASE USER WANTS IT TO LOOK PRETTY
00945  0024A3  C9 3B                 CMP #$3B        ; ';' END OF COMMAND?
00946  0024A5  F0 4A                 BEQ TPROC       ; YES, THEN BRANCH
00947  0024A7  C9 0D                 CMP #$0D        ; 'CR' END OF LINE?
00948  0024A9  F0 3F                 BEQ TPC1        ; YES, THEN GO HANDLE IT
00949  0024AB  A5 22                 LDA ATSW        ; NOT SPECIAL CHAR, GET COMMAND SWITCH
00950  0024AD  C9 41                 CMP #$41        ; 'A' WHICH COMMAND ARE WE DOING?
00951  0024AF  F0 89                 BEQ TASK1       ; BRANCH IF 'ASK', AS IT DIFFERS
00952  0024B1  20 1C 28              JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE THE EXPRESSION
00953          .WORD EVAL      ; ($19F8 in ww -- mtb)
00954  ;        LDA #$54        ; RESTORE 'ATSW' (SINCE WE MUST BE RECURSIVE!)
00955  ;        STA ATSW        ; (in ww -- mtb)
00956  0024B6  20 1F 33              JSR FPRNT       ; GO OUTPUT IT
00957  0024B9  A5 2B                 LDA CHAR        ; GET TERMINATOR FROM 'EVAL'
00958  0024BB  C9 29                 CMP #$29        ; ')' SO "TYPE 3)" DOESN'T DIE!
00959  0024BD  F0 14                 BEQ TASK4       ; FLUSH IF WE DON'T LIKE IT
00960  0024BF  C9 3D                 CMP #$3D        ; '=' ALSO FLUSH OTHER NASTIES
00961  0024C1  F0 10                 BEQ TASK4       ;
00962  0024C3  C9 2E                 CMP #$2E        ; '.'
00963  0024C5  F0 0C                 BEQ TASK4       ;
00964  0024C7  D0 BB                 BNE TASK        ; OTHERWISE, CONTINUE PROCESSING
00965                          ;
00966    2482              ASK     = TYPE          ; ($1488 in ww -- mtb)
00967                          ;
00968  0024C9  20 99 2D      TCRLF   JSR CRLF        ; OUTPUT A CR FOLLOWED BY A LF
00969  0024CC  10 05                 BPL TASK4       ; UNCONDITIONAL BRANCH
00970  0024CE  A9 0D         TCR     LDA #$0D        ; 'CR' OUTPUT A CARRIAGE RETURN
00971  0024D0  20 02 29              JSR PRINTC      ;
00972  0024D3  20 92 29      TASK4   JSR GETC        ; SKIP OVER THIS CHARACTER
00973  0024D6  10 AC                 BPL TASK        ; UNCONDITIONALLY CONTINUE PROCESSING
00974                          ;
00975  0024D8  E6 20         TQUOT   INC DEBGSW      ; DISABLE TRACE SO LITERAL ONLY PRINTS ONCE
00976  0024DA  20 92 29      TQUOT1  JSR GETC        ; GET NEXT CHAR
00977  0024DD  C9 22                 CMP #$22        ; '"' CLOSING QUOTE?
00978  0024DF  F0 F2                 BEQ TASK4       ; BRANCH IF YES
00979  0024E1  C9 0D                 CMP #$0D        ; 'CR' END OF LINE?
00980  0024E3  F0 05                 BEQ TPC1        ; BRANCH IF YES (IT TERMINATES STRING)
00981  0024E5  20 02 29              JSR PRINTC      ; OTHERWISE, PRINT THE CHARACTER
00982  0024E8  10 F0                 BPL TQUOT1      ; UNCONDITIONALLY LOOP UNTIL DONE
00983  0024EA  A9 00         TPC1    LDA #$00        ; ENABLE TRACE JUST IN CASE
00984  0024EC  85 20                 STA DEBGSW      ;
00985  0024EE  4C 63 23      FPC1    JMP PC1         ; EXIT 'PROCESS'
00986  0024F1  4C FF 22      TPROC   JMP PROCES      ; CONTINUE PROCESSING ON THIS LINE
00987                          ;
00988          ; "FOR" LOOP ITERATION COMMAND
00989                          ;
00990  0024F4  20 1C 28      FOR     JSR PUSHJ       ; GO GET THE VARIABLE (mtb)
00991          .WORD GETVAR    ; ($2B51; $1B43 in ww -- mtb)
00992  0024F9  A5 2B                 LDA CHAR        ; GET TERMINATOR
00993  0024FB  C9 3D                 CMP #$3D        ; '=' SIGN?
00994  0024FD  F0 02                 BEQ FOR2        ; BRANCH IF YES
00995  0024FF  00                    BRK             ; NO, TRAP
00996          .BYTE NOEQLS    ; ?NO '=' IN 'FOR' OR 'SET' (#$F3)
00997  002501  A2 37         FOR2    LDX #VARADR     ; SAVE THE ADDRESS OF THE VARIABLE
00998  002503  A0 05                 LDY #$05        ;   AND ITS PROPERTIES
00999  002505  20 6B 28              JSR PUSHB0      ;   ON STACK
01000  002508  20 1C 28              JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE RIGHT HAND
01001          .WORD EVALM1    ;    SIDE OF '=' ($2A03; $19F5 in ww -- mtb)
01002  00250D  A2 3B                 LDX #VARADR+4   ; GET ADDR OF VARIABLE BACK AGAIN
01003  00250F  A0 05                 LDY #$05        ;
01004  002511  20 5B 28              JSR POPB0       ;
01005  002514  20 9B 2C              JSR BOMSTV      ; BOMB OUT IF LOOP COUNTER IS STR. VARIB.
01006  002517  20 A1 2C              JSR PUTVAR      ; NOT A STRING, SO STORE INITIAL VALUE
01007  00251A  A5 2B                 LDA CHAR        ; GET THE EXPRESSION TERMINATOR
01008  00251C  C9 2C                 CMP #$2C        ; ',' COMMA?
01009  00251E  F0 10                 BEQ FINCR       ; BRANCH IF IT'S A 'FOR' COMMAND
01010  002520  00            BTFOR   BRK             ; TRAP
01011          .BYTE FBDTRM    ; ?BAD TERMINATOR IN 'FOR' (#$F2)
01012                          ;
01013          ; "SET" COMMAND
01014                          ;
01015  ;SET1    JSR GETC        ; SKIP OVER COMMA (in ww -- mtb)
01016  002522  20 1C 28      SET     JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE EXPRESSION
01017          .WORD EVALM1    ; 'EVALM1' ($2A03; $19F5 was 'EVAL' $19F8 in ww -- mtb)
01018  002527  A5 2B                 LDA CHAR        ; GET TERMINATOR
01019  002529  C9 2C                 CMP #$2C        ; ',' COMMA?
01020  00252B  F0 F5                 BEQ SET         ; BRANCH IF YES, LOOP FOR ANOTHER EXPRESS (SET1 in ww -- mtb)
01021  00252D  4C 02 23              JMP PROC        ; NO. ALL DONE, CONTINUE ON THIS LINE
01022                          ;
01023  ; there is a handwritten note here: 'Best cmmd exit points $1304'
01024  ; ($2302 in this Aresco version code)
01025                          ;
01026                          ;
01027          ; 'FOR' COMMAND PROCESSING
01028                          ;
01029  002530  A2 37         FINCR   LDX #VARADR     ; SAVE THE ADDR OF THE LOOP VARIABLE ON STACK
01030  002532  20 69 28              JSR PUSHB2      ;
01031  002535  20 1C 28              JSR PUSHJ       ; GO GET THE INCREMENT
01032          .WORD EVALM1    ; ($2A03; $19F5 in ww -- mtb)
01033  00253A  A5 2B                 LDA CHAR        ; GET TERMINATOR
01034  00253C  C9 2C                 CMP #$2C        ; ',' DID WE GET AN INCREMENT?
01035  00253E  F0 16                 BEQ FLIMIT      ; YES, GO GET THE UPPER LIMIT OF LOOP
01036  002540  C9 3B                 CMP #$3B        ; ';' WAS NO INCREMENT SPECIFIED?
01037  002542  F0 06                 BEQ FINCR1      ; BRANCH IF NO INCREMENT GIVEN
01038  002544  C9 0D                 CMP #$0D        ; 'CR' CARRIAGE RETURN?
01039  002546  D0 D8                 BNE BTFOR       ; NO, THEN BAD TERMINATOR
01040  002548  00                    BRK             ; YES, TRAP
01041          .BYTE UFL       ; ?USELESS 'FOR' LOOP (#$F1)
01042  00254A  A2 FB         FINCR1  LDX #$FB        ; GET NEGATIVE OF NUMBER OF BYTES (-5)
01043  00254C  B5 A0         FI1C    LDA FONE+NUMBF,X ; GET NEXT BYTE
01044  00254E  20 31 28              JSR PUSHA       ; PUSH IT ON STACK
01045  002551  E8                    INX             ; POINT TO NEXT ONE
01046  002552  30 F8                 BMI FI1C        ;   AND LOOP UNTIL ALL PUSHED
01047  002554  10 08                 BPL FSHORT      ; UNCONDITIONAL BRANCH
01048  002556  20 79 28      FLIMIT  JSR PHFAC1      ; SAVE INCREMENT ON STACK
01049  002559  20 1C 28              JSR PUSHJ       ; NOW EVALUATE THE UPPER LIMIT
01050          .WORD EVALM1    ; ($2A03; $19F5 in ww -- mtb)
01051  00255E  20 79 28      FSHORT  JSR PHFAC1      ; SAVE UPPER LIMIT ON STACK AND ENTER LOOP
01052                          ;
01053          ; 'LOOP PROCESSOR FOR "FOR" COMMAND'
01054                          ;
01055  002561  20 0A 27      FCONT   JSR PUSHTP      ; NOW SAVE THE TEXT POINTERS ON STACK
01056  002564  A5 26                 LDA PC          ; SAVE PC ACROSS CALL
01057  002566  20 31 28              JSR PUSHA       ;
01058  002569  20 1C 28              JSR PUSHJ       ; NOW EXECUTE THE REST OF THE LINE
01059          .WORD PROCES    ; 'PROCES' ($22FF; $1301 in ww -- mtb)
01060  00256E  20 3F 28              JSR POPA        ; SET PC BACK
01061  002571  85 73                 STA ITEMP1      ; SAVE IT IN TEMPORARY
01062  002573  20 11 27              JSR POPTP       ; SAVE POINTERS FOR POSSIBLE RE-ENTRY
01063  002576  20 A5 28              JSR PLTMP       ; RESTORE UPPER LOOP LIMIT INTO TEMPORARY
01064  002579  20 C3 2C              JSR POPIV       ; RESTORE INCREMENT AND VARIABLE ADDR
01065  00257C  A5 26                 LDA PC          ; GET PC
01066  00257E  C9 FD                 CMP #RETCMD     ; WAS A 'RETURN' COMMAND JUST EXECUTED?
01067  002580  F0 22                 BEQ FORXIT      ; BRANCH IF YES, THEN EXIT THE LOOP NOW!
01068  002582  A5 7C                 LDA M2          ; GET THE SIGN OF THE INCREMENT (+ OR -)
01069  002584  08                    PHP             ; SAVE STATUS ON STACK FOR LATER
01070  002585  20 BB 2C              JSR PUSHIV      ; SAVE AGAIN FOR POSSIBLE REPEAT OF LOOP
01071  002588  20 AE 2C              JSR FETVAR      ; GO GET THE VARIABLE'S CURRENT VALUE
01072  00258B  20 79 32              JSR FADD        ; ADD THE INCREMENT TO FLAC
01073  00258E  20 A1 2C              JSR PUTVAR      ; STORE AS NEW LOOP COUNTER VALUE
01074  002591  20 8F 28              JSR PHTMP       ; SAVE TEMPORARY ON STACK
01075  002594  20 9A 28              JSR PLFAC2      ; PLACE INTO FAC2
01076  002597  20 73 32              JSR FSUB        ; SUBTRACT COUNTER FROM UPPER LIMIT (mtb)
01077  00259A  28                    PLP             ; GET SIGN OF THE INCREMENT
01078  00259B  30 0E                 BMI CNTDWN      ; BRANCH IF NEGATIVE, WE ARE COUNTING DOWN
01079  00259D  A5 81                 LDA FLCSGN      ; GET THE SIGN OF THE NUMBER
01080  00259F  10 10                 BPL MORFOR      ; BRANCH IF REPEAT NECESSARY
01081  0025A1  20 C3 2C      FOREND  JSR POPIV       ; CLEAN UP STACK
01082  0025A4  A5 73         FORXIT  LDA ITEMP1      ; RESTORE PC
01083  0025A6  85 26                 STA PC          ;   IN CASE 'RETURN' ENCOUNTERED
01084  0025A8  20 4B 28              JSR POPJ        ; EXIT 'FOR' COMMAND
01085  0025AB  A5 81         CNTDWN  LDA FLCSGN      ; ARE WE LESS THAN THE LOOP LIMIT?
01086  0025AD  F0 02                 BEQ MORFOR      ; NO, THEN KEEP GOING
01087  0025AF  10 F0                 BPL FOREND      ; YES, THEN THAT'S ALL
01088  0025B1  20 8F 28      MORFOR  JSR PHTMP       ; PLACE UPPER LIMIT BACK ON THE STACK
01089  0025B4  10 AB                 BPL FCONT       ; UNCONDITIOANALLY REPEAT LOOP
01090                          ;
01091          ; LINE NUMBER MANIPULATION ROUTINES
01092                          ;
01093          ; "GETLN" GET A LINE NUMBER FROM PROGRAM TEXT.
01094          ; RETURNS WITH V=1 IF "ALL" (00.00), OTHERWISE
01095          ; IT RETURNS WITH Z=1 IF GROUP NUMBER ONLY (GG.00)
01096          ; AND Z=0 IF INDIVIDUAL LINE NUMBER (GG.LL).
01097                          ;
01098  0025B6  20 27 34      GETLNC  JSR FINP        ; ONLY ALLOW NUMERIC INPUT
01099  0025B9  4C DF 25              JMP GETLN1      ;   AND ENTER REST OF CODE
01100                          ;
01101  0025BC  20 B4 29      GETLNS  JSR SPNOR       ; GET NEXT NON-BLANK
01102  0025BF  A9 00         GETLN   LDA #$00        ; ASSUME LINE NUMBER IS ZERO
01103  0025C1  85 2C                 STA GRPNO       ;
01104  0025C3  85 2D                 STA LINENO      ;
01105  0025C5  A5 2B                 LDA CHAR        ; GET FIRST CHARACTER OF EXPRESSION?
01106  0025C7  C9 2C                 CMP #$2C        ; ',' IS EXPRESSION NULL?
01107  0025C9  F0 3A                 BEQ GOTLNO      ; BRANCH IF YES, THEN WE HAVE THE NUMBER
01108  0025CB  C9 0D                 CMP #$0D        ; 'CR' ANOTHER FORM OF NULL?
01109  0025CD  F0 36                 BEQ GOTLNO      ; BRANCH IF YES, THEN WE HAVE THE NUMBER
01110  0025CF  20 BE 29              JSR TESTN       ; DOES EXPRESSION BEGIN WITH A NUMBER?
01111  0025D2  B0 06                 BCS GETLNX      ; BRANCH IF NOT, THEN MUST BE COMPLEX 
01112  0025D4  20 A3 2D              JSR GETILN      ; CALL INTEGER LINE NUMBER INPUT FOR SPEED
01113  0025D7  4C 05 26              JMP GOTLNO      ; WE NOW HAVE THE LINE NUMBER
01114  0025DA  20 1C 28      GETLNX  JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE EXPRESSION
01115          .WORD EVAL      ; ($2A06; $19F8 in ww -- mtb)
01116  0025DF  20 79 28      GETLN1  JSR PHFAC1      ; SAVE EXPRESSION VALUE ON STACK
01117  0025E2  20 16 26              JSR GETL        ; INTEGERIZE AND RANGE CHECK
01118  0025E5  85 2C                 STA GRPNO       ; SAVE AS GROUP NUMBER
01119  0025E7  20 39 32              JSR FLOAT       ; NOW FLOAT THE GROUP NUMBER
01120  0025EA  20 9A 28              JSR PLFAC2      ; POP FULL GG.SS INTO FAC2
01121  0025ED  20 73 32              JSR FSUB        ; SUBTRACT OFF THE GROUP NUMBER (mtb)
01122  0025F0  20 27 26              JSR GMUL10      ; MULTIPLY BY 100
01123  0025F3  20 27 26              JSR GMUL10      ;
01124  0025F6  A2 96                 LDX #FHALF      ; MOVE CONSTANT .50
01125  0025F8  A0 7B                 LDY #X2         ;
01126  0025FA  20 FF 33              JSR MOVXY       ;
01127  0025FD  20 79 32              JSR FADD        ; NOW ADD IN THE .50 FOR ROUNDING
01128  002600  20 16 26              JSR GETL        ; INTEGERIZE AND RANGE CHECK
01129  002603  85 2D                 STA LINENO      ; SAVE AS LINE NUMBER (STEP NUMBER)
01130  002605  B8            GOTLNO  CLV             ; ASSUME NOT 00.00
01131  002606  A5 2C                 LDA GRPNO       ; GET GROUP NUMBER
01132  002608  05 2D                 ORA LINENO      ; 'OR' IN THE LINE NUMBER
01133  00260A  F0 07                 BEQ GOTALL      ; BRANCH IF BOTH ARE ZERO
01134  00260C  A5 2C                 LDA GRPNO       ; GET GROUP NUMBER AGAIN
01135  00260E  F0 15                 BEQ BADLNO      ; BAD LINE NUMBER IS GROUP ONLY IS ZERO
01136  002610  A5 2D                 LDA LINENO      ; GROUP NUMBER OK, GET LINE (STEP) NO.
01137  002612  60            RTS3    RTS             ; RETURN WITH Z=1 IF GROUP ONLY
01138                          ;
01139  002613  24 6F         GOTALL  BIT BITV1       ; EXIT WITH V=1, (n=1 ??)
01140  002615  60                    RTS             ;
01141                          ;
01142          ; 'LINE NUMBER MANIPULATION ROUTINES'
01143                          ;
01144  002616  20 18 33      GETL    JSR FIX         ; FIX THE NUMBER IN FAC1
01145  002619  A5 81                 LDA M1          ; GET HIGH ORDERS
01146  00261B  05 82                 ORA M1+1        ; SMASH THEM TOGETHER
01147  00261D  D0 06                 BNE BADLNO      ; LINE NUMBER CAN ONLY BE POSITIVE
01148  00261F  A5 83                 LDA M1+2        ;
01149  002621  C9 64                 CMP #$64        ; AND < 100 ?
01150  002623  30 ED                 BMI RTS3        ;
01151  002625  00            BADLNO  BRK             ; TRAP
01152          .BYTE ILLNO     ; ILLEGAL LINE NUMBER (#$FC)
01153  002627  A2 91         GMUL10  LDX #FTEN       ; MOVE 10.0
01154  002629  A0 7B                 LDY #X2         ;   INTO FAC2
01155  00262B  20 FF 33              JSR MOVXY       ;
01156  00262E  4C A0 32              JMP FMUL        ; * PJMP *  FAC1*FAC2=FAC1
01157                          ;
01158          ; 'PRINTLN - PRINT A LINE NUMBER'
01159                          ; 
01160          ; "PRINTLN" PRINT A LINE NUMBER TO OUTPUT DEVICE
01161                          ; 
01162  002631  A4 2A         PRNTLN  LDY TEXTP       ; GET TEXT POINTER
01163  002633  B1 28                 LDA (TXTADR),Y  ; GET GROUP NUMBER
01164  002635  D0 05                 BNE PRNTL1      ; BRANCH IF NOT ZERO
01165  002637  C8                    INY             ; DO NOT PRINT GROUP ZERO LINE NUMBERS
01166  002638  C8                    INY             ;
01167  002639  84 2A                 STY TEXTP       ; POINT TO FIRST CHARACTER IN LINE
01168  00263B  60                    RTS             ;   AND RETURN
01169                          ;
01170  00263C  48            PRNTL1  PHA             ; SAVE THE GROUP NUMBER FOR LATER
01171  00263D  C8                    INY             ; POINT TO THE STEP NUMBER
01172  00263E  B1 28                 LDA (TXTADR),Y  ; GET STEP NUMBER
01173  002640  C8                    INY             ; MOVE PAST IT
01174  002641  84 2A                 STY TEXTP       ; SAVE POINTER
01175  002643  20 77 26              JSR PFLT        ; FLOAT THE STEP NUMBER
01176  002646  20 11 34              JSR DIV10       ; DIVIDE BY 100
01177  002649  20 11 34              JSR DIV10       ;
01178  00264C  20 79 28              JSR PHFAC1      ; SAVE 00.SS FOR LATER
01179  00264F  68                    PLA             ; GET THE GROUP NUMBER BACK
01180  002650  20 77 26              JSR PFLT        ; FLOAT IT
01181  002653  20 9A 28              JSR PLFAC2      ; RESTORE 00.SS INTO FAC2
01182  002656  20 79 32              JSR FADD        ; ADD TOGETHER TO FORM GG.SS
01183                          ; * PFALL * INTO OUTPUT ROUTINE
01184  002659  A9 02                 LDA #$02        ; ASSUME TWO DIGITS BEFORE THE DECIMAL PT.
01185  00265B  AA                    TAX             ;   AND TWO DIGITS AFTER
01186  00265C  D0 04                 BNE OUTLN       ; UNCONDITIONAL BRANCH
01187  00265E  A9 02         OUTLN0  LDA #$02        ; ASSUME TWO DIGITS BEFORE DECIMAL
01188  002660  A2 00         OUTLN1  LDX #$00        ; ASSUME NO DECIMAL POINT (mtb)
01189  002662  A8            OUTLN   TAY             ; SAVE NUMBER BEFORE DECIMAL IN Y REG
01190  002663  A5 8F                 LDA M           ; SAVE OLD FORMAT ON HARDWARE STACK (mtb)
01191  002665  48                    PHA             ; (COULD BE CALLED FROM ERROR TRAP)
01192  002666  A5 90                 LDA N           ;
01193  002668  48                    PHA             ;
01194  002669  84 8F                 STY M           ; STORE NEW FORMAT
01195  00266B  86 90                 STX N           ;
01196  00266D  20 1F 33              JSR FPRNT       ; PRINT NUMBER IN TEMPORARY FORMAT
01197  002670  68                    PLA             ; RESTORE OLD FORMAT
01198  002671  85 90                 STA N           ;
01199  002673  68                    PLA             ;
01200  002674  85 8F                 STA M           ;
01201  002676  60                    RTS             ; AND RETURN
01202                          ;
01203  002677  85 82         PFLT    STA M1+1        ; SAVE IN LOW ORDER
01204  002679  A9 00                 LDA #$00        ; MAKE HIGH ORDER ZERO
01205  00267B  85 81                 STA M1          ;
01206  00267D  4C 4D 32              JMP FLT16       ; * PJMP * AND FLOAT IT
01207                          ;
01208          ; 'FINDLN - FIND A LINE IN THE STORED PROGRAM'
01209                          ; 
01210          ; "FINDLN"  RETURNS WITH C=1 IF THE LINE WAS FOUND.
01211          ;           TXTAD2 POINTS TO THE GROUP NUMBER,
01212          ;           RETURNS WITH C=0 IF THE LINE WAS NOT LOCATED
01213          ;           TXTAD2 POINTS TO THE GROUP NUMBER OF THE NEXT HIGHEST NO.
01214          ;           (I.E., WHERE YOU WOULD INSERT THIS LINE)
01215                          ; 
01216  002680  A5 2C         FINDLN  LDA GRPNO       ; PLACE LINE NUMBER OF LINE WE ARE
01217  002682  85 5A                 STA ITMP2H      ;   LOOKING FOR INTO TEMPORARY
01218  002684  A5 2D                 LDA LINENO      ; STEP PART ALSO
01219  002686  85 59                 STA ITMP2L      ;
01220  002688  A9 00                 LDA #$00        ; SET FLAG INDICATING FIRST SEARCH
01221  00268A  85 3B                 STA FSWIT       ;
01222  00268C  85 2A                 STA TEXTP       ; ALSO RESET TEXT POINTER TO BEGINNING OF
01223  00268E  A5 26                 LDA PC          ;   CURRENT LINE. IS CURR LN DIRECT CMD?
01224  002690  10 05                 BPL CHKLIN      ; NO, THEN START SEARCHING FOR PRESENT POS
01225  002692  20 18 27      FNDINI  JSR TXTINI      ; YES, THEN RESET TEXT POINTERS TO START
01226  002695  E6 3B                 INC FSWIT       ;   OF PROGRAM, INDICATE LAST SEARCH
01227  002697  A4 2A         CHKLIN  LDY TEXTP       ; GET TEXT POINTER
01228  002699  B1 28                 LDA (TXTADR),Y  ; GET THE GROUP NUMBER
01229  00269B  C9 FE                 CMP #EOP        ; END OF TEXT?
01230  00269D  F0 23                 BEQ NOFIND      ; BRANCH IF YES
01231  00269F  85 56                 STA ITMP1H      ; SAVE FOR COMPARISON
01232  0026A1  85 51                 STA TGRP        ; ALSO SAVE IN CASE THIS ONE IS IT
01233  0026A3  C8                    INY             ; POINT TO STEP NUMBER
01234  0026A4  B1 28                 LDA (TXTADR),Y  ; GET IT
01235  0026A6  85 55                 STA ITMP1L      ; SAVE IT FOR COMPARISON
01236  0026A8  85 52                 STA TLINE       ; ALSO SAVE IN CASE THIS IS IT
01237  0026AA  C8                    INY             ; POINT TO FIRST CHAR IN LINE
01238  0026AB  84 2A                 STY TEXTP       ; UPDATE TEXT POINTER
01239  0026AD  38                    SEC             ; SET UP FOR SUBTRACT
01240  0026AE  A5 55                 LDA ITMP1L      ; GET LOW ORDER
01241  0026B0  E5 59                 SBC ITMP2L      ;
01242  0026B2  85 55                 STA ITMP1L      ; SAVE FOR LATER
01243  0026B4  A5 56                 LDA ITMP1H      ; NOW HIGH ORDERS
01244  0026B6  E5 5A                 SBC ITMP2H      ;
01245  0026B8  30 0E                 BMI FNEXT       ; BRANCH IF THE ONE IN THE TEXT AREA IS <
01246  0026BA  05 55                 ORA ITMP1L      ; NOT BIGGER, IS IT EQUAL?
01247  0026BC  F0 0F                 BEQ FOUNDL      ; BRANCH IF WE LOCATE THE LINE
01248  0026BE  A5 3B                 LDA FSWIT       ; LAST SEARCH ATTEMPT?
01249  0026C0  F0 D0                 BEQ FNDINI      ; BRANCH IF NOT, TRY AGAIN FROM START OF
01250                          ;   PROGRAM
01251  0026C2  18            NOFIND  CLC             ; FLAG THE FACT WE DIDN'T FIND IT
01252  0026C3  A0 00         FNEXIT  LDY #$00        ; RESET POINTER TO GROUP NUMBER
01253  0026C5  84 2A                 STY TEXTP       ;
01254  0026C7  60                    RTS             ;
01255  0026C8  20 D0 26      FNEXT   JSR EATCR       ; FLUSH TO START OF NEXT LINE
01256  0026CB  10 CA                 BPL CHKLIN      ; UNCONDITIONALLY LOOP FOR MORE
01257  0026CD  38            FOUNDL  SEC             ; FLAG THE FACT WE FOUND IT
01258  0026CE  B0 F3                 BCS FNEXIT      ;   AND RETURN
01259                          ;
01260          ; UTILITY ROUTINES FOR TEXT MANIPULATION
01261                          ;
01262          ; FLUSH UNTIL A CARRIAGE RETURN
01263                          ;
01264  0026D0  E6 20         EATCR   INC DEBGSW      ; DISABLE TRACE
01265  0026D2  20 92 29      EATCRC  JSR GETC        ; GET NEXT CHAR
01266  0026D5  10 02                 BPL EATCNT      ; UNCONDITIONAL BRANCH
01267  0026D7  E6 20         EATCR1  INC DEBGSW      ; DISABLE TRACE
01268  0026D9  A5 2B         EATCNT  LDA CHAR        ; GET THE CHAR
01269  0026DB  C9 0D                 CMP #$0D        ; 'CR' ?
01270  0026DD  D0 F3                 BNE EATCRC      ; BRANCH IF NOT
01271  0026DF  A5 28                 LDA TXTADR      ; YES, CALCULATE THE START OF NEXT LINE
01272  0026E1  18                    CLC             ;
01273  0026E2  65 2A                 ADC TEXTP       ; ADD IN THE TEXT POINTER
01274  0026E4  85 28                 STA TXTADR      ; SAVE IN POINTER
01275  0026E6  85 33                 STA TXTAD2      ;   AND ALTERNATE POINTER
01276  0026E8  A5 29                 LDA TXTADR+1    ; NOW HIGH ORDER
01277  0026EA  69 00                 ADC #$00        ;
01278  0026EC  85 29                 STA TXTADR+1    ;
01279  0026EE  85 34                 STA TXTAD2+1    ; AND ALTERNATE POINTER
01280  0026F0  A9 00                 LDA #$00        ; AND RESET THE POINTER
01281  0026F2  85 2A                 STA TEXTP       ;
01282  0026F4  85 35                 STA TEXTP2      ;
01283  0026F6  C6 20                 DEC DEBGSW      ; ALLOW TRACE AGAIN
01284  0026F8  60                    RTS             ;   AND RETURN
01285                          ;
01286          ; FLUSH UNTIL END OF COMMAND (SEMI-COLON OR CARRIAGE RETURN)
01287                          ;
01288  0026F9  20 92 29      EATEC1  JSR GETC        ; GET NEXT CHAR
01289  0026FC  10 02                 BPL EATECC      ; UNCONDITIONAL BRANCH
01290  0026FE  E6 20         EATECM  INC DEBGSW      ; TURN OFF TRACE
01291  002700  A5 2B         EATECC  LDA CHAR        ; GET THE CHAR
01292  002702  20 5A 23              JSR TSTEOC      ; GO SEE IF ';' OR CARRIAGE RETURN
01293  002705  D0 F2                 BNE EATEC1      ; BRANCH IF NOT
01294  002707  C6 20                 DEC DEBGSW      ; ENABLE TRACE AGAIN
01295  002709  60                    RTS             ;   AND RETURN
01296                          ;
01297          ; PUSH THE TEXT POINTERS ON THE STACK
01298                          ;
01299  00270A  A2 28         PUSHTP  LDX #TXTADR     ;
01300  00270C  A0 04                 LDY #$04        ; THREE PLUS 'CHAR'
01301  00270E  4C 6B 28              JMP PUSHB0      ; * PJMP *
01302                          ;
01303          ; POP THE TEXT POINTERS OFF THE STACK
01304                          ;
01305  002711  A2 2B         POPTP   LDX #TXTADR+3   ;
01306  002713  A0 04                 LDY #$04        ;
01307  002715  4C 5B 28              JMP POPB0       ; * PJMP *
01308                          ;
01309          ; INIT TEXT POINTER TO BEGINNING OF TEXT
01310                          ;
01311  002718  A5 2F         TXTINI  LDA TXTBEG      ; POINT TO START OF STORED TEXT
01312  00271A  85 28                 STA TXTADR      ;
01313  00271C  A5 30                 LDA TXTBEG+1    ;
01314  00271E  85 29                 STA TXTADR+1    ;
01315  002720  A9 00                 LDA #$00        ; INIT OFFSET TO ZERO
01316  002722  85 2A                 STA TEXTP       ;
01317  002724  60                    RTS             ;
01318                          ;
01319          ; 'NEWLIN' SETUP TEXT POINTERS AND PC FOR NEW LINE NUMBER
01320                          ;
01321  002725  A5 2C         NEWLIN  LDA GRPNO       ; GET THE LINE NUMBER
01322  002727  85 26                 STA PC          ; STORE IN THE PROGRAM COUNTER
01323  002729  A5 2D                 LDA LINENO      ;
01324  00272B  85 27                 STA PC+1        ;
01325  00272D  A0 02                 LDY #$02        ; POINT TO FIRST CHAR 0N LINE
01326  00272F  84 2A                 STY TEXTP       ;
01327  002731  60                    RTS             ; AND RETURN
01328                          ;
01329          ; 'NXTLIN' SETUP TEXT POINTERS AND PC FOR NEXT LINE NUMBER
01330                          ;
01331  002732  A4 2A         NXTLIN  LDY TEXTP       ; GET TEXT POINTER
01332  002734  B1 28                 LDA (TXTADR),Y  ; PICK UP GROUP NUMBER
01333  002736  C9 FE                 CMP #EOP        ; END OF PROGRAM?
01334  002738  F0 0F                 BEQ NONEXT      ; BRANCH IF NO NEXT LINE
01335  00273A  85 26                 STA PC          ; SAVE AS NEW LINE NUMBER
01336  00273C  C8                    INY             ;
01337  00273D  B1 28                 LDA (TXTADR),Y  ; GET STEP NUMBER
01338  00273F  85 27                 STA PC+1        ; STORE IT
01339  002741  C8                    INY             ; POINT TO FIRST CHAR ON THE LINE
01340  002742  84 2A                 STY TEXTP       ;
01341  002744  20 92 29              JSR GETC        ; GET THE FIRST CHAR OF NEW LINE
01342  002747  38                    SEC             ; FLAG THE FACT WE HAVE A NEW LINE
01343  002748  60                    RTS             ;   AND RETURN
01344  002749  18            NONEXT  CLC             ; INDICATE WE HAVE NO NEW LINE
01345  00274A  60                    RTS             ;   AND RETURN
01346                          ;
01347          ; 'DELETE' A LINE OF STORED PROGRAM
01348                          ;
01349  00274B  20 0A 27      DELETE  JSR PUSHTP      ; SAVE TEXT POINTERS
01350  00274E  A0 02                 LDY #$02        ; SKIP OVER LINE NUMBER
01351  002750  84 2A                 STY TEXTP       ;
01352  002752  20 D0 26              JSR EATCR       ; SKIP TO THE CARRIAGE RETURN
01353  002755  20 11 27              JSR POPTP       ; RESTORE POINTER TO START OF LINE TO ZAP
01354  002758  20 0A 27              JSR PUSHTP      ;   BUT KEEP THEM AROUND
01355  00275B  A0 00                 LDY #$00        ; SET OFFSET TO ZERO
01356  00275D  B1 33         DMVLOP  LDA (TXTAD2),Y  ; GET A CHAR
01357  00275F  91 28                 STA (TXTADR),Y  ; MOVE IT DOWN
01358  002761  C9 FE                 CMP #EOP        ; END OF TEXT REACHED YET?
01359  002763  F0 09                 BEQ DELDON      ; BRANCH IF YES
01360  002765  C8                    INY             ; NO, POINT TO NEXT CHAR TO MOVE
01361  002766  D0 F5                 BNE DMVLOP      ; BRANCH IF NO OVERFLOW ON OFFSET
01362  002768  E6 29                 INC TXTADR+1    ; OVERFLOW, BUMP HIGH ORDERS
01363  00276A  E6 34                 INC TXTAD2+1    ;
01364  00276C  D0 EF                 BNE DMVLOP      ; UNCONDITIONALLY MOVE NEXT BYTE
01365  00276E  C8            DELDON  INY             ;
01366  00276F  84 2A                 STY TEXTP       ; SAVE OFFSET
01367  002771  A5 28                 LDA TXTADR      ; GET BASE ADDR
01368  002773  18                    CLC             ;
01369  002774  65 2A                 ADC TEXTP       ; ADD IN THE OFFSET
01370  002776  85 3E                 STA VARBEG      ; SAVE AS START OF VARIABLE LIST
01371  002778  A5 29                 LDA TXTADR+1    ; GET HIGH ORDER
01372  00277A  69 00                 ADC #$00        ; ADD IN THE CARRY
01373  00277C  85 3F                 STA VARBEG+1    ; SAVE IT
01374  00277E  20 0D 28              JSR INSDON      ; FLAG VARIABLE LIST AS EMPTY
01375  002781  4C 11 27              JMP POPTP       ; * PJMP * RESTORE POINTERS TO POINT TO
01376                          ;   WHERE WE WOULD INSERT LINE.
01377                          ;
01378          ; 'INSERT' A LINE IN THE STORED PROGRAM TEXT AREA
01379                          ;
01380  002784  20 0A 27      INSERT  JSR PUSHTP      ; SAVE TEXT POINTERS ACROSS CALL
01381  002787  20 80 26              JSR FINDLN      ; TRY TO LOCATE THE LINE
01382  00278A  90 06                 BCC INSCNT      ; BRANCH IF LINE DOES NOT EXIST
01383  00278C  20 4B 27              JSR DELETE      ; LINE EXISTS, DELETE IT
01384  00278F  20 80 26              JSR FINDLN      ; RE-FIND TO SET UP POINTERS AGAIN
01385  002792  20 11 27      INSCNT  JSR POPTP       ; GET COMBUF POINTERS BACK
01386  002795  C6 2A                 DEC TEXTP       ; POINT TO THE LINE NUMBER DELIMITER
01387  002797  20 0A 27              JSR PUSHTP      ;   BUT KEEP THEM AROUND
01388  00279A  A2 33                 LDX #TXTAD2     ; SAVE POINTER TO PLACE TO INSERT
01389  00279C  A0 04                 LDY #$04        ;   ON STACK
01390  00279E  20 6B 28              JSR PUSHB0      ;
01391  0027A1  A2 02                 LDX #$02        ; SET COUNTER FOR 3 BYTES MINIMUM
01392  0027A3  E8            IFCR    INX             ; COUNT THIS BYTE
01393  0027A4  20 92 29              JSR GETC        ; GET IT FROM COMMAND BUFFER
01394  0027A7  C9 0D                 CMP #$0D        ; 'CR' ?
01395  0027A9  D0 F8                 BNE IFCR        ; NO, KEEP COUNTING
01396  0027AB  86 5F                 STX TEMP1       ; SAVE COUNTER TEMPORARILY
01397  0027AD  A0 00                 LDY #$00        ; OFFSET TO ZERO
01398  0027AF  B1 33                 LDA (TXTAD2),Y  ; GET THE LAST CHAR TO SLIDE DOWN
01399  0027B1  48                    PHA             ; SAVE FOR LATER
01400  0027B2  A9 FD                 LDA #UMARK      ; FLAG THE LOC WITH ALL ONES
01401  0027B4  91 33                 STA (TXTAD2),Y  ;
01402  0027B6  A5 3E                 LDA VARBEG      ; GET ADDR OF START OF VARIABLE LIST
01403  0027B8  85 28                 STA TXTADR      ; SAVE FOR LATER
01404  0027BA  18                    CLC             ;
01405  0027BB  65 5F                 ADC TEMP1       ; ADD IN AMOUNT TO MOVE DOWNWARD
01406  0027BD  85 33                 STA TXTAD2      ; SAVE FOR LATER
01407  0027BF  85 3E                 STA VARBEG      ; SAVE AS NEW START OF VARIABLE LIST
01408  0027C1  A5 3F                 LDA VARBEG+1    ; NOW HIGH ORDER
01409  0027C3  85 29                 STA TXTADR+1    ;
01410  0027C5  69 00                 ADC #$00        ;
01411  0027C7  85 34                 STA TXTAD2+1    ;
01412  0027C9  85 3F                 STA VARBEG+1    ; AND FALL INTO MOVE LOOP
01413  0027CB  B1 28         IMVLOP  LDA (TXTADR),Y  ; PICK UP A BYTE
01414  0027CD  C9 FD                 CMP #UMARK      ; END OF MOVE?
01415  0027CF  F0 0D                 BEQ IMVDON      ; BRANCH IF YES
01416  0027D1  91 33                 STA (TXTAD2),Y  ; NO, THEN SLIDE IT DOWN
01417  0027D3  88                    DEY             ; DECREMENT OFFSET?
01418  0027D4  C0 FF                 CPY #$FF        ; OVERFLOW?
01419  0027D6  D0 F3                 BNE IMVLOP      ; BRANCH IF NOT
01420  0027D8  C6 29                 DEC TXTADR+1    ; OVERFLOW, BUMP HIGH ORDER
01421  0027DA  C6 34                 DEC TXTAD2+1    ;   ADDRESSES
01422  0027DC  D0 ED                 BNE IMVLOP      ; UNCONDITIONALLY LOOP FOR MORE
01423  0027DE  68            IMVDON  PLA             ; GET THE LAST BYTE BACK AGAIN
01424  0027DF  91 33                 STA (TXTAD2),Y  ; STORE IT AWAY
01425  0027E1  20 11 27              JSR POPTP       ; RESTORE POINTERS TO PLACE TO INSERT
01426  0027E4  A2 36                 LDX #TXTAD2+3   ; RESTORE POINTERS TO COMBUF
01427  0027E6  A0 04                 LDY #$04        ;
01428  0027E8  20 5B 28              JSR POPB0       ;
01429  0027EB  A4 2A                 LDY TEXTP       ; GET OFFSET
01430  0027ED  A5 2C                 LDA GRPNO       ; GET THE GROUP NUMBER
01431  0027EF  91 28                 STA (TXTADR),Y  ; STRORE IT IN PROGRAM AREA
01432  0027F1  C8                    INY             ;
01433  0027F2  A5 2D                 LDA LINENO      ; GET THE STEP NUMBER
01434  0027F4  91 28                 STA (TXTADR),Y  ; STRORE IT IN PROGRAM AREA
01435  0027F6  C8                    INY             ; POINT TO WHERE FIRST CHARACTER GOES
01436  0027F7  84 2A                 STY TEXTP       ; SAVE IT FOR LATER
01437  0027F9  A4 35         INSLOP  LDY TEXTP2      ; GET POINTER TO CHAR
01438  0027FB  B1 33                 LDA (TXTAD2),Y  ; PICK IT UP
01439  0027FD  C8                    INY             ; BUMP IT
01440  0027FE  84 35                 STY TEXTP2      ; STORE IT BACK
01441  002800  A4 2A                 LDY TEXTP       ; POINT TO WHERE IT GOES
01442  002802  91 28                 STA (TXTADR),Y  ; PUT IT THERE
01443  002804  C9 0D                 CMP #$0D        ; CARRIAGE RETURN YET?
01444  002806  F0 05                 BEQ INSDON      ; BRANCH IF YES
01445  002808  C8                    INY             ; NO, POINT TO NEXT
01446  002809  84 2A                 STY TEXTP       ; SAVE POINTER
01447  00280B  D0 EC                 BNE INSLOP      ; UNCONDITIONALLY LOOP FOR MORE
01448  00280D  A0 00         INSDON  LDY #$00        ; OFFSET TO ZERO
01449  00280F  A9 FF                 LDA #EOV        ; FLAG VARIABLE LIST AS EMPTY
01450  002811  91 3E                 STA (VARBEG),Y  ;
01451  002813  A5 3E                 LDA VARBEG      ; AND UPDATE 'VAREND'
01452  002815  85 42                 STA VAREND      ;
01453  002817  A5 3F                 LDA VARBEG+1    ;
01454  002819  85 43                 STA VAREND+1    ;
01455  00281B  60                    RTS             ; AND RETURN
01456                          ;
01457  
01458  ; *** BEGIN AZIN67 SECTION (COMPLETED BY DAVE. H)
01459  
01460  ; 
01461  ; 
01462  ;           'SOFTWARE STACK MANIPULATION ROUTINES'
01463  ; 
01464  ; "PUSHJ" - PUSH-JUMP TO A ROUTINE
01465  ; 
01466  ; CALLING SEQUENCE IS:
01467  ; 
01468  ; JSR  PUSHJ	; CALL THIS SUBROUTINE
01469  ; .WORD ROUTINE	; TWO BYTE ADDR OF ROUTINE TO GO TO
01470  ;               ; *** NOTE! THIS WORD CANNOT OVERLAP
01471  ;               ; *** A PAGE BOUNDARY.
01472  ;        <----- ; RETURN IS HERE VIA "POPJ" ROUTINE
01473  ; 
01474  ; *** this routine has self-modifying code at $282F.
01475  ;     (I'm unsure how to write this in 'modern' assembly) --dhh
01476  ; 
01477  00281C  68            PUSHJ     PLA		; GET LOW ORDER RETURN ADDR FROM STACK
01478  00281D  A8                      TAY		; PLACE IN Y REGISTER
01479  00281E  C8                      INY		; INCREMENT TO GET LOW ORDER TO JUMP INDIR
01480  00281F  8C 2F 28                STY PJADR1	; STORE IN JUMP INDIRECT INSTRUCTION
01481  002822  C8                      INY		; BUMP FOR THE RTS IN "POPJ"
01482  002823  98                      TYA		; PLACE IN ACCUMULATOR
01483  002824  20 31 28                JSR PUSHA	; SAVE ON STACK FOR LATER
01484  002827  68                      PLA		; GET HIGH ORDER RETURN ADDR
01485  002828  8D 30 28                STA PJADR1+1	; STORE IN JUMP INDIRECT INSTRUCTION
01486  00282B  20 31 28                JSR PUSHA	; SAVE FOR LATER RETURN VIA "POPJ"
01487    282F              PJADR1 = * + 1
01488  00282E  6C 00 00                JMP ($0000)	; ADDR IS OVERWRITTEN FROM ABOVE CODE
01489              		; THIS JUMP WILL GO TO "ROUTINE".
01490  ; 
01491  ; "PUSHA" - PUSH THE ACCUMULATOR ON THE SOFTWARE STACK
01492  ; 
01493  ; CALLING SEQUENCE IS:
01494  ; JSR  PUSHA
01495  ; 
01496  002831  A4 4E         PUSHA     LDY PDP	; GET THE SOFTWARE STACK POINTER
01497  002833  91 4C                   STA (PDPADR),Y	; STORE THE ACC VIA POINTER
01498  002835  88                      DEY		; DECREMENT THE SOFT STACK POINTER
01499  002836  C0 FF                   CPY #$FF	; IS NEW VALUE $FF ?
01500  002838  D0 02                   BNE PUSHRT	; NO, THEN BASE ADDR IS OK
01501  00283A  C6 4D                   DEC PDPADR+1	; YES, DEC BASE ADDR BY ONE
01502  00283C  84 4E         PUSHRT    STY PDP	; STORE UPDATED POINTER
01503  00283E  60                      RTS		; AND RETURN
01504  ; 
01505  ; "POPA" - POP ITEM OFF SOFTWARE STACK INTO THE ACCUMULATOR
01506  ; 
01507  ; CALLING SEQUENCE IS:
01508  ; JSR  POPA
01509  ; 
01510  00283F  A4 4E         POPA      LDY PDP	; load software stack pointer
01511  002841  C8                      INY		; increment so it points to new item
01512  002842  D0 02                   BNE PHOK	; branch if high-order base addr is OK
01513  002844  E6 4D                   INC PDPADR+1	; if not OK, increment by one page
01514  002846  B1 4C         PHOK      LDA (PDPADR),Y	; get item from soft stack
01515  002848  84 4E                   STY PDP	; store updated pointer
01516  00284A  60                      RTS		; and return
01517  ; 
01518  ; "POPJ" - RETURN TO ADDRESS SAVED BY A CALL TO "PUSHJ"
01519  ; 
01520  ; CALLING SEQUENCE IS:
01521  ; JSR  POPJ
01522  ; 
01523  00284B  BA            POPJ      TSX		; load X w/ hw stack pointer
01524  00284C  20 3F 28                JSR POPA	; get hi order addr to ret to
01525  00284F  9D 02 01                STA STACK+2,X	; overwrite return addr
01526  002852  20 3F 28                JSR POPA	; get lo order byte to ret to
01527  002855  9D 01 01                STA STACK+1,X	; overwrite return addr
01528  002858  60                      RTS		; return to proper place, past
01529                          ;   JSR PUSHJ and .WORD routine
01530                          ; SEQUENCE --->
01531  ; 
01532  ; "POPB0"  pop bytes off of stack into zero page
01533  ; 
01534  002859  A0 02         POPB2     LDY #$02	; entry point when we need 2 bytes only
01535  00285B  84 5F         POPB0     STY TEMP1	; save Y register
01536  00285D  20 3F 28                JSR POPA	; get a byte from stack
01537  002860  95 00                   STA $00,X	; store it in zero page
01538  002862  A4 5F                   LDY TEMP1	; get Y register back
01539  002864  CA                      DEX		; count X down
01540  002865  88                      DEY		; done yet?
01541  002866  D0 F3                   BNE POPB0	; loop for more
01542  002868  60                      RTS		; yes, return
01543  ; 
01544  ; "PUSHB0"  push bytes from page zero onto stack   
01545  ; 
01546  002869  A0 02         PUSHB2    LDY #$02	; entry point, 2 bytes only
01547  00286B  84 5F         PUSHB0    STY TEMP1	; save Y
01548  00286D  B5 00                   LDA $00,X	; get value from Z Pg
01549  00286F  20 31 28                JSR PUSHA	; save on stack
01550  002872  A4 5F                   LDY TEMP1	; get Y back
01551  002874  E8                      INX		; next byte
01552  002875  88                      DEY		; done yet?
01553  002876  D0 F3                   BNE PUSHB0	; loop if >0
01554  002878  60                      RTS		; return
01555  ; 
01556  ; PUSH AND POP F.P. NUMBERS
01557  ; 
01558  ; PUSH FAC1 ONTO STACK
01559  ; 
01560  002879  A2 FB         PHFAC1    LDX #$FB	; get neg of num of bytes to push
01561  00287B  B5 85         PHF1B     LDA $85,X	; get a byte of number
01562  00287D  20 31 28                JSR PUSHA	; push onto software stack
01563  002880  E8                      INX		; point to next one
01564  002881  30 F8                   BMI PHF1B	; loop til all pushed
01565  002883  60                      RTS               
01566  ; 
01567  ; PUSH FAC2 ONTO STACK
01568  ; 
01569  002884  A2 FB         PHFAC2    LDX #$FB	; get neg of num of bytes to push
01570  002886  B5 80         PHF2B     LDA $80,X	; get a byte of number
01571  002888  20 31 28                JSR PUSHA	; etc
01572  00288B  E8                      INX
01573  00288C  30 F8                   BMI PHF2B
01574  00288E  60                      RTS
01575  ; 
01576  ; PUSH F.P. TEMP ONTO STACK
01577  ; 
01578  00288F  A2 FB         PHTMP     LDX #$FB	; get neg of num of bytes to push
01579  002891  B5 A5         PHTB      LDA $A5,X	; get a byte of number
01580  002893  20 31 28                JSR PUSHA	; etc
01581  002896  E8                      INX
01582  002897  30 F8                   BMI PHTB
01583  002899  60                      RTS
01584  ; 
01585  ; POP NUMBER ON STACK INTO FAC2
01586  ; 
01587  00289A  A2 04         PLFAC2    LDX #$04	; point to last byte
01588  00289C  20 3F 28      PLF2B     JSR POPA	; pop item from stack into ACC
01589  00289F  95 7B                   STA X2,X	; store into FAC2
01590  0028A1  CA                      DEX		; point to next byte
01591  0028A2  10 F8                   BPL PLF2B	; loop until all popped 
01592  0028A4  60                      RTS
01593  ; 
01594  ; POP NUMBER ON STACK INTO F.P. TEMP
01595  ; 
01596  0028A5  A2 04         PLTMP     LDX #$04	; point to last byte
01597  0028A7  20 3F 28      PLTB      JSR POPA	; get item from stack into ACC
01598  0028AA  95 A0                   STA $A0,X	; store in temp area
01599  0028AC  CA                      DEX		; point to next byte
01600  0028AD  10 F8                   BPL PLTB	; loop til done
01601  0028AF  60                      RTS
01602  ; 
01603  ;           'CHARACTER MANIPULATING ROUTINES'
01604  ; 
01605  ; READ ONE CHARACTER WITH NO ECHO
01606  ; 
01607  0028B0  A5 6B         RNOECH    LDA ECHFLG	; get echo ctrl flag
01608  0028B2  48                      PHA		; save on stack
01609  0028B3  A9 01                   LDA #$01	; no disable echo
01610  0028B5  85 6B                   STA ECHFLG
01611  0028B7  20 C0 28                JSR READC	; get a char from input device
01612  0028BA  AA                      TAX		; save char into X
01613  0028BB  68                      PLA		; get old echo flag value back
01614  0028BC  85 6B                   STA ECHFLG
01615  0028BE  8A                      TXA		; get the char input
01616  0028BF  60                      RTS
01617  ; 
01618  ; "READC" - READ ONE CHARACTER FROM INPUT DEVICE
01619  ; 
01620  0028C0  A6 66         READC     LDX IDEV	; GET CURRENT INPUT DEVICE NUMBER
01621  0028C2  10 03                   BPL READC1	; BRANCH IF DEVICE NUMBER IS POSITIVE
01622  0028C4  4C CB 30                JMP RSTRNG	; * PJMP * NEG, READ FROM STRING AND RET
01623  0028C7  BD AF 35      READC1    LDA IDSPH,X	; GET HIGH ORDER DISPATCH ADDRESS
01624  0028CA  85 60                   STA TEMP1+1	; STORE IT AWAY
01625  0028CC  BD B4 35                LDA IDSPL,X	; GET LOW ORDER
01626  0028CF  85 5F                   STA TEMP1	; STORE IT AWAY
01627  0028D1  20 5E 00                JSR JSRIND	;   AND CALL THE INPUT ROUTINE
01628  0028D4  90 05                   BCC READCC	; BRANCH IF NO ERRORS
01629  0028D6  20 15 20      IERRI     JSR CLRDEV	; RESET DEVICES ON AN I-O ERROR
01630  0028D9  00                      BRK		; TRAP
01631            .BYTE ERRI	; ?I-O ERROR ON INPUT DEVICE (#$E9)
01632  0028DB  85 2B         READCC    STA CHAR	; SAVE CHAR
01633  0028DD  C9 7F                   CMP #$7F	; here the Aresco code differs from the
01634  0028DF  F0 5F                   BEQ RTS1	; ProgExch/6502Grp original. Was only a
01635  0028E1  C9 5F                   CMP #$5F	; test for CR, but now testing for RUBOUT,
01636  0028E3  F0 5B                   BEQ RTS1	; LF and CXL LINE.
01637  0028E5  C9 0A                   CMP #$0A	;   --dhh
01638  0028E7  F0 57                   BEQ RTS1
01639  0028E9  A5 6B                   LDA ECHFLG	; ECHO FLAG
01640  0028EB  F0 03                   BEQ READCE
01641  0028ED  A5 2B         READCR    LDA CHAR	; GET CHAR BACK
01642  0028EF  60                      RTS
01643  
01644  0028F0  A5 2B         READCE    LDA CHAR	; this is also not in original ProgExch code...
01645            ; JSR PRINTC   ; Changed to no-ops ($EA) for I/O patch
01646            .BYTE $EA, $EA, $EA
01647  0028F5  C9 0D                   CMP #$0D
01648  0028F7  D0 47                   BNE RTS1	; ... to here. Next line was label READCE
01649  0028F9  A9 0A                   LDA #$0A	; FOLLOW CARRIAGE RETS WITH A LINE FEED
01650  0028FB  20 02 29                JSR PRINTC	; PRINT IT
01651  0028FE  10 ED                   BPL READCR	; UNCONDITIONAL BRANCH
01652  ; 
01653  ; PRINTC - PRINT THE CHAR IN ACCUMULATOR OR 'CHAR'
01654  ; 
01655  002900  A9 20         PSPACE    LDA #$20	; OUTPUT A SPACE
01656  002902  29 FF         PRINTC    AND #$FF	; here we're testing for a null ($00),
01657  002904  D0 02                   BNE PRNTC	; otherwise, routine branches to the
01658  002906  A5 2B                   LDA CHAR	; original ProgExch 'PRINTC'
01659  002908  48            PRNTC     PHA		; SAVE THE CHAR IN THE AC
01660  002909  A6 67                   LDX ODEV	; GET CURRENT OUTPUT DEVICE NUMBER
01661  00290B  10 06                   BPL PUSEA1	; BRANCH IF DEVICE NUMBER IS POSITIVE
01662        
01663         ; ProgExch source has a 'patch' here (literally pasted on!)
01664         ; covering the next six bytes:
01665         ; LDY STOPNT   ; get pntr to next char
01666         ; JMP WSTRNG   ; *PJMP* write to string
01667         ; NOP            ; patch fill
01668  
01669  00290D  20 BE 30                JSR WSTRNG     
01670  002910  4C 29 29                JMP PRRET
01671  002913  BD B9 35      PUSEA1    LDA ODSPH,X	; GET HIGH ORDER ADDR OF OUTPUT ROUTINE
01672  002916  85 60                   STA TEMP1+1	; SAVE IT
01673  002918  BD BE 35                LDA ODSPL,X	; GET LOW ORDER ADDR OF OUTPUT ROUTINE
01674  00291B  85 5F                   STA TEMP1	; SAVE IT
01675  00291D  68                      PLA		; GET CHAR BACK
01676  00291E  48                      PHA		; BUT SAVE ACROSS CALL
01677  00291F  20 5E 00                JSR JSRIND	; CALL THE ROUTINE TO DO THE OUTPUT
01678  002922  90 05                   BCC PRRET	; BRANCH IF NO ERRORS
01679  002924  20 15 20      OERRO     JSR CLRDEV	; RESET I-O DEVICES IF ERROR
01680  002927  00                      BRK		; TRAP
01681            .BYTE ERRO	; ?I-O ERROR ON OUTPUT DEVICE (#$DE)
01682  002929  68            PRRET     PLA		; RESTORE THE CHARACTER
01683  00292A  60                      RTS		; AND RETURN
01684  ; 
01685  ; PACKC - PACK A CHAR INTO MEMORY
01686  ; 
01687  00292B  A5 2B         PACKC     LDA CHAR	; get character
01688  00292D  A4 2A         PACKC1    LDY TEXTP	; get text pointer
01689  00292F  C9 7F                   CMP #$7F	; rubout?
01690  002931  F0 10                   BEQ RUB1	; yes, branch
01691  002933  C9 5F                   CMP #LINCHR	; 'line delete' char?
01692  002935  F0 29                   BEQ RUBLIN	; yes, branch
01693  002937  91 28                   STA (TXTADR),Y     ; store char to memory
01694  002939  C8            PCKRUB    INY		; +1 text pointer
01695  00293A  C0 7F                   CPY #$7F	; over max line length?
01696  00293C  10 03                   BPL PBIG	; yes, branch
01697  00293E  84 2A         PCKRET    STY TEXTP	; save text pointer
01698  002940  60            RTS1      RTS		; and return
01699  002941  00            PBIG      BRK		; trap
01700            .BYTE LTL	; ?line too long
01701  ; 
01702  ; ROUTINE TO RUB OUT ONE CHARACTER
01703  ; 
01704  002943  C0 00         RUB1      CPY #$00	; anything to rubout?
01705  002945  F0 F7                   BEQ PCKRET	; nope, branch
01706  002947  A4 6B                   LDY ECHFLG	; has user enabled character echo?
01707  002949  D0 0E                   BNE RUB1CC	; branch if disabled
01708  00294B  A4 6C                   LDY DELSPL	; need special CRT rubout?          
01709  00294D  F0 05                   BEQ RUB1C	; branch if not
01710  00294F  20 7D 29                JSR EATTVC	; yes, eat the char          
01711  002952  10 05                   BPL RUB1CC	; uncond. branch
01712  002954  A9 5C         RUB1C     LDA #$5C	; echo sp char '\' for rubout
01713  002956  20 08 29                JSR PRNTC
01714  002959  A4 2A         RUB1CC    LDY TEXTP	; load Y with text pointer
01715  00295B  88                      DEY		; -1
01716  00295C  10 E0                   BPL PCKRET	; RET if positive
01717  00295E  30 D9                   BMI PCKRUB	; if past beginning, set to 0
01718  ; 
01719  ; ROUTINE TO RUB OUT THE ENTIRE LINE
01720  ; 
01721  ;	*** this routine is visibly patched in the ProgExch code; Aresco code
01722  ;	    below is different.  -dhh
01723  ;
01724  002960  C0 00         RUBLIN    CPY #$00	; anything to rubout?
01725  002962  F0 DA                   BEQ PCKRET	; branch if not
01726  002964  A4 6B                   LDY ECHFLG	; has user enabled char echo?
01727  002966  D0 11                   BNE RUBLR	; branch if disabled
01728  002968  A4 6C                   LDY DELSPL	; need special CRT rubout proc?
01729  00296A  F0 08                   BEQ RUBLC	; branch if not
01730  00296C  20 7D 29      RUBLCL    JSR EATTVC	; eat a char off CRT screen
01731  00296F  C6 2A                   DEC TEXTP	; zap it from buffer
01732  002971  D0 F9                   BNE RUBLCL	; loop til all zapped
01733  002973  60                      RTS     
01734  002974  A9 5F         RUBLC     LDA #$5F	; echo 'line del' character
01735  002976  20 08 29                JSR PRNTC
01736  002979  A0 00         RUBLR     LDY #$00	; reset text pointer
01737  00297B  F0 C1                   BEQ PCKRET	; and RET
01738  ; 
01739  ; EAT A CRT CHAR WITH BS-SPC-BS SEQUENCE
01740  ; 
01741  00297D  20 83 29      EATTVC    JSR BACKSP	; output a BS
01742  002980  20 00 29                JSR PSPACE	; followed by a space
01743  002983  A9 08         BACKSP    LDA #$08	; get BS char
01744  002985  4C 02 29                JMP PRINTC	; * PJMP * output it and return
01745  ; 
01746  ; 'GETC' GET A CHAR FROM MEMORY, ECHO IF TRACE ON
01747  ; 
01748  002988  A4 20         GETCX     LDY DEBGSW	; is trace disabled?
01749  00298A  D0 17                   BNE GETC1	; yes, don't look at flag
01750  00298C  A5 21                   LDA DMPSW	; flip state of the dump switch
01751  00298E  49 FF                   EOR #$FF
01752  002990  85 21                   STA DMPSW	; and store it back
01753  002992  A5 24         GETC      LDA INSW	; where do we get the char from?
01754  002994  F0 03                   BEQ GETCC	; from memory
01755  002996  4C C0 28                JMP READC	; * PJMP * go get from input dev
01756  002999  A4 2A         GETCC     LDY TEXTP	; get text pointer
01757  00299B  E6 2A                   INC TEXTP	; +1 to next char
01758  00299D  B1 28                   LDA (TXTADR),Y	; get it
01759  00299F  C9 3F                   CMP #$3F	; is it '?'
01760  0029A1  F0 E5                   BEQ GETCX	; yes, go handle
01761  0029A3  85 2B         GETC1     STA CHAR	; store away for others
01762  0029A5  A5 20                   LDA DEBGSW	; check to see if we print it
01763  0029A7  05 21                   ORA DMPSW	; for debugging
01764  0029A9  D0 03                   BNE GETRT1	; no
01765  0029AB  20 F0 28                JSR READCE	; print only if both are 0
01766  0029AE  A5 2B         GETRT1    LDA CHAR	; get char back
01767  0029B0  60                      RTS		; and RET
01768  ;
01769      ; the ProgramExchange/6502Group code has a 'patch'
01770      ; over GETC1:
01771      ; GETC1     STA CHAR     ; STORE IT
01772      ;           PHA          ; SAVE ON STACK
01773      ;           LDA DEBGSW     ; DO WE PRINT IT?
01774      ;           ORA DMPSW     ; FOR DEBUGGING
01775      ;           BNE TESTN+7     ; NO
01776      ;           PLA          ; GET CHAR BACK
01777      ;           JSR TRACBG     ; FIX FOR TRACE BUG
01778      ;           RTS          ; CHAR IS RETURNED
01779  ; 
01780  ; 'SPNOR' ROUTINE TO IGNORE LEADING SPACES
01781  ; 
01782  0029B1  20 92 29      GSPNOR    JSR GETC	; CALL GETC FIRST
01783  0029B4  A5 2B         SPNOR     LDA CHAR	; GET THE CHAR
01784  0029B6  C9 20                   CMP #$20	; IS IT A SPACE?
01785  0029B8  F0 F7                   BEQ GSPNOR	; YES, THEN IGNORE
01786  0029BA  60                      RTS		; NO, RETURN
01787  ; 
01788  ; "TESTN"  TESTS TO SEE IF CHARACTER IS A NUMBER
01789  ; 
01790  0029BB  20 B1 29      TESTNS    JSR GSPNOR	; GET NEXT NON-BLANK
01791  0029BE  A5 2B         TESTN     LDA CHAR	; GET CHAR
01792  0029C0  48            TESTN1    PHA		; SAVE CHAR ON STACK
01793  0029C1  49 30                   EOR #$30	; CONVERT TO BCD (IF A NUMBER)
01794  0029C3  C9 0A                   CMP #$0A	; SET C BIT IF GREATER THAN 9
01795  0029C5  68                      PLA		; RETORE CHARACTER TO ACCUMULATOR
01796  0029C6  60                      RTS		; RETURN (C BIT CLEAR IF NUMBER)
01797  ; 
01798  ;           'EVAL' - EXPRESSION EVALUATOR
01799  ; 
01800  ; 'EVAL' - EVALUATE AN EXPRESSION (RECURSIVE)
01801  ; 
01802  0029C7  A9 00         EFUN      LDA #$00	; GET A ZERO
01803  0029C9  0A            EFUNL     ASL		; ROTATE LEFT TO HASH
01804  0029CA  85 65                   STA ETEMP1	; SAVE IT
01805  0029CC  20 92 29                JSR GETC	; GET NEXT CHARACTER OF FUNCTION NAME
01806  0029CF  20 3E 2B                JSR TTERMS	; TERMINATOR?
01807  0029D2  F0 07                   BEQ EFNAME	; BRANCH IF END OF NAME
01808  0029D4  29 1F                   AND #$1F	; KEEP ONLY 5 BITS
01809  0029D6  18                      CLC
01810  0029D7  65 65                   ADC ETEMP1	; ADD IN THE HASH
01811  0029D9  D0 EE                   BNE EFUNL     ; UNCONDITIONALLY LOOP FOR MORE
01812  0029DB  C9 28         EFNAME    CMP #$28	; '(' LEFT PAREN?
01813  0029DD  F0 02                   BEQ EFUNC     ; BRANCH IF YES
01814  0029DF  00                      BRK		; TRAP
01815            .BYTE PFERR	; ?PARENTHESES ERROR IN FUNCTION
01816  0029E1  A5 65         EFUNC     LDA ETEMP1	; GET THE HASH CODE FOR FUNCTION NAME
01817  0029E3  20 31 28                JSR PUSHA     ; SAVE FOR LATER
01818  0029E6  20 1C 28                JSR PUSHJ     ; MOVE PAST PAREN, EVALUATE 1ST ARGUMENT
01819            .BYTE $3,$2A
01820  0029EB  20 3F 28                JSR POPA	; GET THE NAME BACK AGAIN
01821  0029EE  AA                      TAX		; TRANSFER TO X REGISTER
01822  0029EF  20 1C 28                JSR PUSHJ     ; AND GO DO THE FUNCTION
01823            .WORD	FUNC    ; SamCoVT - scan has EVALM1 but binary version
01824                          ; has FUNC here instead
01825  0029F4  4C CD 2A                JMP ERPAR     ; GO SEE IF TERMINATOR IS A RIGHT PAREN.
01826  ; 
01827  ; HERE FOR A QUOTED CONSTANT
01828  ; 
01829  0029F7  20 92 29      ECHAR     JSR GETC	; GET CHARACTER FOLLOWING QUOTE
01830  0029FA  20 41 32                JSR FLT8	; AND MAKE IT A FLOATING POINT NUMBER
01831  0029FD  20 92 29                JSR GETC	; MOVE PAST CHARACTER
01832  002A00  4C 83 2A                JMP OPNEXT	; AND CHECK FOR OPERATOR
01833  ; 
01834  ; *** MAIN ENTRY POINT(S) TO 'EVAL' ***
01835  ; 
01836  002A03  20 92 29      EVALM1    JSR GETC	; ENTER HERE TO GET PAST CURRENT CHARACTER
01837  002A06  A9 00         EVAL      LDA #$00	; ASSUME LOWEST LEVEL ARITHMETIC OPERATION
01838  002A08  85 75                   STA LASTOP
01839  002A0A  85 3B                   STA STRSWT	; MAKE SURE STRING VAR SWITCH IS OFF
01840  002A0C  20 CB 2C                JSR ZRFAC1	; ASSUME VALUE OF EXPRESSION IS ZERO
01841  002A0F  A5 75         ARGNXT    LDA LASTOP	; SAVE LAST OPERATION ON STACK
01842  002A11  20 31 28                JSR PUSHA
01843  002A14  20 3E 2B                JSR TTERMS	; GO SEE IF THIS CHARACTER IS A TERMINATOR
01844  002A17  D0 03                   BNE ECHKC	; BRANCH IF NOT
01845  002A19  4C C4 2A                JMP ETERM1	; YES, THEN HANDLE
01846  002A1C  C9 46         ECHKC     CMP #$46	; 'F' IS IT A FUNCTION?
01847  002A1E  F0 A7                   BEQ EFUN	; BRANCH IF YES
01848  002A20  C9 27                   CMP #$27	; ''' IS IT A CHARACTER CONSTANT?
01849  002A22  F0 D3                   BEQ ECHAR     ; BRANCH IF YES
01850  002A24  C9 2E                   CMP #$2E	; '.' IS IT A FRACTION?
01851  002A26  F0 1C                   BEQ ENUM	; BRANCH IF YES, CALL FLOATING P. ROUTINE
01852  002A28  20 C0 29                JSR TESTN1	; NO, BUT IS IT A NUMBER?
01853  002A2B  B0 28                   BCS EGTVAR	; BRANCH IF NOT A NUMBER
01854                ; *** START OF KLUDGE HACK
01855                ;     TO SPEED THINGS UP ***
01856  002A2D  A5 24                   LDA INSW	; ARE WE INPUTTING FROM INPUT DEVICE?
01857  002A2F  D0 13                   BNE ENUM	; BRANCH IF YES, CALL FLOAT PT ROUTINE
01858  002A31  A2 02                   LDX #$02	; NO, THEN WE CAN LOOK AHEAD TO SEE IF
01859  002A33  A4 2A                   LDY TEXTP     ;   CONSTANT IS IN RANGE 0-99
01860  002A35  B1 28         KLOOP     LDA (TXTADR),Y	; GET NEXT CHAR
01861  002A37  C8                      INY		; BUMP POINTER
01862  002A38  C9 2E                   CMP #$2E	; '.' DOES NUMBER HAVE A FRACTIONAL PART
01863  002A3A  F0 08                   BEQ ENUM	; BRANCH IF IT DOES, CALL F.P. ROUTINE
01864  002A3C  20 C0 29                JSR TESTN1	; IS THIS CHAR A DIGIT 0-9 ALSO?
01865  002A3F  B0 09                   BCS FSTNUM	; BRANCH IF NOT, THEN CALL FAST INPUT
01866  002A41  CA                      DEX		; CAN ONLY HAVE UP TO TWO DIGITS
01867  002A42  D0 F1                   BNE KLOOP     ; LOOK AT NEXT ONE
01868                          ; IF WE FALL OUT OF THE LOOP, WE HAVE TO
01869  002A44  20 27 34      ENUM      JSR FINP	;   CALL FLOAT PT. INPUT ROUTINE (SLOW!)
01870  002A47  4C 83 2A                JMP OPNEXT	; AND LOOP FOR OPERATOR
01871  002A4A  A5 2B         FSTNUM    LDA CHAR	; GET FIRST DIGIT OF NUMBER
01872  002A4C  20 C2 2D                JSR GETIN     ; CALL FAST INPUT ROUTINE FOR #S 0-99
01873  002A4F  20 41 32                JSR FLT8	; CALL FAST ONE-BYTE FLOAT ROUTINE
01874  002A52  4C 83 2A                JMP OPNEXT	;    AND LOOK FOR OPERATOR
01875  		; *** END OF KLUDGE HACK ***
01876  002A55  20 1C 28      EGTVAR    JSR PUSHJ     ; IT MUST BE A VARIABLE, GET VALUE
01877            .WORD GETVAR	; or .WORD GETVAR
01878  002A5A  A5 2B                   LDA CHAR	; GET CHARACTER THAT TERMINATED THE VARIB
01879  002A5C  C9 3D                   CMP #$3D	; '=' DOES HE WANT SUBSTITUTION?
01880  002A5E  D0 23                   BNE OPNEXT	; BRANCH IF NOT, JUST A TERM
01881  002A60  A2 37                   LDX #VARADR	; YES, THEN SAVE THE INFO ABOUT THIS VARIB
01882  002A62  A0 05                   LDY #$05
01883  002A64  20 6B 28                JSR PUSHB0	;   ONTO THE STACK
01884  002A67  20 1C 28                JSR PUSHJ     ; CALL OURSELVES TO EVAL THE EXPRESSION
01885            .WORD EVALM1	; or .WORD EVALM1
01886  002A6C  A2 3B                   LDX #VARADR+4	; RESTORE POINTERS TO VARIABLE
01887  002A6E  A0 05                   LDY #$05
01888  002A70  20 5B 28                JSR POPB0
01889  002A73  A5 3B                   LDA STRSWT	; WAS THE VARIABLE A STRING VARIABLE?
01890  002A75  D0 05                   BNE SETSTR	; BRANCH IF IT WAS
01891  002A77  20 A1 2C                JSR PUTVAR	; NO, THEN STORE EXPRESS VALUE AS VARIB'S
01892  002A7A  F0 07                   BEQ OPNEXT	;   VALUE - IS ALSO VALUE OF THIS TERM
01893  002A7C  20 93 2F      SETSTR    JSR INTGER	; KEEP ONLY 8 BITS FOR VALUE
01894  002A7F  A4 3A                   LDY VSUB+1	; POINT TO POSITION IN STRING
01895  002A81  91 37                   STA (VARADR),Y	; STORE IT INTO $, FALL INTO...
01896  002A83  20 3E 2B      OPNEXT    JSR TTERMS	; GO SEE IF NEXT NON-SPACE IS SPECIAL
01897  002A86  D0 04                   BNE MISOPR	; BRANCH IF NOT
01898  002A88  E0 06                   CPX #$06	; LEFT PAREN?
01899  002A8A  D0 08                   BNE OPNXT1	; NO, THAT'S GOOD AS WE CAN'T HAVE 1 HERE
01900  002A8C  00            MISOPR    BRK		; TRAP TO ERROR HANDLER
01901            .BYTE OPRMIS	; ?OPERATOR MISSING - EVAL
01902  002A8E  4C 0F 2A      JARGN     JMP ARGNXT	; BRANCH AID
01903  002A91  20 4B 28      EVALRT    JSR POPJ	; RETURN FROM CALL TO "EVAL"
01904  
01905  002A94  E0 07         OPNXT1    CPX #$07	; IS THIS A DELIMITER?
01906  002A96  30 02                   BMI OPNXT2	; BRANCH IF NOT
01907  002A98  A2 00                   LDX #$00	; YES, THEN THE OPERATION LEVEL IS LOWEST
01908  002A9A  20 3F 28      OPNXT2    JSR POPA	; GET LAST OPERATION LEVEL
01909  002A9D  85 5F                   STA TEMP1     ; SAVE IT FOR COMPARE
01910  002A9F  E4 5F                   CPX TEMP1     ; IS THIS OPER LVL < OR = TO LAST ONE?
01911  002AA1  30 02                   BMI DOBOP     ; BRANCH IF YES
01912  002AA3  D0 12                   BNE ESTACK	; BRANCH IF NO
01913  002AA5  09 00         DOBOP     ORA #$00	; TO RESET FLAGS AFTER CPX
01914  002AA7  85 75                   STA LASTOP	; YES, THEN GET THE LAST OPERATOR
01915  002AA9  F0 E6                   BEQ EVALRT	; IF LOWEST LEVEL, THEN WE ARE ALL DONE
01916  002AAB  8A                      TXA		; SAVE 'THISOP'
01917  002AAC  48                      PHA		; ON HARDWARE STACK
01918  002AAD  20 9A 28                JSR PLFAC2	; POP PARTIAL RESULT BACK INTO FAC2
01919  002AB0  20 E8 2A                JSR EVBOP     ; AND GO DO THE OPERATION LEAVING THE
01920  			;   RESULT IN FLAC
01921  002AB3  68                      PLA		; GET 'THISOP' BACK
01922  002AB4  AA                      TAX
01923  002AB5  10 E3                   BPL OPNXT2	; UNCOND. BRANCH WITH NEW PARTIAL RESULT.
01924  
01925  002AB7  20 31 28      ESTACK    JSR PUSHA	; SAVE BACK ON STACK FOR LATER COMPUTATION
01926  002ABA  86 75                   STX LASTOP	; NOW UPDATE 'LASTOP' TO 'THISOP'
01927  002ABC  20 79 28                JSR PHFAC1	; SAVE PARTIAL RESULT ON STACK
01928  002ABF  20 92 29                JSR GETC	; SKIP OVER THE OPERATOR
01929  002AC2  10 CA                   BPL JARGN	; UNCOND. BRANCH TO PICK UP NEXT ARGUMENT
01930  002AC4  E0 06         ETERM1    CPX #$06	; LEFT PAREN?
01931  002AC6  D0 12                   BNE ETERM2	; BRANCH IF NOT
01932  002AC8  20 1C 28                JSR PUSHJ	; ENTERING NEW LEVEL OF NESTING, SO CALL
01933            .WORD EVALM1	; OURSELVES TO EVALUATE IT!
01934  002ACD  A5 2B         ERPAR     LDA CHAR	; GET THE DELIMITER THAT ENDED THIS LEVEL
01935  002ACF  48                      PHA		; SAVE IT MOMENTARILY
01936  002AD0  20 92 29                JSR GETC	; MOVE PAST IT
01937  002AD3  68                      PLA		; GET DELIMITER BACK
01938  002AD4  C9 29                   CMP #$29	; ')' RIGHT PAREN?
01939  002AD6  F0 AB                   BEQ OPNEXT	; YES. GO PICK UP NEXT OPERATOR
01940  002AD8  00            EPMISS    BRK		; TRAP TO ERROR HANDLER
01941            .BYTE PMATCH	; ?PARENTHESIS MISMATCH - EVAL
01942  002ADA  E0 07         ETERM2    CPX #$07	; DELIMITER ON RIGHT-HAND SIDE?
01943  002ADC  10 04                   BPL ETERM3	; BRANCH IF YES
01944  002ADE  E0 03                   CPX #$03	; OR UNARY OPERATOR
01945  002AE0  10 04                   BPL MISOPN	; NO, THEN IT CAN'T BE HERE
01946  002AE2  A5 75         ETERM3    LDA LASTOP	; PICK UP OPERATION LEVEL
01947  002AE4  F0 AE                   BEQ OPNXT1	; ONLY ALLOW IF AT LOWEST LEVEL
01948  002AE6  00            MISOPN    BRK		; TRAP TO ERROR HANDLER
01949            .BYTE OPNMIS	; ?OPERAND MISSING - EVAL
01950  
01951  002AE8  A6 75         EVBOP     LDX LASTOP	; GET THE ARITHMETIC OPERATION TO PERFORM
01952  002AEA  BD 80 35                LDA EVDSPH,X	; GET THE HIGH-ORDER ADDR OF ROUTINE
01953  002AED  85 60                   STA TEMP1+1	; STORE IT
01954  002AEF  BD 85 35                LDA EVDSPL,X	; GET THE LOW-ORDER ADDR OF ROUTINE
01955  002AF2  85 5F                   STA TEMP1	; STORE IT
01956  002AF4  6C 5F 00                JMP ($005F)	; * PJMP * TO ROUTINE TO DO THE OPERATION
01957  ; 
01958  ; 
01959  ;           EVALUATE A POWER
01960  ; 
01961  ; *** NOTE: THIS ROUTINE IS CURRENTLY RESTRICTED TO RAISING
01962  ;           THE NUMBER TO AN INTEGER POWER WITHIN THE RANGE
01963  ;           OF + OR - 32,767          (label: EVPOWR)
01964  ; 
01965  002AF7  20 A7 2F      EVPOWR    JSR INTFIX	; GET EXPONENT
01966  002AFA  85 55                   STA ITMP1L	; STORE IT AWAY
01967  002AFC  A5 82                   LDA M1+1	; AS NUMBER OF TIMES TO DO OPERATION
01968  002AFE  85 56                   STA ITMP1H
01969  002B00  A2 9B                   LDX #FONE	; GET THE CONSTANT 1.0 INTO FAC1
01970  002B02  A0 80                   LDY #FAC1
01971  002B04  20 FF 33                JSR MOVXY
01972  002B07  A5 56                   LDA ITMP1H	; RAISING TO A NEGATIVE POWER?
01973  002B09  30 1A                   BMI NPOWR	; BRANCH IF WE ARE
01974  002B0B  A9 FF         POWRLP    LDA #$FF	; POSITIVE POWER, ARE WE DONE YET?
01975  002B0D  C6 55                   DEC ITMP1L
01976  002B0F  C5 55                   CMP ITMP1L
01977  002B11  D0 02                   BNE POWR1	; BRANCH IF HIGH ORDER OK
01978  002B13  C6 56                   DEC ITMP1H	; DECREMENT HIGH ORDER
01979  002B15  C5 56         POWR1     CMP ITMP1H	; DONE YET?
01980  002B17  F0 32                   BEQ TTRET	; YES, THEN RETURN
01981  002B19  20 84 28                JSR PHFAC2	; NO, SAVE FAC2
01982  002B1C  20 A0 32                JSR FMUL	; NUMBER TIMES ITSELF (EXCEPT FIRST TIME)
01983  002B1F  20 9A 28                JSR PLFAC2	; RESTORE NUMBER TO FAC2
01984  002B22  4C 0B 2B                JMP POWRLP	; AND KEEP MULTIPLYING
01985  ; 
01986  ; HERE IF RAISING TO A NEGATIVE POWER
01987  ; 
01988  002B25  A5 56         NPOWR     LDA ITMP1H	; DONE YET?
01989  002B27  F0 22                   BEQ TTRET     ; BRANCH IF ALL DONE
01990  002B29  E6 55                   INC ITMP1L	; NO, THEN COUNT UP SINCE COUNT IS NEG.
01991  002B2B  D0 02                   BNE NPOWR1
01992  002B2D  E6 56                   INC ITMP1H	; INCREMENT HIGH ORDER ALSO
01993  002B2F  20 29 32      NPOWR1    JSR SWAP	; PUT PARTIAL INTO FAC2, 'X' INTO FAC1
01994  002B32  20 79 28                JSR PHFAC1	; SAVE 'X'
01995  002B35  20 CA 32                JSR FDIV	; 1/(X*X*X*X...)
01996  002B38  20 9A 28                JSR PLFAC2	; RESTORE 'X'
01997  002B3B  4C 25 2B                JMP NPOWR     ; AND LOOP TILL DONE
01998  ; 
01999  ;           'ROUTINES USED BY "EVAL" '
02000  ; 
02001  ; TEST TO SEE IF CHARACTER IS A SPECIAL TERMINATOR
02002  ; 
02003  002B3E  20 B4 29      TTERMS    JSR SPNOR     ; IGNORE SPACES, GET NEXT NON-BLANK CHAR
02004  002B41  A2 0C                   LDX #$0C	; GET MAX TABLE OFFSET; 'trmax in ProgExch code'
02005  002B43  DD E8 34      TRMCHK    CMP TRMTAB,X	; MATCH?
02006  002B46  F0 03                   BEQ TTRET	; YES, RETURN WITH Z=1
02007  002B48  CA                      DEX		; POINT TO NEXT ENTRY
02008  002B49  10 F8                   BPL TRMCHK	; AND CHECK IT
02009  002B4B  60            TTRET     RTS		; RETURN (NOTE: Z=0 IF CANNOT FIND)
02010  ; 
02011  ;           'GETVAR' - GET A VARIABLE FROM VARIABLE LIST
02012  ; 
02013  ; "GETVAR" - GET A VARIABLE FROM THE VARIABLE LIST
02014  ;            OTHERWISE CREATE IT AND ASSIGN IT A VALUE OF ZERO
02015  ; 
02016  002B4C  4C D8 2A      GPMISS    JMP EPMISS	; BRANCH AID
02017  002B4F  00            GTERR3    BRK		; TRAP
02018            .BYTE FUNILL	; ?FUNCTION ILLEGAL HERE
02019  002B51  A9 00         GETVAR    LDA #$00	; ASSUME VARIABLE IS NOT A STRING
02020  002B53  85 3B                   STA STRSWT
02021  002B55  20 B4 29                JSR SPNOR	; (DEFENSIVE!) GET THE CHARACTER
02022  002B58  C9 26                   CMP #$26	; '&' IS IT SPECIAL 'FSBR' SCRATCH VARIB?
02023  002B5A  F0 0A                   BEQ VAROK	; YES, THEN NAME IS OK
02024  002B5C  C9 41                   CMP #$41	; 'A' IS IT ALPHABETIC?
02025  002B5E  30 04                   BMI VARBAD	; BRANCH IF NOT
02026  002B60  C9 5B                   CMP #$5B	; '[' Z+1
02027  002B62  30 02                   BMI VAROK     ; BRANCH IF ALPHABETIC
02028  002B64  00            VARBAD    BRK		; NOT ALPHABETIC
02029            .BYTE BADVAR	; ?BAD VARIABLE NAME
02030  002B66  C9 46         VAROK     CMP #$46	; 'F' FUNCTION?
02031  002B68  F0 E5                   BEQ GTERR3	; BRANCH IF YES
02032  002B6A  0A                      ASL 
02033  002B6B  0A                      ASL 
02034  002B6C  0A                      ASL 		; SHIFT ALPHA LEFT 3
02035  002B6D  48                      PHA		; SAVE IT
02036  002B6E  20 92 29                JSR GETC	; GET NEXT CHARACTER
02037  002B71  49 30                   EOR #$30	; CONVERT TO BCD IF A NUMBER
02038  002B73  C9 08                   CMP #$08	; IS IT 0-7?
02039  002B75  B0 09                   BCS VARDUN	; IF NOT, NAME IS ON STACK
02040  002B77  85 3D                   STA VCHAR	; IF YES, SAVE IT
02041  002B79  68                      PLA		; GET BACK ALPHA PART
02042  002B7A  05 3D                   ORA VCHAR	; PUT THE PARTS TOGETHER
02043  002B7C  48                      PHA		; AND STICK ON STACK
02044  002B7D  20 92 29                JSR GETC	; GET A NEW CHARACTER IN CHAR
02045  ; 
02046  ; 
02047  ; X X X X X X X X X X X X X X X X X X X X X X X X X X X
02048  ;
02049  ; *** here begins transcription work done by Nils Andreas (2023)
02050  ; 
02051  ; 
02052  
02053  
02054  002B80  A5 2B         VARDUN    LDA CHAR
02055  002B82  C9 24                   CMP #$24	; '$' STRING VARIABLE?
02056  002B84  D0 05                   BNE VARDN1	;BRANCH IF NOT, PRESS ON
02057  002B86  85 3B                   STA STRSWT	;YES, FLAG THE FACT
02058  002B88  20 92 29                JSR GETC	;AND MOVE TO THE '3'
02059  002B8B  68            VARDN1    PLA		;GET VARIABLE OFF STACK
02060  002B8C  20 31 28                JSR PUSHA	;PUT NAME ON SOFT STACK
02061  002B8F  20 B4 29                JSR SPNOR	;GET NEXT NON-BLANK
02062  002B92  C9 28                   CMP #$28	; '(' LEFT PAREN?
02063  002B94  F0 06                   BEQ VARSUB	;BRANCH IF VARIABLE HAS A SUBSCRIPT
02064  002B96  A9 00                   LDA #$00	;OTHERWISE ASSUME 0
02065  002B98  85 3A                   STA VSUB+1	;ZERO THE SUBSCRIPT
02066  002B9A  F0 21                   BEQ VARSOK	;AND PROCESS IT
02067  002B9C  A5 3B         VARSUB    LDA STRSWT	;SAVE STRING FLAG
02068  002B9E  20 31 28                JSR PUSHA
02069  002BA1  20 1C 28                JSR PUSHJ	;CALL EAVL TO CALCULATE SUBSCRIPT
02070            .WORD EVALM1          
02071  002BA6  20 3F 28                JSR POPA	;RESTORE STRING FLAG
02072  002BA9  85 3B                   STA STRSWT
02073  002BAB  A5 2B                   LDA CHAR	;GET TERMINATOR
02074  002BAD  C9 29                   CMP #$29	; ')' PAREN MATCH?
02075  002BAF  D0 9B                   BNE GPMISS	;BRANCH IF NOT
02076  002BB1  20 92 29                JSR GETC	;MOVE PAST THE RIGHT PAREN (TYPO?)
02077  002BB4  20 18 33                JSR FIX	;MAKE SUBSCRIPT AN INTEGER
02078  002BB7  A5 83                   LDA X1+3	;GET LOW ORDER BYTE
02079  002BB9  85 3A                   STA VSUB+1	;STORE IT
02080  002BBB  A5 82                   LDA X1+2	;GET HIGH ORDER BYYTE (NOTE:16 BIT)
02081  002BBD  85 39         VARSOK    STA VSUB	;SAVE FOR LATER
02082  002BBF  20 3F 28                JSR POPA	;GET THE VARIABLE NAME BACK
02083  002BC2  85 3D                   STA VCHAR	;SAVE IT
02084  002BC4  20 76 2C      FNDVAR    JSR VARINI	;SET ADDR TO START OF VARIABLE LIST
02085  002BC7  A0 00         CHKVAR    LDY #$00	;SET OFFSET TO ZERO
02086  002BC9  B1 37                   LDA(VARADR),Y	;GET THE VARIABLE NAME
02087  002BCB  C9 FF                   CMP #EOV	;IS THIS THE END OF THE VARIABLE LIST?     
02088  002BCD  F0 57                   BEQ NOVAR	;BRANCH IF END OF LIST
02089  002BCF  C9 FC                   CMP #STRMRK	;IS THIS VARIABLE IN THE LIST A STRING VARIABLE?
02090  002BD1  F0 09                   BEQ CHKSTR	;BRANCH IF YES, WE HANDLE DIFFERENTLY
02091  002BD3  C5 3D                   CMP VCHAR	;ARE THE NAMES THE SAME
02092  002BD5  F0 37                   BEQ CHKSUB	;YES, GO SEE IF THE SUBSCRIPTS ARE EQUAL
02093  002BD7  20 7F 2C      NOTVAR    JSR NXTVAR	;POINT TO NEXT VARIABLE IN LIST
02094  002BDA  D0 EB                   BNE CHKVAR	;UNCONDITIONAL BRANCH TO CHECK NEXT VARIABLE
02095  002BDC  A5 3B         CHKSTR    LDA STRSWT	;ARE WE LOOKING FOR A STRING VARIABLE?
02096  002BDE  F0 1E                   BEQ SKPSTR	;BRANCH IF NOT, JUST SKIP OVER THIS STRING VARIB
02097  002BE0  A5 3D                   LDA VCHAR	;YES, THEN GET IT'S NAME
02098  002BE2  C8                      INY		;POINT TO NAME OF STRING VARIABLE IN VAR LIST 
02099  002BE3  D1 37                   CMP(VARADR),Y	;IS THIS THE ONE WE ARE LOOKING FOR?
02100  002BE5  D0 18                   BNE SKPST1	;BRANCH IF NOT, JUST SKIP IT OVER
02101  002BE7  C8                      INY		;YES, THIS IS THE ONE, GET THE SIZE OF THE
02102  002BE8  B1 37                   LDA(VARADR),Y	;STRING
02103  002BEA  85 3C                   STA VSIZE	;STORE FOR THOSE WHO NEED IT
02104  002BEC  C8                      INY		;AND UPDATE
02105  002BED  98                      TYA
02106  002BEE  20 81 2C                JSR UPDVAR	;'VARADR' TO POINT TO BASE ADDR OF STRING
02107  002BF1  A4 3A         GETSTC    LDY VSUB+1	;GET SUBSCRIPT (POSITION) OF BYTE WE WANT
02108  002BF3  B1 37                   LDA(VARADR),Y	;GET THE BYTE WE WANT
02109  002BF5  85 82                   STA M1+1	;STORE AS LOW ORDER 8 BITS
02110  002BF7  A9 00                   LDA #$00
02111  002BF9  85 81                   STA M1	;ZERO HIGH ORDER
02112  002BFB  4C E3 2E                JMP FL16PJ	;*PJMP* FLOAT AND RETURN THE VALUE
02113  002BFE  C8            SKPSTR    INY		;MOVE OVER STRING VARIABLE'S NAME
02114  002BFF  C8            SKPST1    INY		;POINT TO STRING VARIABLE'S LENGTH
02115  002C00  B1 37                   LDA(VARADR),Y	;GET THE STRING LENGTH
02116  002C02  48                      PHA		;SAVE IT
02117  002C03  C8                      INY		;POINT TO FIRST BYTE IN STRING
02118  002C04  98                      TYA		;UPDATE 'VARADR' TO BASE OF STRING
02119  002C05  20 81 2C                JSR UPDVAR               
02120  002C08  68                      PLA		;GET SIZE OF STRING
02121  002C09  20 81 2C                JSR UPDVAR	;UPDATE 'VARADR' BY PROPER AMOUNT
02122  002C0C  D0 B9                   BNE CHKVAR	;AND LOOK FOR NEXT VARIABLE IN LIST
02123  002C0E  A5 3B         CHKSUB    LDA STRSWT	;ARE WE LOOKING FOR A STRING VARIABLE
02124  002C10  D0 C5                   BNE NOTVAR	;BRANCH IF WE ARE, CAN'T BE THIS NUMERIC VARIABLE
02125  002C12  A5 39                   LDA VSUB	;GET HIGH ORDER SUBSCRIPT WE ARE LOOKING FOR
02126  002C14  C8                      INY		;POINT TO SUBSCRIPT IN LIST
02127  002C15  D1 37                   CMP(VARADR),Y	;ARE THEY THE SAME?     
02128  002C17  D0 BE                   BNE NOTVAR	;BRANCH IF THIS ONE IS NOT IT
02129  002C19  A5 3A                   LDA VSUB+1	;ARE LOW ORDERS ALSO THE SAME?
02130  002C1B  C8                      INY
02131  002C1C  D1 37                   CMP(VARADR),Y          
02132  002C1E  D0 B7                   BNE NOTVAR	;BRANCH IF THEY ARE NOT THE SAME
02133  002C20  20 AE 2C      LOCVAR    JSR FETVAR	;GET THE VARIABLE'S VALUE INTO FLAC
02134  002C23  20 4B 28                JSR POPJ	;AND RETURN TO CALLER 
02135  002C26  A5 3B         NOVAR     LDA STRSWT	;IS THIS STRING A VARIABLE 
02136  002C28  D0 21                   BNE NOSTR	;BRANCH IF IT IS A STRING VARIABLE 
02137  002C2A  A5 3D                   LDA VCHAR	;GET THE VARIABLE'S NAME 
02138  002C2C  91 37                   STA (VARADR),Y	;STORE IT IN LIST
02139  002C2E  C8                      INY		;POINT TO NEXT IN LIST
02140  002C2F  A5 39                   LDA VSUB	;GET HIGH ORDER SUBSCRIPT
02141  002C31  91 37                   STA (VARADR),Y	;SAVE IT IN LIST
02142  002C33  C8                      INY		;POINT TO NEXT
02143  002C34  A5 3A                   LDA VSUB+1	;GET LOW ORDER SUBSCRIPT
02144  002C36  91 37                   STA (VARADR),Y	;SAVE IT IN LIST
02145  002C38  A9 00                   LDA #$00	;GET A ZERO
02146  002C3A  A2 06                   LDX #NUMBF+1	;GET COUNT OF NUMBER OF BYTES IN NUMBER
02147  002C3C  C8            ZERVAR    INY		;POINT TO THE NEXT VARIABLE
02148  002C3D  91 37                   STA (VARADR),Y	;ZERO OUT VARIABLES VALUE
02149  002C3F  CA                      DEX		;COUNT THIS BYTE
02150  002C40  D0 FA                   BNE ZERVAR	;LOOP TILL DONE. NOTE: EXTRA ZERO AT END
02151  002C42  A9 FF                   LDA #EOV	;FLAG END OF VARIABLE LIST
02152  002C44  91 37                   STA (VARADR),Y	;FLAG END OF VARIABLE LIST
02153  002C46  20 8D 2C                JSR UPDEND	;UPDATE THE END OF THE VARIABLE LIST
02154  002C49  D0 D5                   BNE LOCVAR	;UNCONDITIONAL BRANCH, AS WE HAVE FOUND
02155  			;THE VARIABLE
02156  
02157  ; *** BEGIN GAVIN D. SECTION
02158  
02159  ;
02160  ; 
02161  ;  HERE WHEN STRING VARIABLE WAS NOT FOUND
02162  ; 
02163  
02164  002C4B  A9 FC         NOSTR     LDA #STRMRK	;ADD A STRING MARKER AT THE END OF VARIABLE LIST
02165  002C4D  91 37                   STA (VARADR),Y
02166  002C4F  C8                      INY
02167  002C50  A5 3D                   LDA VCHAR	;ADD IT'S NAME
02168  002C52  91 37                   STA (VARADR),Y
02169  002C54  C8                      INY
02170  002C55  A5 64                   LDA STRSIZ	;GET DEFAULT STRING SIZE
02171  002C57  91 37                   STA (VARADR),Y	;STORE AS SIZE OF STRING
02172  002C59  85 3C                   STA VSIZE	;ALSO STORE FOR OTHERS WHO NEED TO KNO
02173  002C5B  C8                      INY		;POINT TO FIRST BYTE OF STRING
02174  002C5C  98                      TYA		;UPDATE 'VARADR'
02175  002C5D  20 81 2C                JSR UPDVAR
02176  002C60  A0 00                   LDY #$00	;POINT TO FIRST BYTE OF STRING
02177  002C62  A9 20                   LDA #$20	;GET A BLANK
02178  002C64  91 37         STRINI    STA (VARADR),Y	;SET STRING TO ALL BLANKS
02179  002C66  C8                      INY
02180  002C67  C4 64                   CPY STRSIZ	;DONE YET?
02181  002C69  D0 F9                   BNE STRINI	;NO, LOOP TILL STRING IS ALL BLANKS
02182  002C6B  A9 FF                   LDA #EOV	;GET THE END OF VARIABLE LIST MARKER
02183  002C6D  91 37                   STA (VARADR),Y	;FLAG END OF LIST
02184  002C6F  98                      TYA		;UPDATE 'VARADR'
02185  002C70  20 8F 2C                JSR UBDENV
02186  002C73  4C F1 2B                JMP GETSTC	;GET BYTE FROM STRING AND RETURN
02187  002C76  A5 3E         VARINI    LDA VARBEG	;GET ADDR OF START OF VARIABLE LIST
02188  002C78  85 37                   STA VARADR	;AND SET POINTER
02189  002C7A  A5 3F                   LDA VARBEG+1
02190  002C7C  85 38                   STA VARADR+1
02191  002C7E  60                      RTS		;AND RETURN
02192  
02193  002C7F  A9 08         NXTVAR    LDA #VARSIZ	;ADD IN SIZE OF NUMERIC VARIABLE
02194  002C81  18            UPDVAR    CLC		;SETUP FOR ADDITION
02195  002C82  65 37                   ADC VARADR	;TO 'VARADR'
02196  002C84  85 37                   STA VARADR
02197  002C86  A5 38                   LDA VARADR+1
02198  002C88  69 00                   ADC #$00
02199  002C8A  85 38                   STA VARADR+1
02200  002C8C  60                      RTS
02201  ;
02202  ; ROUTINE TO UPDATE THE END OF THE VARIABLE LIST
02203  ;
02204  002C8D  A9 08         UPDEND    LDA #VARSIZ	;ADD SIZE OF NUMERIC VARIABLE
02205  002C8F  18            UBDENV    CLC
02206  002C90  65 37                   ADC VARADR	;ADD NUMBER IN ACCUMULATOR 'VARADR'
02207  002C92  85 42                   STA VAREND	;AND STORE RESULT IN 'VAREND'
02208  002C94  A5 38                   LDA VARADR+1
02209  002C96  69 00                   ADC #$00	;ADD IN THE CARRY
02210  002C98  85 43                   STA VAREND+1
02211  002C9A  60            BOMSVR    RTS		;AND RETURN
02212  ;
02213  ;ROUTINE TO BOMB OUT IF THE VARIABLE IS A STRING VARIABLE
02214  ;
02215  002C9B  A5 3B         BOMSTV    LDA STRSWT	;GET A STRING FLAG
02216  002C9D  F0 FB                   BEQ BOMSVR	;RETURN IF NOT A STRING
02217  002C9F  00                      BRK		;TRAP
02218            .BYTE SVNA	;?STRING VARIABLE NOT ALLOWED HERE 
02219  ;
02220  ;          'VARIABLE MANIPULATION UTILITIES
02221  ;
02222  ;"PUTVAR" PUT NUMBER IN FAC1 INTO THE VARIABLE
02223  ;
02224  002CA1  A0 03         PUTVAR    LDY #$03	;POINT TO START OF VALUE
02225  002CA3  B9 7D 00      PUTV1     LDA X1-3,Y	;GET A BYTE FROM FAC1
02226  002CA6  91 37                   STA (VARADR),Y	;STORE IT INTO VARIABLE
02227  002CA8  C8                      INY		;POINT TO NEXT BYTE
02228  002CA9  C0 08                   CPY #VARSIZ	;REACHED END OF VARIABLE YET?          
02229  002CAB  D0 F6                   BNE PUTV1	;NO, THEN MOVE SOME MORE
02230  002CAD  60                      RTS		;*** MUST RETURN WITH Z BIT = ! ! ***
02231  
02232  ; "FETVAR" FETCH VARIABLE VALUE INTO FAC1
02233  
02234  002CAE  A0 03         FETVAR    LDY #$03	;POINT TO START OF VALUE
02235  002CB0  B1 37         FETV1     LDA (VARADR),Y	;GET A BYTE FROM VARIABLE
02236  002CB2  99 7D 00                STA X1-3,Y	;PUT IT INTO FAC1
02237  002CB5  C8                      INY		;POINT TO NEXT BATE
02238  002CB6  C0 08                   CPY #VARSIZ	;REACHED THE END OF VARIABLE YET?
02239  002CB8  D0 F6                   BNE FETV1	;NO, THEN MOVE ANOTHER BYTE
02240  002CBA  60                      RTS		;YES, RETURN
02241  
02242  ;"PUSHIV" PUSH INCREMENT AND VARIABLE ADDR ON STACK USED BY "FOR" COMMAND
02243  
02244  002CBB  A2 37         PUSHIV    LDX #VARADR	;POINT TO VARIABLE ADDR
02245  002CBD  20 69 28                JSR PUSHB2	;PUSH IT INTO STACK
02246  002CC0  4C 84 28                JMP PHFAC2	;* PJMP * PUSH FAC2 INTO STACK AND RETURN
02247  
02248  ;"POPIV" POP INCREMENT AND VARIABLE ADDR OFF STACK
02249  
02250  002CC3  20 9A 28      POPIV     JSR PLFAC2	;RESTORE INTO FAC2
02251  002CC6  A2 38                   LDX #VARADR+1	;POINT TO VARIABLE ADDR
02252  002CC8  4C 59 28                JMP POPB2	;* PJMP * RESTORE INTO VARIABLE ADDR AND RETURN
02253  
02254  ;ZERO THE FLOATING POINT ACCUMULATOR FACE1
02255  
02256  002CCB  A2 04         ZRFAC1    LDX #NUMBF-1	;POINT TO LAST BYTE
02257  002CCD  A9 00                   LDA #$00	;LOAD A ZERO
02258  002CCF  95 80         ZRFAC     STA X1,X	;ZERO THE BYTE
02259  002CD1  CA                      DEX		;POINT TO NEXT ONE
02260  002CD2  D0 FB                   BNE ZRFAC	;LOOP TILL ALL OF MANTISSA ZEROED
02261  002CD4  A9 80                   LDA #$80	;NOW SET EXPONENT
02262  002CD6  85 80                   STA X1
02263  002CD8  60                      RTS		;AND RETURN
02264  ;
02265  ;          'INTERRUPT HANDLERS'
02266  ;
02267  002CD9  48            NOTBRK    PHA		;SAVE THE PROCESSOR STATUS          
02268  002CDA  A9 ED                   LDA #UNKINT	;UNKNOWN INTERRUPT
02269  002CDC  48                      PHA		;SAVE CODE ON STACK
02270  002CDD  D0 22                   BNE BERROR	;AND PRINT ERROR CODE
02271  002CDF  EA            NMISRV    NOP		;CURRENTLY PUNT NMI'S AS UNKNOWNS
02272  002CE0  85 71         INTSRV    STA ACSAV	;SAVE ACCUMULATOR
02273  002CE2  68                      PLA		;GET THE PROCESSOR STATUS
02274  002CE3  24 70                   BIT MSKBRK	;IS B BIT ON?
02275  002CE5  F0 F2                   BEQ NOTBRK	;BRANCH TO INTERRUPT SERVICE CHAIN
02276  002CE7  85 72                   STA STATUS	;SAVE OLD PROCESSOR STATUS     
02277  002CE9  68                      PLA		;GET THE LOW ORDER RETURN ADDRESS
02278  002CEA  18                      CLC		;GET READY FOR ADD
02279  002CEB  69 FF                   ADC #$FF	;ADD IN A -1
02280  002CED  85 73                   STA ITEMP1	;STORE IT IN PAGE ZERO
02281  002CEF  68                      PLA		;GET HIGH ORDER RETURN ADDR
02282  002CF0  69 FF                   ADC #$FF	;ADD IN A -1
02283  002CF2  85 74                   STA ITEMP1+1	;STORE IN PAGE ZERO
02284  002CF4  98                      TYA		;GET Y REGISTER
02285  002CF5  48                      PHA		;SAVE ON STACK
02286  002CF6  A0 00                   LDY #$00	;OFFSET OF ZERO
02287  002CF8  B1 73                   LDA (ITEMP1),Y	;GET BRK CODE     
02288  002CFA  48                      PHA		;SAVE ON STACK
02289  002CFB  30 04                   BMI BERROR	;BRANCH IF A SOFTWARE DETECTED ERROR
02290  002CFD  68                      PLA		;POSITIVE ERROR CODE, GET IT BACK
02291  002CFE  A9 EE                   LDA #UNRBRK	;UNRECOGNIZABLE BREAK
02292  002D00  48                      PHA		;SAVE ON STACK
02293  ;
02294  ;          ERROR CODE OUTPUT ROUTINE
02295  ;
02296  002D01  A9 FF         BERROR    LDA #$FF	;GET -1
02297  002D03  85 81                   STA M1	;FOR HIGH ORDER
02298  002D05  68                      PLA		;GET THE NEG ERROR CODE
02299  002D06  85 82                   STA M1+1	;STORE INIC LOW ORDER
02300  002D08  20 4D 32                JSR FLT16	;FLOAT IT
02301  002D0B  20 0D 20                JSR SETUP	;RESET AND INITIALIZE IMPORTANT STUFF
02302  002D0E  20 99 2D                JSR CRLF	;ADVANCE A LINE
02303  002D11  A9 3F                   LDA #$3F	;'?' INDICATE AN ERROR
02304  002D13  20 02 29                JSR PRINTC	;
02305  002D16  20 5E 26                JSR OUTLN0	;OUTPUT IT
02306  002D19  A5 26                   LDA PC	;GET HIGH ORDER FOCAL STATEMENT COUNTER
02307  002D1B  10 04                   BPL BERR1	;BRANCH IF ERROR OCCURED IN A STORED STATEMENT
02308  002D1D  C9 FE                   CMP #STRLIN	;DID ERROR OCCUR WHILE EXECUTING A STRING?
02309  002D1F  D0 32                   BNE BERRC	;NO, THEN ERROR OCCURED IN DIRECT COMMAND
02310  002D21  A9 20         BERR1     LDA #$20	;SPACE FOR LOOKS
02311  002D23  20 02 29                JSR PRINTC	;
02312  002D26  A9 40                   LDA #$40	;NOW AN '@'
02313  002D28  20 02 29                JSR PRINTC          
02314  002D2B  A9 20                   LDA #$20	;ANOTHER SPACE FOR THE LOOKS
02315  002D2D  20 02 29                JSR PRINTC
02316  002D30  20 0A 27                JSR PUSHTP	;SAVE THE TEXTPOINTERS
02317  002D33  A5 26                   LDA PC	;EXECUTING A STRING WHEN ERROR OCCURED?
02318  002D35  10 0C                   BPL BERR2	;BRANCH IF NOT, PRINT STATEMENT NUMBER
02319  002D37  A5 27                   LDA PC+1	;YES, THEN GET THE STRING NAME
02320  002D39  20 E7 23                JSR PRTVNM	;AND PRINT IT
02321  002D3C  A9 24                   LDA #$24	;INDICATE IT'S A STRING
02322  002D3E  20 02 29                JSR PRINTC          
02323  002D41  D0 0D                   BNE BERR3	;AND UNCONDITIONALLY PRESS ON
02324  002D43  A9 26         BERR2     LDA #PC	;GET ADDR OF WHERE PROGRAM COUNTER IS STORED
02325  002D45  85 28                   STA TXTADR	;MAKE TEXT POINTER POINT TO IT
02326  002D47  A9 00                   LDA #$00
02327  002D49  85 29                   STA TXTADR+1	;HIGH ORDER IS ZERO
02328  002D4B  85 2A                   STA TEXTP
02329  002D4D  20 31 26                JSR PRNTLN	;OUTPUT THE LINE NUMBER
02330  002D50  20 11 27      BERR3     JSR POPTP	;RESTORE TEXT POINTERS
02331  			;FALL INTO 'BERRC'
02332  ;
02333  ;          'MORE INTERRUPT HANDLERS'
02334  ;
02335  002D53  20 96 2D      BERRC     JSR CRLF2	;ADVANCE TWO LINES
02336  002D56  A0 00                   LDY #$00	;POINT TO FIRST CHAR IN LINE
02337  002D58  A5 26                   LDA PC	;DIRECT COMMAND OR STRING?
02338  002D5A  30 02                   BMI OUTCMD	;BRANCH IF YES
02339  002D5C  A0 02                   LDY #$02	;NO, THEN POINT PAST LINE NUMBER
02340  002D5E  C4 2A         OUTCMD    CPY TEXTP	;ARE WE AT FRONT OF LINE?
02341  002D60  F0 31                   BEQ BERRET	;BRANCH IF YES, DON'T OUTPUT SPECIAL ERROR AID
02342  002D62  98            OUTCML    TYA		;SAVE Y OUTPUT ACROSS OUTPUT CALL
02343  002D63  48                      PHA
02344  002D64  B1 28                   LDA (TXTADR),Y	;OUTPUT CHAR FROM COMMAND LINE SO USER CAN SEE
02345  002D66  20 02 29                JSR PRINTC
02346  002D69  C9 0D                   CMP #$0D	;REACHED END OF LINE YET?
02347  002D6B  F0 05                   BEQ EREOL	;BRANCH IF YES,
02348  002D6D  68                      PLA		;RESTORE Y REG
02349  002D6E  A8                      TAY
02350  002D6F  C8                      INY		;POINT TO THE NEXT CHAR IN THE COMMAND LINE
02351  002D70  D0 F0                   BNE OUTCML	;AND LOOP TILL ALL OF THE COMMAND LINE HAS BEEN OUTPUT
02352  002D72  68            EREOL     PLA		;ADJUST STACK
02353  002D73  20 9E 2D                JSR OUTLF	;FOLLOW WITH A LINE FEED
02354  002D76  C6 2A         CHKERR    DEC TEXTP	;COUNT DOWN NUMBER OF BYTES TILL ERROR
02355  002D78  A0 00                   LDY #$00	;ASSUME WE COUNT BACK TO ZERO
02356  002D7A  A5 26                   LDA PC	;DIRECT COMMAND OR STRING
02357  002D7C  30 02                   BMI CHKERC	;BRANCH IF YES
02358  002D7E  A0 02                   LDY #$02	;NO, THEN WE ONLY COUNT BACK TO LINE NUMBER
02359  002D80  C4 2A         CHKERC    CPY TEXTP	;HAVE WE OUTPUT ENOUGH SPACES TO GET ERROR BYTE?
02360  002D82  F0 07                   BEQ EARROW	;BRANCH IF YES, OUTPUT UPARROW TO FLAG CHARACTER
02361  002D84  A9 20                   LDA #$20	;NO, THEN ADVANCE ONE SPACE
02362  002D86  20 02 29                JSR PRINTC          
02363  002D89  10 EB                   BPL CHKERR	;AND UNCONDITIONALLY CHECK AGAIN
02364  002D8B  A9 5E         EARROW    LDA #$5E	;OUTPUT UPARROW TO INDICATE WHERE ERROR IS
02365  002D8D  20 02 29                JSR PRINTC
02366  002D90  20 96 2D                JSR CRLF2	;AND ADVANCE FOR LOOKS
02367  002D93  4C 31 20      BERRET    JMP START	;AND RESTART
02368  ;
02369  ;
02370  002D96  20 99 2D      CRLF2     JSR CRLF          ;ADVANCE TWO LINES
02371  002D99  A9 0D         CRLF      LDA #$0D          ;A CARRIAGE RETURN
02372  002D9B  20 02 29                JSR PRINTC
02373  002D9E  A9 0A         OUTLF     LDA #$0A          ;AND A LF
02374  002DA0  4C 02 29                JMP PRINTC          ;* PJMP * TO PRINT ROUTINE
02375  ;
02376  ;          'INTEGER LINE NUMBER INPUT ROUTINE'
02377  ;
02378  ; 'GETLIN' THIS ROUTINE IS CALLED IF THE FIRST CHAR OF A LINE NUMBER
02379  ; IS 0-9 FOR ADDED SPEED, AS THE CALL TO 'EVAL' IS POWERFUL
02380  ; BUT SLOW (SEE 'GETLN').
02381  ;
02382  002DA3  20 C2 2D      GETILN    JSR GETIN	;GET A TWO-DIGIT INTEGER
02383  002DA6  85 2C                   STA GRPNO	;SAVE AS GROUP NUMBER
02384  002DA8  20 3E 2B                JSR TTERMS	;IS TERMINATOR ONE WE RECOGNIZE?
02385  002DAB  F0 31                   BEQ GETIR	;YES, THEN RETURN
02386  002DAD  C9 2E                   CMP #$2E	;NO, IS IT A PERIOD?
02387  002DAF  D0 29                   BNE GETBAD	;NO, THEN A BAD LINE NUMBER
02388  002DB1  20 BB 29                JSR TESTNS	;ANOTHER NUMBER?
02389  002DB4  B0 24                   BCS GETBAD	;NO, THEN ERROR
02390  002DB6  20 C2 2D                JSR GETIN	;YES, THEN GET NEXT NUMBER
02391  002DB9  90 04                   BCC LNOK	;BRANCH, IF TWO-DIGIT OUTPUT
02392  002DBB  AA                      TAX		;MOVE INTO X
02393  002DBC  BD DF 2D                LDA TENS,X	;YES, THEN ASSUME TRAILING ZERO
02394  002DBF  85 2D         LNOK      STA LINENO	;SAVE THE LINE (STEP) NUMBER
02395  002DC1  60                      RTS		;AND RETURN
02396  ;
02397  002DC2  29 0F         GETIN     AND #$0F	;MAKE 0-9
02398  002DC4  48                      PHA		;SAVE ON STACK
02399  002DC5  20 BB 29                JSR TESTNS	;TEST NEXT NON-BLANK
02400  002DC8  68                      PLA		;RESTORE SAVED NUMBER
02401  002DC9  B0 13                   BCS GETIR	;RETURN IF NOT A DIGIT
02402  002DCB  AA                      TAX		;PLACE SAVED NUMBERINTO X
02403  002DCC  A5 2B                   LDA CHAR	;GET NEW DIGIT
02404  002DCE  29 0F                   AND #$0F	;FORM 0-9
02405  002DD0  7D DF 2D                ADC TENS,X	;ADD IN PROPER HIGH ORDER
02406  002DD3  48                      PHA		;SAVE NUMBER ON STACK
02407  002DD4  20 BB 29                JSR TESTNS	;TEST NEXT NON-BLANK
02408  002DD7  68                      PLA		;GET SAVED NUMBER BACK
02409  002DD8  B0 03                   BCS GETIRC	;BRANCH IF NOT A NUMBER
02410  002DDA  4C 25 26      GETBAD    JMP BADLNO	;BAD LINE NUMBER BRANCH AID
02411  002DDD  18            GETIRC    CLC		;INDICATE TWO DIGITS INPUT
02412  002DDE  60            GETIR     RTS		;RETURN
02413  ;
02414  TENS      .BYTE 0
02415            .BYTE 10
02416            .BYTE 20
02417            .BYTE 30
02418            .BYTE 40
02419            .BYTE 50          ; Aresco code has a $15 here, clearly wrong
02420            .BYTE 60                 
02421            .BYTE 70
02422            .BYTE 80             
02423            .BYTE 90                  
02424  ;
02425  ;
02426  ;
02427  ;               FOCAL FUNCTIONS
02428  ;
02429  ;
02430  002DE9  A0 00         FUNC      LDY #$00	; SET OFFSET TO ZERO
02431  002DEB  8A                      TXA		;PLACE HASH CODE INTO ACCUMULATOR
02432  002DEC  BE F5 34      FUNC1     LDX FUNTAB,Y	;GET TABLE VALUE
02433  002DEF  F0 15                   BEQ BADFUN	;END OF TABLE AND NOT FOUND
02434  002DF1  D9 F5 34                CMP FUNTAB,Y	;MATCH YET?
02435  002DF4  F0 03                   BEQ GOTFUN	;YES, WE FOUND IT
02436  002DF6  C8                      INY		;NO, POINT TO NEXT ENTRY
02437  002DF7  D0 F3                   BNE FUNC1	;AND TRY IT
02438  002DF9  B9 2D 35      GOTFUN     LDA FUNADL,Y	;GET LOW ORDER ARRD OFROUTINE TO HANDLE
02439  002DFC  85 5F                   STA TEMP1	;FUNCTION
02440  002DFE  B9 11 35                LDA FUNADH,Y	;GET HIGH ORDER
02441  002E01  85 60                   STA TEMP1+1	;STORE IT
02442  002E03  6C 5F 00                JMP (TEMP1)	;AND GO TO IT (TEMP1)
02443  
02444  002E06  00            BADFUN    BRK		;TRAP
02445            .BYTE UNRFUN	;?UNRECOGNIZABLE FUNCTION NAME
02446  ;
02447  ;     FABS - ABS. VALUE FUNCTION
02448  ;
02449  002E08  20 F7 33      FABS      JSR ABSF1	;TAKE ABSOLUTE VALUE OF FAC1
02450  002E0B  4C 14 2E                JMP FPOPJ	;*PJMP* AND RETURN
02451  ;
02452  ;     FINT & FINR - RETURN INTEGER FUNCTIONS
02453  ;
02454  002E0E  20 A7 2F      FINT      JSR INTFIX	; MAKE FAC1 AN INTEGER
02455  002E11  20 39 32      FLPOPJ    JSR FLOAT	; FLOAT ALL BITS
02456  002E14  20 4B 28      FPOPJ     JSR POPJ	; *FJMP* AND RETURN
02457  ;
02458  ; 'FINR' INTEGERIZE AFTER ROUNDING
02459  ;
02460  002E17  20 93 2F      FINR      JSR INTGER	; FORM ROUNDED INTEGER
02461  002E1A  4C 11 2E                JMP FLPOPJ	;*PJMP*FLOAT AND RETURN
02462  ;
02463  ;              ROUTINES TO CHECK RANGE INPUT AND OUTPUT DEVICE NUMBERS
02464  ;
02465  002E1D  C9 03         CHKODV    CMP #ODEVM	;COMPARE AC AGAINST MAX ALLOWED
02466  002E1F  10 05                   BPL RNGDEV	;BRANCH IF ERROR
02467  002E21  60            CHKRTS    RTS		;RETURN IF OK
02468  002E22  C9 03         CHKIDV    CMP #IDEVM	;COMPARE AGAINST MAX
02469  002E24  30 FB                   BMI CHKRTS	;RETURN IF OK
02470  002E26  C9 FF         RNGDEV    CMP #$FF	;MINUS 1?
02471  002E28  F0 F7                   BEQ CHKRTS	;BRANCH IF YES, ALWAYS IN RANGE
02472  002E2A  00                      BRK		;TRAP
02473  	  .BYTE DEVRNG	;DEVICE NUMBER OUT OF RANGE
02474  ;
02475  ;              "FINI" INITIALIZE INPUT DEVICE 
02476  ;
02477  002E2C  20 93 2F      FINI      JSR INTGER	;MAKE ARGUMENT INTEGER
02478  002E2F  30 06                   BMI INIRET	;IGNORE IF NEGATIVE
02479  002E31  20 22 2E                JSR CHKIDV	;CHECK FOR VALIDITY
02480  002E34  20 8D 2E                JSR INI	;GO CALL APPROPRIATE ROUTINE     
02481  002E37  4C 11 2E      INIRET    JMP FLPOPJ	;NO ERRORS, RETURN
02482  ;
02483  ;            'FINO' INITIALIZE OUTPUT DEVICE
02484  ;
02485  002E3A  20 93 2F      FINO      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02486  002E3D  30 F8                   BMI INIRET	;IGNORE IF NEGATIVE
02487  002E3F  20 1D 2E                JSR CHKODV	;CHECK FOR VALIDITY
02488  002E42  20 A2 2E                JSR INO	;GO CALL APPROPRIATE ROUTINE
02489  002E45  4C 11 2E                JMP FLPOPJ	;NO ERRORS - RETURN
02490  ;
02491  ;            'FCLI' CLOSE INPUT DEVICE
02492  ;
02493  002E48  20 93 2F      FCLI      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02494  002E4B  30 06                   BMI CLIRET	;IGNORE IF NEGATIVE
02495  002E4D  20 22 2E                JSR CHKIDV	;RANGE CHECK THE DEVICE NUMBER
02496  002E50  20 B6 2E                JSR CLI_	;CALL DEVICE DEPENDENT CODE
02497  002E53  4C 11 2E      CLIRET    JMP FLPOPJ	;NO ERRORS - RETURN
02498  ;
02499  ;           "FCLO" CLOSE OUTPUT DEVICE
02500  ;
02501  002E56  20 93 2F      FCLO      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02502  002E59  30 F8                   BMI CLIRET	;IGNORE IF NEGATIVE
02503  002E5B  20 1D 2E                JSR CHKODV	;RANGE CHECK THE DEVICE NUMBER
02504  002E5E  20 C2 2E                JSR CLO	;CALL DEVICE DEPENDENT CODE
02505  002E61  4C 11 2E                JMP FLPOPJ	;NO ERRORS - RETURN
02506  ;
02507  ;           "FCON" SET CONSOLE DEVICE
02508  ;
02509  002E64  20 93 2F      FCON      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02510  002E67  30 11                   BMI RETCON	;BRANCH IF NEGATIVE
02511  002E69  20 22 2E                JSR CHKIDV	;MAKE SURE DEVICE IS IN RANGE FOR BOTH INPUT
02512  002E6C  20 1D 2E                JSR CHKODV	;AND OUTPUT
02513  002E6F  85 6A                   STA CONDEV	;MAKE IT CURRENT CONSOLE     
02514  002E71  20 15 20                JSR CLRDEV	;MAKE CURRENT IO DEVICE
02515  002E74  20 27 20                JSR INIDEV	;INITIALIZE IT FOR INPUT AND OUTPUT
02516  002E77  4C 11 2E                JMP FLPOPJ	;*PJMP* NO ERRORS - RETURN
02517  002E7A  A5 6A         RETCON    LDA CONDEV	;GET THE DEVICE NUMBER OF CONSOLE
02518  002E7C  20 41 32                JSR FLT8	;FLOAT IT
02519  002E7F  4C 14 2E                JMP FPOPJ	;*PJMP* AND RETURN
02520  ;
02521  ;           "FCUR" CONSOLE CURSOR ADDRESSING FUNCTION
02522  ;          NOTE:     THIS FUNCTION IS DEVICE DEPENDENT, AND IS HERE
02523  ;                    PRIMARILY BY POPULAR DEMAND. THE FUNCTION HAS
02524  ;                    TWO ARGUMENTS. THE FIRST IS THE ROW, THE SECOND     
02525  ;                    IS THE COLUMN, OF THE PLACE TO POSITION ON THE CONSOLE
02526  ;                    DEVICE (USUALLY ASSUMED TO BE CRT).
02527  ;
02528    2940              CONCUR = RTS1 ; Device dependant routine location - currently disabled
02529  002E82  20 79 2F      FCUR      JSR FI2ARG	;PICK UP TWO INTEGER ARGS
02530  002E85  20 40 29                JSR CONCUR	;*** CALL THE DEVICE DEPENDENT CODE ***
02531  002E88  B0 29                   BCS JOERRO	;BRANCH IF ERROR HAS OCCURED
02532  002E8A  4C 11 2E                JMP FLPOPJ	;* PJMP * AND RETURN
02533  ;
02534  ;ROUTINES TO DISPATCH TO DEVICE DEPENDENT INITIALIZATION ROUTINE
02535  ;ENTER EACH WITH THE DEVICE NUMBER IN THE ACCUMULATOR
02536  ;THEY WILL RETURN ONLY IF NO ERRORS WERRE ENCOUNTERED
02537  ;
02538  002E8D  AA            INI       TAX		;USE AS OFFSET TO ADDR TABLE
02539  002E8E  BD C3 35                LDA INIAH,X	;GET HIGH ORDER ADDR OF THE ROUTINE TO HANDLE
02540  002E91  85 60                   STA TEMP1+1	;SAVE IT
02541  002E93  BD C8 35                LDA INIAL,X	;GET LOW ORDER ADDR
02542  002E96  85 5F         INIC      STA TEMP1	;SAVE IT
02543  002E98  18                      CLC		;ASSUME SUCCESSS
02544  002E99  20 5E 00                JSR JSRIND	;CALL THE PROPER ROUTINE FOR THIS DEVICE
02545  002E9C  90 03                   BCC IRTS	;RETURN IF NO ERRORS
02546  002E9E  4C D6 28                JMP IERRI	;ERROR, GO COMPLAIN
02547  002EA1  60            IRTS      RTS
02548  
02549  002EA2  AA            INO       TAX		;USE AS OFFSET
02550  002EA3  BD CD 35                LDA INOAH,X	;GET HIGH ORDER OF THE ROUTINE TO HANDLE
02551  002EA6  85 60                   STA TEMP1+1	;SAVE IT
02552  002EA8  BD D2 35                LDA INOAL,X	;GET LOW ORDER OF THE ROUTINE TO HANDLE
02553  002EAB  85 5F         INOC      STA TEMP1	;SAVE IT
02554  002EAD  18                      CLC		;ASSUME SUCCESS
02555  002EAE  20 5E 00                JSR JSRIND	;CALL PROPER ROUTINE FOR THIS DEVICE
02556  002EB1  90 EE                   BCC IRTS	;RETURN IF NO ERRORS
02557  002EB3  4C 24 29      JOERRO    JMP OERRO	;COMPLAIN IF ERRORS
02558  
02559  002EB6  AA            CLI_      TAX		;USE AS OFFSET TO TABLE
02560  002EB7  BD D7 35                LDA CLIAH,X	;GET HIGH ORDER ADDR OF THE DEVICE DEPENDENT CODE
02561  002EBA  85 60                   STA TEMP1+1
02562  002EBC  BD DC 35                LDA CLIAL,X	;GET LOW ORDER ADDR
02563  002EBF  4C 96 2E                JMP INIC	;*PJMP* CALL DEVICE DEPENDENT CODE AND RETURN
02564  
02565  
02566  002EC2  AA            CLO       TAX		;USE AS OFFSET TO TABLE
02567  002EC3  BD E1 35                LDA CLOAH,X	;GET HIGH ORDER ADDR OF THE DEVICE DEPENDENT CODE
02568  002EC6  85 60                   STA TEMP1+1
02569  002EC8  BD E6 35                LDA CLOAL,X	;GET LOW ODER
02570  002ECB  4C AB 2E                JMP INOC	;*PJMP* CALL DEVICE DEPENDENT CODE AND RETURN
02571  ;
02572  ;           "FMEM"  MEMORY EXAMINE-DEPOSIT FUNCTION
02573  ;
02574  002ECE  20 79 2F      FMEM      JSR FI2ARG	;PICK UP TWO INTEGER ARGS
02575  002ED1  A4 2B                   LDY CHAR	;GET THE TERMINATOR
02576  002ED3  C0 2C                   CPY #$2C	;ANOTHER ARG?
02577  002ED5  F0 12                   BEQ FMEMD	;YES, THEN IT'S THE DEPCSIT FUNCTION
02578  002ED7  85 56                   STA ITMP1H	;SAVE HIGH ORDER ARRD TO EXAMINE
02579  002ED9  86 55                   STX ITMP1L	;SAVE THE LOW ORDER ADDR TO EXAMINE               
02580  002EDB  A0 00                   LDY #$00	;FORM OFFSET OF ZERO
02581  002EDD  B1 55                   LDA (ITMP1L),Y	;GET DATA STORED IN THE LOCATION
02582  002EDF  85 82         ST16PJ    STA M1+1	;SAVE IN INTEGER
02583  002EE1  84 81                   STY M1	;HIGH ORDER OF ZERO
02584  002EE3  20 4D 32      FL16PJ    JSR FLT16	;FLOAT A 16 BIT INTEGER
02585  002EE6  4C 14 2E                JMP FPOPJ	;*PJMP* AND RETURN
02586  
02587  002EE9  48            FMEMD     PHA		;SAVE HIGH ORDER
02588  002EEA  8A                      TXA		;
02589  002EEB  48                      PHA		;AND LOW ORDER 
02590  002EEC  20 89 2F                JSR NXIARG	;PICK UP THE NEXT INTEGER ARG
02591  002EEF  A8                      TAY		;SAVE IN Y REGISTER FOR A MOMENT
02592  002EF0  68                      PLA		;GET LOW ORDER ADDR BACK
02593  002EF1  85 55                   STA ITMP1L                         
02594  002EF3  68                      PLA		;GET HIGH ORDER ADDR BACK
02595  002EF4  85 56                   STA ITMP1H     
02596  002EF6  98                      TYA		;GET DATA TO DEPOSIT BACK
02597  002EF7  A0 00                   LDY #$00	;SET OFFSET OF ZERO
02598  002EF9  48                      PHA		;SAVE DATA TO DEPOSIT
02599  002EFA  B1 55                   LDA (ITMP1L),Y	;READ THE LOCATION
02600  002EFC  85 82                   STA M1+1	;SAVE AS INTEGER
02601  002EFE  84 81                   STY M1	;HIGH ORDER OF ZERO
02602  002F00  68                      PLA		;GET DATA TO DEPOSIT BACK AGAIN
02603  002F01  91 55                   STA (ITMP1L),Y	;STORE IN THE ADDR     
02604  002F03  A5 2B                   LDA CHAR	;GET TERMINATOR
02605  002F05  C9 2C                   CMP #$2C	; ',' MORE ARGS?
02606  002F07  D0 DA                   BNE FL16PJ	;* PJMP * NO, FLOAT AND RETURN
02607  002F09  20 1C 28                JSR PUSHJ	;MOVE PAST COMMA,
02608            .WORD EVALM1	;EVALUATE NEXT ARG
02609  002F0E  4C CE 2E                JMP FMEM	;AND TRY AGAIN
02610  ;
02611  ;          "FOUT" OUTPUT ASCII EQUIVALENT
02612  ;
02613  002F11  20 93 2F      FOUT      JSR INTGER	;FORM INTEGER
02614  002F14  20 02 29                JSR PRINTC	;OUTPUT THE CHARACTER
02615  002F17  4C 11 2E                JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02616  ;
02617  ;           "FCHR" RETUNR DECIMAL EQUIVALIENT CF ASCII CHAR INPUT
02618  ;
02619  002F1A  20 20 2F      FCHR      JSR GICHR	;GET A CHAR FROM INPUT DEVICE 
02620  002F1D  4C E3 2E                JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02621  ;
02622  ; ROUTINE TO INPUT ONE CHAR FROM INPUT DEVICE INTO FAC1
02623  ;
02624  002F20  A9 00         GICHR     LDA #$00	;ZERO HIGH ORDER
02625  002F22  85 81                   STA M1	;               
02626  002F24  A5 2B                   LDA CHAR	;SAVE CURRENT HAR
02627  002F26  48                      PHA
02628  002F27  20 C0 28                JSR READC	;NEXT CHAR FROM INPUT DEVICE
02629  002F2A  85 82                   STA M1+1	;STORE IN LOW ORDER
02630  002F2C  68                      PLA		;RESTORE SAVED CHAR
02631  002F2D  85 2B                   STA CHAR          
02632  002F2F  A5 82                   LDA M1+1	;GET CHAR INPUT INTO ACCUMULATOR
02633  002F31  60                      RTS		;AND RETURN
02634  ;
02635  ;           "FECH" SET CHAR ECHO CONTROL
02636  ;
02637  002F32  20 93 2F      FECH      JSR INTGER	;FORM INTEGER
02638  002F35  85 6B                   STA ECHFLG	;SAVE IN FLAG FOR LATER REFERENCE
02639  002F37  4C 11 2E                JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02640      ;
02641  ;           "FIDV" SET INPUT DEVICE FUNCTION
02642  ;
02643  002F3A  A2 44         FIDV      LDX #STIADR	;GET ADDR TO STORE INTO STRING INFORMATION
02644  002F3C  20 5F 2F                JSR GTDEVN	;GET DEVICE NUMBER (POSSIBLY A STRING)
02645  002F3F  20 22 2E                JSR CHKIDV	;RANGE CHECK IT
02646  002F42  A6 66                   LDX IDEV	;SAVE PREVIOUS VALUE FOR POSSIBLE RESTORE
02647  002F44  86 68                   STX IDVSAV	;
02648  002F46  85 66                   STA IDEV	;MAKE IT THE CURRENT INPUT DEVICE
02649  002F48  4C 59 2F                JMP FIODRT	;* PJMP * SET FAC1 TO ZERO, THEN RETURN
02650  ;
02651  ;           "FODV" SET OUTPUT DEVICE FUNCTION
02652  ;
02653  002F4B  A2 48         FODV      LDX #STOADR	;GET SDDR TO STORE STRING INFORMATION
02654  002F4D  20 5F 2F                JSR GTDEVN	;GET DEVICE NUMBER (POSSIBLY A STRING)
02655  002F50  20 1D 2E                JSR CHKODV	;RANGE CHECK IT
02656  002F53  A6 67                   LDX ODEV	;SAVE PREVIOUS VALUE FOR POSSIBLE RESTORE
02657  002F55  86 69                   STX ODVSAV
02658  002F57  85 67                   STA ODEV	;SET AS OUTPUT DEVICE
02659  002F59  20 CB 2C      FIODRT    JSR ZRFAC1	;RETURN A VALUE OF ZERO FOR THE FUNCTION 
02660  002F5C  4C 11 2E                JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02661  ;
02662  ; ROUTINE TO GET A DEVICE NUMBER (POSSIBLY A STRING)
02663  ;
02664  002F5F  A5 3B         GTDEVN    LDA STRSWT	;WAS ARGUMENT A STRING VARIABLE?
02665  002F61  D0 03                   BNE STRDEV	;BRANCH IF YES
02666  002F63  4C 93 2F                JMP INTGER	;* PJMP * NO, JUST TO INTEGRIZE ARG AND RETURN
02667  002F66  A5 37         STRDEV    LDA VARADR	;STORE BASE ADDR OF STRING
02668  002F68  95 00                   STA $00,X	;IN POINTER
02669  002F6A  A5 38                   LDA VARADR+1
02670  002F6C  95 01                   STA $01,X
02671  002F6E  A5 3A                   LDA VSUB+1	;GET SUBSCRIPT OF PLACE TO START
02672  002F70  95 02                   STA $02,X          
02673  002F72  A5 3C                   LDA VSIZE	;AND GET MAX SIZE OF STRING
02674  002F74  95 03                   STA $03,X
02675  002F76  A9 FF                   LDA #$FF	;RETURN DEVICE NUMBER OF -1
02676  002F78  60                      RTS		;AND RETURN
02677  
02678  002F79  A5 2B         FI2ARG    LDA CHAR	;GET TERMINATOR
02679  002F7B  C9 2C                   CMP #$2C	;',' ANOTHER ARG?
02680  002F7D  D0 12                   BNE FARGM	;BRANCH IF ARG IS MISSING
02681  002F7F  20 93 2F                JSR INTGER	;GET A SINGLE BYTE INTEGER
02682  002F82  48                      PHA		;SAVE ACROSS 'EVAL' CALL
02683  002F83  20 89 2F                JSR NXIARG	;GET ANOTHER ARG
02684  002F86  AA                      TAX		;SAVE THE SECOND ARGUMENT
02685  002F87  68                      PLA		;GET THE FIRST ARGUMENT 
02686  002F88  60                      RTS		;AND RETURN
02687  ;
02688  002F89  20 1C 28      NXIARG    JSR PUSHJ	;MOVE PAST COMMA, EVALUATE NEXT ARGUMENT
02689            .WORD EVALM1
02690  002F8E  4C 93 2F                JMP INTGER	;*PJMP* FORM SINGLE BYTE INTEGER AND RETRUN
02691  
02692  002F91  00            FARGM     BRK		;TRAP
02693            .BYTE ARGM	;?ARGUMENT MISSING IN FUNCTION
02694  ;
02695  ;     ROUTINE TO GENERATE A ROUNDED INTEGER
02696  ;
02697  002F93  A2 96         INTGER    LDX #FHALF	;MOVE CONSTANT .50
02698  002F95  A0 7B                   LDY #X2	;INTO FAC2
02699  002F97  20 FF 33                JSR MOVXY
02700  002F9A  20 29 32                JSR SWAP	;PUT .5 IN FAC1
02701  002F9D  A5 7C                   LDA M2	;GET SIGN OF FAC2
02702  002F9F  10 03                   BPL INTG1	;OK IF POSITIVE
02703  002FA1  20 B8 32                JSR FCOMPL	;MAKE -.50
02704  002FA4  20 79 32      INTG1     JSR FADD	;ADD IT IN AS ROUNDING
02705  002FA7  20 18 33      INTFIX    JSR FIX	;AND FORM 23 BIT INTEGER
02706  002FAA  A5 83                   LDA M1+2	;GET LOW ORDER IF CALLER NEEDS IT               
02707  002FAC  60                      RTS		;AND RETURN
02708  ;
02709  ;           "FPIC" SOFTWARE PRIORITY INTERRUPT CONTROL FUNCTION
02710  ;
02711  002FAD  20 1C 28      FPICC     JSR PUSHJ	;CALL 'EVAL' TO PICK UP NEXT ARG
02712            .WORD EVALM1
02713  002FB2  A5 2B         FPIC      LDA CHAR	;GET CHAR WHICH TERMINATED ARGUMENT
02714  002FB4  C9 2C                   CMP #$2C	;IS THERE ANOTHER ARGUMENT TO FOLLOW
02715  002FB6  D0 D9                   BNE FARGM	;BRANCH IF NOT, GO COMPLAIN
02716  002FB8  20 93 2F                JSR INTGER	;YES, PICK UP VALUE OF FIRST
02717  002FBB  F0 27                   BEQ PISET	;BRANCH IF LEVEL TO ENABLE IS 0
02718  002FBD  48                      PHA		;SAVE LEVEL TO ENABLE
02719  002FBE  20 92 29                JSR GETC	;MOVE PAST COMMA
02720  002FC1  20 BC 25                JSR GETLNS	;AND PICK UP THE LINE NUMBER TO 'DO'
02721  002FC4  68                      PLA		;GET LEVEL BACK
02722  002FC5  AA                      TAX		;INTO X REGISTER
02723  002FC6  A5 2C                   LDA GRPNO	;GET GROUP NUMBER OF LINE TO 'DO'
02724  002FC8  9D 8B 35                STA INTGRP,X	;SAVE FOR LATER USE
02725  002FCB  A5 2D                   LDA LINENO	;GET STEP NUMBER OF LINE TO 'DO'
02726  002FCD  9D 94 35                STA INTLIN,X	;SAVE FOR LATER USE
02727  002FD0  A5 6D                   LDA ACTMSK	;GET MASK WHICH INDICATES WITH CHANNELS
02728  002FD2  1D A6 35                ORA BITTAB,X	;SET THE BIT FOR SPECIFIED CHANNELS
02729  002FD5  85 6D                   STA ACTMSK	;MAKING IT ACTIVE NOW
02730  002FD7  A5 2B         ENDPIC    LDA CHAR	;GET CHAR WHICH TERMINATES SECOND ARG
02731  002FD9  C9 2C                   CMP #$2C	;',' ANY MORE ARGS?
02732  002FDB  F0 D0                   BEQ FPICC	;BRANCH IF YES, PICK THEM UP
02733  002FDD  A0 00                   LDY #$00	;NO GET A ZERO
02734  002FDF  A5 6D                   LDA ACTMSK	;AND THE CURRENT ACTIVE MASK
02735  002FE1  4C DF 2E                JMP ST16PJ	;* PJMP * STORE, FLOAT AND RETURN IT AS VALUE
02736  
02737  002FE4  20 89 2F      PISET     JSR NXIARG	;GET NEXT ARG AS NUMBER
02738  002FE7  A5 82                   LDA M1+1	;IS IT NEGATIVE
02739  002FE9  30 EC                   BMI ENDPIC	;YES, THEN THIS CALL IS A NO-OP
02740  002FEB  A5 83                   LDA M1+2	;NO, GET THE INTEGER VALUE (0-255)
02741  002FED  85 6D                   STA ACTMSK	;AND STORE THAT AS NEW ACTIVE MASK
02742  002FEF  4C D7 2F                JMP ENDPIC	;AND CHECK FOR MORE ARGUMENTS BEFORE RETURNING
02743  ;
02744  ;                    'FOCAL STRING FUNCTIONS'
02745  ;
02746  ;           "FISL" INITIALIZE STRING LENGTH
02747  ;
02748  002FF2  20 1C 28      FISLNX    JSR PUSHJ	;PICK UP NEXT ARGUMENT
02749           .WORD EVALM1     
02750  002FF7  A5 64         FISL      LDA STRSIZ	;SAVE DEFAULT STRING SIZE
02751  002FF9  48                      PHA          
02752  002FFA  20 93 2F                JSR INTGER	;GET FIRST ARGUMENT WHICH IS SIZE TO SET
02753  002FFD  85 64                   STA STRSIZ
02754  002FFF  20 0E 30                JSR FGTSV	;GET NEXT ARGUMENT WHICH IS A STRING VARIABLE
02755              ;IF NOT PREVIOUSLY DEFINED IT WILL BE DEFINED
02756              ;WITH SUPPLIED LENGTH.
02757  003002  68                      PLA		;RESTORE WITH LENGTH
02758  003003  85 64                   STA STRSIZ
02759  003005  A5 2B                   LDA CHAR
02760  003007  C9 2C                   CMP #$2C	;',' ANY MORE ARGS?
02761  003009  F0 E7                   BEQ FISLNX	;BRANCH IF YES, PROCESS THEM
02762  00300B  4C 14 2E                JMP FPOPJ	;* PJMP * NO, THEN RETURN
02763  ;
02764  ; ROUTINE TO GET A STRING VARIABLE FROM PROGRAM TEXT
02765  ;
02766  00300E  A5 2B         FGTSV     LDA CHAR	;ANY MORE ARGUMENTS IN FUNCTION CALL?
02767  003010  C9 2C                   CMP #$2C
02768  003012  D0 15                   BNE FSTRBA	;BRANCH IF NOT, ERROR
02769  003014  20 92 29                JSR GETC	;YES, MOVE PAST COMMA
02770  003017  20 1C 28      FGTSV1    JSR PUSHJ	;CALL 'GETVAR' TO GET A VARIABLE
02771            .WORD GETVAR
02772  00301C  A5 3B                   LDA STRSWT	;WAS IT A STRING VARIABLE?
02773  00301E  D0 02                   BNE SVOK	;BRANCH IF IT WAS 
02774  003020  00                      BRK		;TRAP
02775            .BYTE SVRQ	;?STRING VARIABLE REQUIRED HERE
02776  003022  A4 3A         SVOK      LDY VSUB+1	;GET ELEMENT POSITION
02777  003024  A5 37                   LDA VARADR	;AND LOW AND
02778  003026  A6 38                   LDX VARADR+1	;HIGH ORDER BASE ADDR OF STRING
02779  003028  60                      RTS		;AND RETURN
02780  
02781  003029  00            FSTRBA    BRK		;TRAP
02782            .BYTE BASTRF	;?BAD OR MISSING ARGUMENT IN STRING FUNCTION
02783  ;
02784  ;           "FSTI" INPUT A STRING FROM INPUT DEVICE
02785  ;
02786  00302B  20 8D 30      FSTI      JSR SETSIO	;PICK UP ARGS
02787  00302E  20 20 2F      FSTINX    JSR GICHR	;GET A CHARACTER FROM INPUT DEVICE
02788  003031  C5 3D                   CMP VCHAR	;IS THIS THE TERMINATOR?
02789  003033  F0 10                   BEQ SENDIO	;YES, THEN THAT'S ALL FOLKS
02790  003035  A4 3A                   LDY VSUB+1	;GET SUBSCRIPT TO PLACE CHAR
02791  003037  C9 7F                   CMP #RUBCHR	;IS THE CHARACTER A RUBOUT?
02792  003039  F0 15                   BEQ RUBSTI	;BRANCH IF YES, SEE IF WE DO SOMETHING
02793  00303B  91 37         FSTOC     STA (VARADR),Y	;STORE CHAR THERE
02794  00303D  E6 3A                   INC VSUB+1	;POINT TO NEXT
02795  00303F  E6 55                   INC STRCNT	;COUNT THIS CHARACTER
02796  003041  C6 59                   DEC STRMAX	;REACH MAX ALLOWED?
02797  003043  D0 E9                   BNE FSTINX	;BRANCH IF NOT, INPUT MORE
02798  003045  A9 00         SENDIO    LDA #$00	;STORE A ZERO IN HIGH ORDER
02799  003047  85 81                   STA M1               
02800  003049  A5 55                   LDA STRCNT	;GET NUMBER ACTUALLY MOVED
02801  00304B  85 82                   STA M1+1          
02802  00304D  4C E3 2E                JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02803  ;
02804  ;HERE IF RUBOUT SEEN DURING A STRING INPUT
02805  ;
02806  003050  A6 66         RUBSTI    LDX IDEV	;IS THE INPUT DEVICE
02807  003052  E4 6A                   CPX CONDEV	;THE CONSOLE?
02808  003054  D0 E5                   BNE FSTOC	;BRANCH IF NOT, DON'T DO ANYTHING SPECIAL
02809  003056  C4 5D                   CPY STBSAV	;YES, ARE WE TRYING TO RUBOUT PAST STARTING SUBSCRIPT?
02810  003058  F0 D4                   BEQ FSTINX	;BRANCH IF SO, DON'T DO ANYTHING, IGNORE RUBOUT
02811  00305A  A4 6B                   LDY ECHFLG	;DOES USER WANT CHARACTER ECHOING?
02812  00305C  D0 0E                   BNE RUBSC	;BRANCH IF ECHOING DISABLED
02813  00305E  A4 6C                   LDY DELSPL	;DO WE DO FANCY CRT STYLE RUBOUTS?
02814  003060  F0 05                   BEQ RUBS1	;BRANCH IF NOT
02815  003062  20 7D 29                JSR EATTVC	;YES, THEN EAT THE CHAR OFF CRT SCREEN
02816  003065  10 05                   BPL RUBSC	;AND DO COMMON THINGS
02817  003067  A9 5C         RUBS1     LDA #RUBECH	;ECHO PLAIN CHAR TO INDICATE A RUBOUT
02818  003069  20 08 29                JSR PRNTC     ; SamCoVT - scan says PRINTC but binary version 
02819                          ; uses PRNTC, which just skips NULL check
02820  00306C  C6 3A         RUBSC     DEC VSUB+1	;PACK UP ONE BYTE IN THE STRING
02821  00306E  C6 55                   DEC STRCNT	;DON'T COUNT THE CHARACTER RUBBED OUT
02822  003070  E6 59                   INC STRMAX
02823  003072  4C 2E 30                JMP FSTINX	;AND GET NEXT CHARACTER
02824  ;
02825  ;           "FSTO" OUTPUT A STRING TO OUTPUT DEVICE
02826  ;
02827  003075  20 8D 30      FSTO      JSR SETSIO	;GET ARGS
02828  003078  A4 3A         FSTONX    LDY VSUB+1	;GET SUBSCRIPT OF BYTE IN STRING
02829  00307A  B1 37                   LDA(VARADR),Y	;GET THE BYTE
02830  00307C  C5 3D                   CMP VCHAR	;TERMINATOR?
02831  00307E  F0 C5                   BEQ SENDIO	;BRANCH IF YES
02832  003080  20 02 29                JSR PRINTC	;OUTPUT IT
02833  003083  E6 3A                   INC VSUB+1	;POINT TO NEXT BATE
02834  003085  E6 55                   INC STRCNT	;COUNT THIS ONE OUTPUR
02835  003087  C6 59                   DEC STRMAX	;OUTPUT MAX YET?
02836  003089  D0 ED                   BNE FSTONX	;BRANCH IF MORE TO OUTPUT
02837  00308B  F0 B8                   BEQ SENDIO	;BRANCH IF WE HAVE HIT LIMIT
02838  ;
02839  ; ROUTINE TO GET ARGS FOR 'FSTI' AND 'FSTD'
02840  ;
02841  00308D  A9 00         SETSIO    LDA #$00	;GET A ZERO
02842  00308F  85 55                   STA STRCNT	;INIT BYTE COUNT TO ZERO
02843  003091  20 93 2F                JSR INTGER	;GET MAX NUMBER OF CHARACTER TO MOVE
02844  003094  85 59                   STA STRMAX
02845  003096  20 0E 30                JSR FGTSV	;GET THE STRING VARIABLE
02846  003099  48                      PHA		;SAVE NEAT STUFF RETURNED
02847  00309A  8A                      TXA
02848  00309B  48                      PHA
02849  00309C  98                      TYA
02850  00309D  48                      PHA
02851  00309E  A5 2B                   LDA CHAR	;IS THE OPTIONAL TERMINATOR ARG SUPPLIED?
02852  0030A0  C9 2C                   CMP #$2C      
02853  0030A2  F0 04                   BEQ SETS1	;YES, THEN PICK IT UP
02854  0030A4  A9 FF                   LDA #$FF	;NO, THEN SET IT TO $FF
02855  0030A6  D0 08                   BNE SETS2	;AND ENTER COMMON CODE
02856  0030A8  20 1C 28      SETS1     JSR PUSHJ	;MOVE PAST COMMA, PICK UP NEXT ARG
02857            .WORD EVALM1
02858  0030AD  20 93 2F                JSR INTGER	;FORM INTEGER
02859  0030B0  85 3D         SETS2     STA VCHAR	;SAVE TERMINATION CHARACTER
02860  0030B2  68                      PLA		;RESTORE GOOD STUFF
02861  0030B3  85 3A                   STA VSUB+1	;
02862  0030B5  85 5D                   STA STBSAV	;REMEMBER SUBSCRIPT TO BEGIN I-O TO/FROM
02863  0030B7  68                      PLA                    
02864  0030B8  85 38                   STA VARADR+1
02865  0030BA  68                      PLA
02866  0030BB  85 37                   STA VARADR
02867  0030BD  60                      RTS		;AND RETURN
02868  ;
02869  ; ROUTINE TO WRITE A STRING
02870  ;
02871  0030BE  A4 4A         WSTRNG    LDY STOPNT	;new line - not in the 6502 Grp original
02872  
02873              ;original code  	(appears to be a patch
02874              ;WSTRNG CPY STOMAX    in ProgExch code)
02875              ;     BEQ WSRET
02876              ;     STA (STOADR),Y
02877              ;     INC STOPNT
02878              ;WSRET      PLA
02879              ;     RTS
02880  ;                    ; then go on with IOSRET
02881  ;
02882  0030C0  C4 4B                   CPY STOMAX	;BEYOND END OF STRING
02883  0030C2  F0 04                   BEQ IOSRET	;BRANCH IF YES, IGNORE
02884  0030C4  91 48                   STA (STOADR),Y	;NO, STORE CHAR IN STRING
02885  0030C6  E6 4A                   INC STOPNT	;POINT TO NEXT BYTE
02886  
02887  0030C8  A9 0D         IOSRET    LDA #$0D	;RETURN A CR   
02888              ;additional line in original: 
02889                      ;STA CHAR ;also in char
02890  0030CA  60                      RTS		;AND RETURN 
02891  ;
02892  ; ROUTINE TO INPUT FROM A STRING
02893  ;
02894  0030CB  A4 46         RSTRNG    LDY STIPNT	;GET POINTER TO NEXT BYTE
02895  0030CD  C4 47                   CPY STIMAX	;BEYOND END OF STRING?
02896  0030CF  F0 F7                   BEQ IOSRET	;BRANCH IF YES, RETURN A CARRIAGE RETURN
02897  0030D1  B1 44                   LDA (STIADR),Y	;NO, GET BYTE FROM STRING
02898  0030D3  85 2B                   STA CHAR	;SAVE FOR THOSE WHO NEED IT
02899  0030D5  E6 46                   INC STIPNT	;AND POINT TO NEXT
02900  0030D7  60                      RTS		;AND RETURN
02901  ;
02902  ;           FSLK - STRING "LOOK" FUNCTION
02903  ;
02904  0030D8  A5 3B         FSLK      LDA STRSWT	;WAS ARG A STRING VARIABLE
02905  0030DA  D0 02                   BNE FSLK1	;YES, THEN PROCEED
02906  0030DC  00                      BRK		;TRAP
02907            .BYTE BASTRF	;?BAD OR MISSING ARGUMENT IN STRING
02908  0030DE  A5 37         FSLK1     LDA VARADR	;COPY POINTERS INTO STRING1 POINTERS
02909  0030E0  85 55                   STA STRAD1
02910  0030E2  A5 38                   LDA VARADR+1
02911  0030E4  85 56                   STA STRAD1+1
02912  0030E6  A5 3A                   LDA VSUB+1
02913  0030E8  85 57                   STA SBEG1	;STORE BEGINNING POSITION
02914  0030EA  20 0E 30                JSR FGTSV	;GET NEXT STRING PARAMETER
02915  0030ED  84 58                   STY SEND1	;STORE ENDING POSITION
02916  0030EF  20 0E 30                JSR FGTSV	;GET STRING 2 POINTERS
02917  0030F2  85 59                   STA STRAD2	;
02918  0030F4  86 5A                   STX STRAD2+1
02919  0030F6  84 5B                   STY SBEG2
02920  0030F8  20 0E 30                JSR FGTSV	;GET ENDING POSITION 
02921  0030FB  84 5C                   STY SEND2	;STORE IT
02922  0030FD  A9 FF                   LDA #$FF	;ASSUME -1 (STRING NOT FOUND)
02923  0030FF  85 81                   STA M1
02924  003101  85 82                   STA M1+1
02925  ;
02926  ;SEARCH ROUTINE
02927  ;
02928  003103  20 41 31      LKFCHR    JSR CMPCHR	;FIRST CHAR MATCH?
02929  003106  F0 09                   BEQ FCMAT	;BRANCH IF YES
02930  003108  C4 5C         CHKEOS    CPY SEND2	;NO, REACHES END OF STRING2?
02931  00310A  F0 32                   BEQ SNOTF	;BRANCH IF YES, STRING1 NOT FOUND IN STRING2
02932  00310C  E6 5B                   INC SBEG2	;NO, POINT TO NEXT CHAR IN STRING2
02933  00310E  4C 03 31                JMP LKFCHR	;AND TRY TO FIND CHAR MATCH
02934  ;
02935  ;  HERE IF FIRST CHAR IN STRING1 MATCHES A CHAR IN STRING2
02936  ;
02937  003111  20 4A 31      FCMAT     JSR PUSHSP	;SAVE CURRENT POSITION IN BOTH STRINGS
02938  003114  A5 57         NXCMAT    LDA SBEG1	;REACHED END OF  FIRST STRING?
02939  003116  C5 58                   CMP SEND1                              
02940  003118  F0 13                   BEQ SFOUND	;BRANCH IF YES, THEN STRING1 WAS FOUND IN STRING2
02941  00311A  C4 5C                   CPY SEND2	;NO, REACHED END OF STRING2?     
02942  00311C  F0 1D                   BEQ SNOTFP	;BRANCH IF YES, THEN STRING 1 CAN'T BE FOUND IN STRING2
02943  00311E  E6 57                   INC SBEG1	;POINT TO NEXT CHAR IN EACH STRING
02944  003120  E6 5B                   INC SBEG2
02945  003122  20 41 31                JSR CMPCHR	;MATCH?
02946  003125  F0 ED                   BEQ NXCMAT	;BRANCH IF YES, KEEP CHECKING AS LONG AS THEY MATCH
02947  003127  20 56 31                JSR POPSP	;NO, THEN RETURN TO THE POINT OF FIRST CHAR MATCH
02948  00312A  4C 08 31                JMP CHKEOS	;AND TRY AGAIN FOR FIRST CHAR MATCH
02949  00312D  20 56 31      SFOUND    JSR POPSP	;RESTORE POINTERS TO POSITION OF FIRST CHAR MATCH
02950  003130  A9 00                   LDA #$00	;STORE 0 IN HIGH ORDER
02951  003132  85 81                   STA M1                    
02952  003134  A5 5B                   LDA SBEG2	;RETURN SUBSCRIPT WHERE FIRST CHAR MATCHED
02953  003136  85 82                   STA M1+1               
02954  003138  4C E3 2E                JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02955  00313B  20 56 31      SNOTFP    JSR POPSP	;POP OFF SAVED POINTERS
02956  00313E  4C E3 2E      SNOTF     JMP FL16PJ	;FLOAT -1 AND RETURN STRING1 WAS NOT FOUND IN STRING2
02957  ;
02958  ; ROUTINES USED BY 'FSLK'
02959  ;
02960  003141  A4 57         CMPCHR    LDY SBEG1	;GET CHAR FROM STRING1
02961  003143  B1 55                   LDA (STRAD1),Y
02962  003145  A4 5B                   LDY SBEG2	;GET CHAR FROM STRING2
02963  003147  D1 59                   CMP (STRAD2),Y	;COMPARE THEM
02964  003149  60                      RTS		;RETURN WITH Z=1 IF THEY ARE THE SAME
02965  ;
02966  00314A  98            PUSHSP    TYA		;PRESERVE Y REGISTER
02967  00314B  48                      PHA          
02968  00314C  A2 55                   LDX #STRAD1	;SAVE STRING POINTERS ON STACK
02969  00314E  A0 08                   LDY #$08
02970  003150  20 6B 28                JSR PUSHB0
02971  003153  68                      PLA		;RESTORE Y REGISTER
02972  003154  A8                      TAY
02973  003155  60                      RTS		;AND RETURN
02974  ;
02975  003156  98            POPSP     TYA		;PRESERVE Y REGISTER
02976  003157  48                      PHA
02977  003158  A2 5C                   LDX #STRAD1+7	;RESTORE STRING POINTERS
02978  00315A  A0 08                   LDY #$08
02979  00315C  20 5B 28                JSR POPB0
02980  00315F  68                      PLA		;RESTORE Y REGISTER
02981  003160  A8                      TAY
02982  003161  60                      RTS		;AND RETURN
02983  ;
02984  ;            'FSBR' SINGLE VALUED SUBROUTINE CALL
02985  ;
02986  003162  20 DF 25      FSBR      JSR GETLN1	;FINISH EVALUATING GROUP OR LINE TO "DO"
02987  003165  08                      PHP		;SAVE STATUS FLAGS ON STACK
02988  003166  A9 30                   LDA #$30	;GET CODE NAME FOR VARIABLE '&0'
02989  003168  85 3D                   STA VCHAR	;SAVE AS VARIABLE NAME TO LOOK FOR
02990  00316A  A9 00                   LDA #$00	;ALSO SET SUBSCRIPT TO ZERO
02991  00316C  85 39                   STA VSUB
02992  00316E  85 3A                   STA VSUB+1
02993  003170  85 3B                   STA STRSWT	;MAKE SURE STRING VARIABLE FLAG IS OFF
02994  003172  20 1C 28                JSR PUSHJ	;CALL 'FNDVAR' TO LOCATE '&0(0)'
02995            .WORD FNDVAR
02996  003177  20 29 32                JSR SWAP	;PUT CURRENT VALUE OF '&0' INTO FAC2
02997  00317A  20 BB 2C                JSR PUSHIV	;SAVE IT'S VALUE AND ADDR ON STACK
02998  00317D  A5 2B                   LDA CHAR	;GET TERMINATOR
02999  00317F  C9 2C                   CMP #$2C	;',' IS THERE ANOTHER ARGUMENT
03000  003181  F0 02                   BEQ FSBR1	;BRANCH IF YES, PRESS ON
03001  003183  00                      BRK		;NO, TRAP
03002            .BYTE ARGM	;?ARGUMENT MISSING IN FUNCTION
03003  003185  68            FSBR1     PLA		;GET FLAGS FROM 'GETLN' INTO ACCUMULATOR
03004  003186  20 31 28                JSR PUSHA	;SAVE ON STACK
03005  003189  A2 2C                   LDX #GRPNO	;SAVE LINE OR GROUP TO 'DO'
03006  00318B  20 69 28                JSR PUSHB2
03007  00318E  20 1C 28                JSR PUSHJ	;MOVE PAST COMMA, EVALUATE NEXT ARGUMENT
03008            .WORD EVALM1  
03009  003193  A2 2D                   LDX #LINENO	;GET LINE OR GROUP TO 'DO' BACK
03010  003195  20 59 28                JSR POPB2               
03011  003198  20 3F 28                JSR POPA	;GET 'GETLN'FLAGS BACK
03012  00319B  48                      PHA		;SAVE ON STACK FOR LATER 
03013  00319C  20 C3 2C                JSR POPIV	;GET VALUE OF '&0' AND POINTER TO IT
03014  00319F  20 BB 2C                JSR PUSHIV	;SAVE FOR LATER (VALUE IS IN FAC2)
03015  0031A2  20 A1 2C                JSR PUTVAR	;NOW SET '&0' TO ARG VALUE (IN FAC1)
03016  
03017  ; SamCoVT - These next 4 instructions do not appear to be in the original .PTP version          
03018  ;          LDA INSW	;SAVE WHERE INPUT IS COMING FROM
03019  ;          JSR PUSHA	;(PROGRAM OR INPUT DEVICE)
03020  ;          LDA #$00	;AND FORCE IT TO BE PROGRAM
03021  ;          STA INSW          
03022  
03023  0031A5  68                      PLA		;GET STATUS FLAGS RETURNED BY 'GETLN'
03024  0031A6  AA                      TAX		;SAVE IN X REGISTER
03025  0031A7  20 1C 28                JSR PUSHJ	;NOW PERFORM THE 'DO' OF THE LINE OR GROUP
03026            .WORD DO1
03027  0031AC  20 C3 2C                JSR POPIV	;RESTORE WHERE INPUT IS COMMING FROM
03028                   ;AND OLD VALUE IS IN FAC2
03029  0031AF  20 AE 2C                JSR FETVAR	;GET CURRENT VALUE IN FAC1
03030  0031B2  20 29 32                JSR SWAP	;OLD VALUE IN FAC1, CURRENT VALUE IN FAC2
03031  0031B5  20 A1 2C                JSR PUTVAR	;REPLACE OLD VALUE OF '&0' BEFORE CALL
03032  0031B8  20 29 32                JSR SWAP	;GET CURRENT VALUE OF '&0' INTO FAC1
03033  0031BB  4C 14 2E                JMP FPOPJ	;RETURN IT AS THE VALUE OF THE 'FSBR'
03034  ;
03035  ;          "FRAN" RANDOM NUMBER GENERATOR, 
03036  ;          RETURNS A FRACTION BETWEEN 0.00 AND 1.00
03037  ;
03038  0031BE  20 93 2F      FRAN      JSR INTGER	;INTEGRIZE ARGUMENT
03039  0031C1  F0 0F                   BEQ FRANC	;BRANCH IF =0, RETURN NEXT RANDOM NUMBER
03040  0031C3  10 04                   BPL FRSET	;BRANCH IF >0, SET TO REPEATABILITY
03041  0031C5  A5 76                   LDA HASH	;GET THE RANDOM NUMBER HASH VALUE
03042  0031C7  D0 02                   BNE FRNINI	;AND RANDOMITE
03043  0031C9  A9 55         FRSET     LDA #$55	;SET TO ALTERNATING ZEROS AND ONES
03044  0031CB  A2 02         FRNINI    LDX #$02	;SETUP LOOP COUNTER
03045  0031CD  95 77         FRNILP    STA SEED,X	;STORE IN SEED
03046  0031CF  CA                      DEX	;POINT TO NEXT
03047  0031D0  10 FB                   BPL FRNILP	;AND LOOP TILL DONE
03048  0031D2  A9 7F         FRANC     LDA #$7F	;SET EXPONENT OF FAC1
03049  0031D4  85 80                   STA X1
03050  0031D6  18                      CLC		;ADD K TO SEED
03051  0031D7  A5 77                   LDA SEED
03052  0031D9  69 B1                   ADC #$B1
03053  0031DB  85 83                   STA M1+2	;PUT RESULT IN LOW ORDER
03054  0031DD  85 77                   STA SEED	;ALSO THIS PART IN SEED
03055  0031DF  A5 78                   LDA SEED+1
03056  0031E1  69 0C                   ADC #$0C
03057  0031E3  85 82                   STA M1+1	;INTO MIDDLE ORDER
03058  0031E5  A5 79                   LDA SEED+2
03059  0031E7  69 1B                   ADC #$1B
03060  0031E9  29 7F                   AND #$7F	;KILL SIGN BIT
03061  0031EB  85 81                   STA M1
03062  0031ED  A5 83                   LDA M1+2
03063  0031EF  0A                      ASL  	;2^17
03064  0031F0  18                      CLC
03065  0031F1  65 83                   ADC M1+2	;2^16
03066  0031F3  18                      CLC
03067  0031F4  65 81                   ADC M1	;PLUS HIGH ORDER
03068  0031F6  85 79                   STA SEED+2	;NEW SEED
03069  0031F8  18                      CLC
03070  0031F9  A5 83                   LDA M1+2	;2^8 ADDED
03071  0031FB  65 82                   ADC M1+1
03072  0031FD  85 78                   STA SEED+1
03073  0031FF  A5 82                   LDA M1+1
03074  003201  65 79                   ADC SEED+2
03075  003203  85 79                   STA SEED+2	;SEED NOW READY FOR NEXT TIME
03076  003205  A9 00                   LDA #$00	;GET A ZERO
03077  003207  20 55 32                JSR NORM0	;NORMALIZE THE FRACTION
03078  00320A  4C 14 2E                JMP FPOPJ	;* PJMP * and return
03079  
03080  
03081  ; *** BEGIN SamCoVT SECTION
03082     
03083  ;
03084  ;            CENTRAL ROUTINES
03085  ;
03086  00320D  18            ADD       CLC
03087  00320E  A2 03                   LDX #$03	;*INDEX FOR 4 BYTE ADD
03088  003210  B5 81         ADD1      LDA M1,X               
03089  003212  75 7C                   ADC M2,X	;ADD NEXT BYTE
03090  003214  95 81                   STA M1,X
03091  003216  CA                      DEX		;TO NEXT MORE SIG BYTE
03092  003217  10 F7                   BPL ADD1	;DO ALL THREE
03093  003219  60                      RTS
03094  
03095  00321A  06 7A         MD1       ASL SIGN	;CLEAR LSB OF SIGN
03096  00321C  20 1F 32                JSR ABSWAP	;ABS VAL M1, THEN SWAP
03097  00321F  24 81         ABSWAP    BIT M1	;M1 NEG?
03098  003221  10 05                   BPL ABSWP1	;NO JUST SWAP
03099  003223  20 B8 32                JSR FCOMPL	;YES, NEGATE IT
03100  003226  E6 7A                   INC SIGN	;COMPLEMENT SIGN
03101  003228  38            ABSWP1    SEC		;FOR RETURN TO MUL/DIV
03102  ;
03103  ; SWAP FAC1 WITH FAC2
03104  ;
03105  003229  A2 05         SWAP      LDX #$05	;*FIVE BYTES TOTAL
03106  00322B  94 84         SWAP1     STY EM1,X               
03107  00322D  B5 7F                   LDA X1M1,X	;SWAP A BYTE OF FAC1 WITH
03108  00322F  B4 7A                   LDY SIGN,X	;FAC2 AND LEAVE COPY OF
03109  			;$7A is X2M1 and SIGN. 
03110  			;used SIGN, because it is defined!!!
03111  003231  94 7F                   STY X1M1,X	;M1 IN E, E+3 USED
03112  003233  95 7A                   STA SIGN,X
03113  003235  CA                      DEX		;NEXT BYTE
03114  003236  D0 F3                   BNE SWAP1	;UNTIL DONE
03115  003238  60                      RTS
03116  ;
03117  ; ROUTINE TO FLOAT 23 BITS OF MANTISSA
03118  ;
03119  003239  A9 96         FLOAT     LDA #FHALF	;SET EXPONENT TO 22 DECIMAL
03120  00323B  85 80                   STA X1                    
03121  00323D  A9 00                   LDA #$00	;ZERO INTO LOW BYTES
03122  00323F  F0 14                   BEQ NORM0	;* PBE Q* NORMALIZE IT AND RETURN
03123  ;
03124  ; DO A FAST FLOAT OF A 1-BYTE QUANTITY 
03125  ;
03126  003241  85 81         FLT8      STA M1	;STORE THE BYTE
03127  003243  A9 86                   LDA #$86	;ASSUME ALREADY SHIFTED 8 BLACES
03128  003245  85 80                   STA X1                    
03129  003247  A9 00                   LDA #$00	;GET A ZERO
03130  003249  85 82                   STA M1+1	;ZERO OUT BYTE OF MANTISSA
03131  00324B  F0 06                   BEQ FLOATC	;*P BEQ * CLEAR THIRD BYTE, NORMALIZE AND RETURN
03132  ;
03133  ; FLOAT A 16-BUT INTEGER IN M1 & M1+1 TO FAC1
03134  ; FAC2 UNAFFECTED
03135  ;
03136  00324D  A9 8E         FLT16     LDA #$8E
03137  00324F  85 80                   STA X1	;SET EXP TO 14 DEC
03138  003251  A9 00                   LDA #$00	;CLEAR LOW BYTES
03139  003253  85 83         FLOATC    STA M1+2
03140  003255  85 84         NORM0     STA M1+3	;*
03141  			;* PFALL * NORMALIZE IT AND RETURN
03142  003257  20 1E 34      NORM      JSR CHKZER	;* IS MANTISSA ZERO?
03143  00325A  D0 0F                   BNE NORML	;BRANCH IF NOT, THEN DO THE NORMALIZE SHIFTING
03144  00325C  A9 80                   LDA #$80	;YES, THEN AVOID MUCH SHIFTING BY SETTING
03145  00325E  85 80                   STA X1	;THE EXPONENT
03146  003260  60                      RTS		;AND RETURN
03147  003261  C6 80         NORM1     DEC X1
03148  003263  06 84                   ASL M1+3	;* SHIFT 4 BYTES LEFT
03149  003265  26 83                   ROL M1+2
03150  003267  26 82                   ROL M1+1
03151  003269  26 81                   ROL M1
03152  00326B  A5 81         NORML     LDA M1	;NORMALISED CHECK
03153  00326D  0A                      ASL 		;UPPER TWO BYTES UNEQUAL?
03154  00326E  45 81                   EOR M1
03155  003270  10 EF                   BPL NORM1	;NO, LOOP TILL THEY ARE
03156  003272  60            RTSN      RTS
03157  ;
03158  ;FAC2-FAC1 INTO FAC1
03159  ;
03160  003273  20 B8 32      FSUB      JSR FCOMPL	;WILL CLEAR CARRY UNLESS ZERO
03161  003276  20 86 32      SWPALG    JSR ALGNSW	;RIGHT SHIFT M1 OR SWAP ON CARRY
03162  ;
03163  ;FAC1 + FAC2 INTO FAC1
03164  ;
03165  003279  A5 7B         FADD      LDA X2                    
03166  00327B  C5 80                   CMP X1	;EXPONENTS EQUAL?
03167  00327D  D0 F7                   BNE SWPALG	;IF NOT SWAP OR ALIGN
03168  00327F  20 0D 32                JSR ADD	;ADD MANTISSAS
03169  003282  50 D3         ADDEND    BVC NORM	;IF COOL, NORMALIZE
03170  003284  70 05                   BVS RTLOG	;DV: SHIFT RIGHT-CARRY IS COOL
03171  			;SWAP IF CARRY CLEAR, ELSE SHIFT RIGHT ARITHMETICALLY
03172  003286  90 A1         ALGNSW    BCC SWAP
03173  003288  A5 81         RTAR      LDA M1	;SIGN INTO CARRY
03174  00328A  0A                      ASL 		;ARITH SHIFT
03175  00328B  E6 80         RTLOG     INC X1	;COMPENSATE FOR SHIFT
03176  00328D  F0 39                   BEQ OVFL	;EXP OUT OF RANGE
03177  00328F  A2 F8         RTLOG1    LDX #$F8	;* INDEX FOR 8 BYTE RT SHIFT
03178  003291  A9 80         ROR1      LDA #$80
03179  003293  B0 01                   BCS ROR2
03180  003295  0A                      ASL 
03181  003296  56 89         ROR2      LSR E+4,X	;*FAKE RORX E+4
03182  003298  15 89                   ORA E+4,X
03183  00329A  95 89                   STA E+4,X
03184  00329C  E8                      INX		;NEXT BYTE
03185  00329D  D0 F2                   BNE ROR1	;UNTIL DONE
03186  00329F  60                      RTS
03187  ;
03188  ;  FAC1 * FAC2 INTO FAC1
03189  ;
03190  0032A0  20 1A 32      FMUL      JSR MD1	;ABS VAL OF M1,M2
03191  0032A3  65 80                   ADC X1	;ADD EXPONENTS
03192  0032A5  20 FE 32                JSR MD2	;CHECK & PREP FOR NUL
03193  0032A8  18                      CLC
03194  0032A9  20 8F 32      MUL1      JSR RTLOG1	;SHIFT PROD AND MFYR(?) RIGHT
03195  0032AC  90 03                   BCC MUL2	;SKIP PARTIAL PROD
03196  0032AE  20 0D 32                JSR ADD	;ADD IN MCAND
03197  0032B1  88            MUL2      DEY		;NEXT ITERATION
03198  0032B2  10 F5                   BPL MUL1	;LOOP UNTIL DONE
03199  0032B4  46 7A         MDEND     LSR SIGN	;SIGN EVEN OR ODD?
03200  0032B6  90 9F         NORMX     BCC NORM	;IF EVEN NORMALIZE, ELSE COMPARE
03201  0032B8  38            FCOMPL    SEC                    
03202  0032B9  A2 04                   LDX #$04	;*4 BYTE SUBTRACT
03203  0032BB  A9 00         COMPL1    LDA #$00
03204  0032BD  F5 80                   SBC X1,X
03205  0032BF  95 80                   STA X1,X
03206  0032C1  CA                      DEX		;TO MORE SIG BYTE
03207  0032C2  D0 F7                   BNE COMPL1	;UNTIL DONE
03208  0032C4  F0 BC                   BEQ ADDEND	;FIX UP
03209  ;                              
03210  0032C6  10 46         OVCHK     BPL MD3	;IF POSITIVE EXPONENT NO CVF     
03211  0032C8  00            OVFL      BRK		;TRAP
03212            .BYTE FOVFL	;FLOATING POINT OVERFLOW
03213  ;
03214  ; DIVIDE FAC2 BY FAC1 INTO FAC1
03215  ;
03216  0032CA  20 1A 32      FDIV      JSR MD1	;ABS VALUE OF M1, M2
03217  0032CD  E5 80                   SBC X1	;SUBTRACT EXPONENTS
03218  0032CF  20 FE 32                JSR MD2	;SAVE AS RES EXP
03219  0032D2  38            DIV1      SEC
03220  0032D3  A2 03                   LDX #$03	;* FOR 4 BYTES
03221  0032D5  B5 7C         DIV2      LDA M2,X               
03222  0032D7  F5 85                   SBC E,X	;SUBTRACT BYTE OF E FROM M2
03223  0032D9  48                      PHA     
03224  0032DA  CA                      DEX		;NEXT MORE SIG BYTE
03225  0032DB  10 F8                   BPL DIV2	;UNTIL DONE
03226  0032DD  A2 FC                   LDX #$FC	;* FOR 4 BYTE COND MOVE
03227  0032DF  68            DIV3      PLA		;DIFF WAS ON STACK
03228  0032E0  90 02                   BCC DIV4	;IF M2<E DON'T RESTORE
03229  0032E2  95 80                   STA X1,X	;*
03230  0032E4  E8            DIV4      INX		;NEXT LESS SIG BYTE
03231  0032E5  D0 F8                   BNE DIV3	;UNTIL DONE
03232  0032E7  26 84                   ROL M1+3	;*
03233  0032E9  26 83                   ROL M1+2               
03234  0032EB  26 82                   ROL M1+1	;ROLL QUOTIENT LEFT
03235  0032ED  26 81                   ROL M1	;CARRY INTO LSB
03236  0032EF  06 7F                   ASL M2+3	;*
03237  0032F1  26 7E                   ROL M2+2
03238  0032F3  26 7D                   ROL M2+1	;DIVIDEND LEFT
03239  0032F5  26 7C                   ROL M2
03240  0032F7  B0 CF                   BCS OVFL	;OVF IS DUE TO UNNORM DIVISOR
03241  0032F9  88                      DEY		;NEXT ITERATION
03242  0032FA  D0 D6                   BNE DIV1	;UNTIL DONE (23 ITERATIONS)
03243  0032FC  F0 B6                   BEQ MDEND	;NORM QUOTIENT AND FIX SIGN
03244  0032FE  86 84         MD2       STX M1+3	;*
03245  003300  86 83                   STX M1+2
03246  003302  86 82                   STX M1+1	;CLEAR M1
03247  003304  86 81                   STX M1                    
03248  003306  B0 BE                   BCS OVCHK	;CHECK FOR OVFL
03249  003308  30 04                   BMI MD3	;IF NEG NO UNDERFLOW
03250  00330A  68                      PLA		;POP ONE RETURN
03251  00330B  68                      PLA
03252  00330C  90 A8                   BCC NORMX	;CLEAR X1 AND RETURN
03253  00330E  49 80         MD3       EOR #$80	;COMPL. SIGN OF EXPONENT
03254  003310  85 80                   STA X1                    
03255  003312  A0 1F                   LDY #$1F	;COUNT FOR 31 (/), 32 (*) ITERATIONS
03256  003314  60                      RTS
03257  ;
03258  ; FAC1 TO 23 BIT SIGNED INTEGER IN M1 (HIGH), M1+1 (MIDDLE), M1+2 (LOW) 
03259  ;
03260  003315  20 88 32      FIX1      JSR RTAR	;SHIFT MANTISSA, INC EXPONENT
03261  003318  A5 80         FIX       LDA X1	;CHECK EXP
03262  00331A  C9 96                   CMP #FHALF	;IS EXP #22?
03263  00331C  D0 F7                   BNE FIX1	;NO, SHIFT MORE
03264  00331E  60                      RTS	;DONE
03265  ;
03266  ;            FLOATING POINT OUTPUT ROUTINE
03267  ;
03268  00331F  A5 81         FPRNT     LDA M1	;SAVE THE SIGN OF THE NUMBER
03269  003321  85 8A                   STA SIGNP	;FOR LATER REFERENCE
03270  003323  20 F7 33                JSR ABSF1	;DEAL ONLY WITH ABSOLUTE VALUE
03271  003326  20 1E 34                JSR CHKZER	;IS NUMBER = 0?
03272  003329  D0 05                   BNE FPR0	;BRANCH IF NOT, THEN TRY TO DIVIDE DOWN
03273  00332B  85 8D                   STA K		;YES, SOME FLAVOR OF ZERO. INDICATE THAT WE
03274  00332D  48                      PHA		;DID NOT HAVE TO DIVIDE AS ALREADY <1
03275  00332E  F0 43                   BEQ FPR4A	;AND PUNT DIVIDE DOWN AND ROUNDING CODE
03276  003330  A5 80         FPR0      LDA X1	;GET THE EXPONENT
03277  003332  48                      PHA		;SAVE FOR LATER REFERENCE
03278  003333  A9 00                   LDA #$00	;ZERO COUNTER WHICH COUNTS HOW MANY TIMES
03279  003335  85 8D                   STA K		;WE HAD TO DIVIDE TO GET NUMBER <1
03280  003337  24 80         FPR1      BIT X1	;IS NUMBER <1?
03281  003339  10 07                   BPL FPR2	;BRANCH IF YES
03282  00333B  20 11 34                JSR DIV10	;NO, THEN DIVIDE BY 10
03283  00333E  E6 8D                   INC K		;COUNT THE FACT WE DID
03284  003340  10 F5                   BPL FPR1	;AND CHECK AGAIN
03285  003342  20 79 28      FPR2      JSR PHFAC1	;SAVE NUMBER (NOW <1) ON STACK
03286  003345  A2 96                   LDX #FHALF	;GET THE CONSTANT .5
03287  003347  A0 80                   LDY #X1	;INTO FAC1
03288  003349  20 FF 33                JSR MOVXY
03289  00334C  18                      CLC
03290  00334D  A5 8D                   LDA K		;ROUNDING FACTOR IS .5*10^-(K+N)
03291  00334F  65 90                   ADC N
03292  003351  85 8E                   STA L
03293  003353  F0 0F                   BEQ FPR4	;BRANCH IF WE NEED .5*10^0
03294  003355  A9 09                   LDA #$09	;* IS FACTOR BEYOND OUR PRECISSION?
03295  003357  C5 8E                   CMP L
03296  003359  10 02                   BPL FPR3	;BRANCH IF NOT, THEN ROUNDING FACTOR IS OK
03297  00335B  85 8E                   STA L		;YES, THEN APPLY ROUNDING TO LEAST SIG FIG
03298  00335D  20 11 34      FPR3      JSR DIV10	;NOW SHIFT .5 INTO PROPER POSITION
03299  003360  C6 8E                   DEC L
03300  003362  D0 F9                   BNE FPR3
03301  003364  20 9A 28      FPR4      JSR PLFAC2	;GET NUMBER INTO FAC2
03302  003367  20 79 32                JSR FADD	;ADD THE ROUNDING FACTOR
03303  00336A  24 80                   BIT X1	;IS IT STILL <1?
03304  00336C  10 05                   BPL FPR4A	;BRANCH IF IT IS
03305  ;
03306  ;original ProgExch/6502Grp code has more lines here:
03307  ;          pla          ;no then get original exponent
03308  ;          bmi fpr4a    ;branch if original number >1 do nothing
03309  ;          lda x1       ;we gained a sig fig in rounding, get new exp
03310  ;fpr41     pha          ;save exponent for later
03311  ;
03312  00336E  20 11 34                JSR DIV10	;SCALE NUMBER BACK DOWN
03313  003371  E6 8D                   INC K		;AND INDICATE WE HAD TO
03314  003373  38            FPR4A     SEC
03315  003374  A5 8F                   LDA M		;NOW CONSULATE NUMBER OF LEADING BLANKS NEEDED
03316  003376  E5 8D                   SBC K
03317  003378  85 8E                   STA L		;INTO L
03318  00337A  68                      PLA		;GET EXPONENT OF ORIGINAL NUMBER BACK
03319  00337B  48                      PHA		;SAVE AGAIN FOR LATER
03320  00337C  30 02                   BMI FPR4B	;BRANCH IF ORIGINAL NUMBER IS <1?
03321  00337E  C6 8E                   DEC L		;IT WAS <1. LEAVE ROOM FOR LEADINF 0
03322  003380  24 8A         FPR4B     BIT SIGNP	;WAS NUMBER NEGATIVE
03323  003382  10 02                   BPL FPR5	;BRANCH IF NOT
03324  003384  C6 8E                   DEC L		;YES, THEN LEAVE ROOM FOR A MINUS SIGN
03325  003386  A5 8E         FPR5      LDA L		;ANY BLANKS TO OUTPUT?
03326  003388  30 09                   BMI FPR7	;BRANCH IF NOT
03327  00338A  F0 07                   BEQ FPR7	;BRANCH IF NOT
03328  00338C  20 00 29      FPR6      JSR PSPACE	;OUTPUT A BLANK
03329  00338F  C6 8E                   DEC L		;COUNT IT
03330  003391  D0 F9                   BNE FPR6	;AND LOOP TILL ALL HAVE BENN OUTPUT
03331  003393  24 8A         FPR7      BIT SIGNP	;WAS NUMBER NEGATIVE?
03332  003395  10 05                   BPL FPR7A	;BRANCH IF NOT
03333  003397  A9 2D                   LDA #$2D	;YES, OUTPUT A LEADING "-"
03334  003399  20 02 29                JSR PRINTC	;AND FALL INTO NEXT PAGE
03335  00339C  68            FPR7A     PLA		;GET EXPONENT OF THE ORIGINAL NUM BACK AGAIN
03336  00339D  30 03                   BMI FPR8	;BRANCH IF NOT <1
03337  00339F  20 C8 33                JSR PZERO	;YES, THEN GIVE A LEADING ZERO
03338  			;(PEOPLE LIKE IT!)
03339  			;(IT'S ALSO A PAIN TO CHECK FOR!)
03340  ;                                        
03341  ; NOW FOR THE MEAT OF IT
03342  ;
03343  0033A2  A9 09         FPR8      LDA #$09	;* GET MAX NUMBER OF SIG FIGS
03344  0033A4  85 8E                   STA L		;INTO L
03345  0033A6  A5 8D         FPR9      LDA K		;ANY OUTPUT BEFORE DECIMAL?
03346  0033A8  F0 07                   BEQ FPR11	;BRANCH IF NO MORE
03347  0033AA  20 C4 33      FPR10     JSR MDO	;OUTPUT A DIGIT BEFORE DECIMAL
03348  0033AD  C6 8D                   DEC K
03349  0033AF  D0 F9                   BNE FPR10	;AND LOOK TILL ALL DONE
03350  0033B1  A5 90         FPR11     LDA N		;GET NUMBER AFTER DECIMAL POINT
03351  0033B3  85 8D                   STA K		;INTO K
03352  0033B5  F0 0C                   BEQ FPRET	;BRANCH IF NONE TO OUTPUT
03353  0033B7  A9 2E                   LDA #$2E	;THERE ARE SOME TO OUTPUT,
03354  0033B9  20 02 29                JSR PRINTC	;PRINT THE DECIMAL POINT
03355  0033BC  20 C4 33      FPR12     JSR MDO	;OUTPUT A DIGIT AFTER DECIMAL
03356  0033BF  C6 8D                   DEC K		;AND LOOP
03357  0033C1  D0 F9                   BNE FPR12	;TILL ALL OUTPUT
03358  0033C3  60            FPRET     RTS		;RETURN FROM 'FPRNT' FAC1 IS DESTROYED!
03359  ;
03360  ; MPY BY 10, PRINT INTEGER AND SUBTRACT IT
03361  ;
03362  0033C4  C6 8E         MDO       DEC L		;HAVE WE OUTPUT ALL DIGITS OF SIGNIFICANCE?
03363  0033C6  10 05                   BPL MDO1	;BRANCH IF NOT, OUTPUT THIS ONE
03364  0033C8  A9 30         PZERO     LDA #$30	;YES, THEN OUTPUT A ZERO
03365  0033CA  4C 02 29                JMP PRINTC	;* PJMP * AND RETURN
03366  0033CD  A2 91         MDO1      LDX #FTEN               
03367  0033CF  A0 7B                   LDY #X2
03368  0033D1  20 FF 33                JSR MOVXY
03369  0033D4  20 A0 32                JSR FMUL
03370  0033D7  A2 80         FDONE     LDX #X1	;SAVE FAC1
03371  0033D9  A0 A0                   LDY #T
03372  0033DB  20 FF 33                JSR MOVXY
03373  0033DE  20 18 33                JSR FIX
03374  0033E1  A5 83                   LDA M1+2	;MAKE ASCII
03375  0033E3  29 0F                   AND #$0F
03376  0033E5  09 30                   ORA #$30
03377  0033E7  20 02 29                JSR PRINTC
03378  0033EA  20 39 32                JSR FLOAT	;NOW SUBTRACT IT
03379  0033ED  A2 A0                   LDX #T		;RESTORE TO FAC2
03380  0033EF  A0 7B                   LDY #X2
03381  0033F1  20 FF 33                JSR MOVXY
03382  0033F4  4C 73 32                JMP FSUB	;PJUMP
03383  
03384  ;
03385  ;   UTILITIES FOR FPRNT
03386  ;
03387  0033F7  24 81         ABSF1     BIT M1
03388  0033F9  10 03                   BPL ABSFE
03389  0033FB  20 B8 32                JSR FCOMPL
03390  0033FE  60            ABSFE     RTS
03391  0033FF  CA            MOVXY     DEX
03392  003400  8E 0A 34                STX MOV1+1
03393  003403  88                      DEY
03394  003404  8C 0C 34                STY MOV2+1
03395  003407  A2 05                   LDX #$05	;*
03396  003409  B5 00         MOV1      LDA $00,X
03397  00340B  95 00         MOV2      STA $00,X
03398  00340D  CA                      DEX
03399  00340E  D0 F9                   BNE MOV1
03400  003410  60                      RTS
03401  ;
03402  003411  20 29 32      DIV10     JSR SWAP
03403  003414  A2 91                   LDX #FTEN
03404  003416  A0 80                   LDY #X1
03405  003418  20 FF 33                JSR MOVXY
03406  00341B  4C CA 32                JMP FDIV	;*PJMP*
03407  ;
03408  00341E  A5 81         CHKZER    LDA M1	;GET HIGH ORDER MANTISSA
03409  003420  05 82                   ORA M1+1	;'OR' ALL BYTES OF MANTISSA TOGETHER
03410  003422  05 83                   ORA M1+2
03411  003424  05 84                   ORA M1+3	;*
03412  003426  60                      RTS		;RETURN WITH Z=1 IF MANTISSA IS =0.
03413  ;
03414  ;   'FLOATING POINT INPUT ROUTINE'
03415  ;
03416  003427  A9 00         FINP      LDA #$00
03417  003429  85 8A                   STA SIGNP	;SET SIGN +
03418  00342B  85 8B                   STA DPFLG	;RESET DP FLAG
03419  00342D  85 8C                   STA GOTFLG	;NO INPUT YET
03420  00342F  85 8D                   STA K		;NO DIGITS AFTER DECIMAL POINT
03421  003431  85 7B                   STA X2	;ZERO RESULT
03422  003433  85 7C                   STA M2
03423  003435  85 7D                   STA M2+1
03424  003437  85 7E                   STA M2+2
03425  003439  85 7F                   STA M2+3	;*
03426  00343B  A5 2B                   LDA CHAR	;GET CHARACTER
03427  00343D  C9 2B                   CMP #$2B	;IGNORE +'S
03428  00343F  F0 06                   BEQ FINP3               
03429  003441  C9 2D                   CMP #$2D	;'-' FLAG IF NEGATIVE
03430  003443  D0 05                   BNE FINP2
03431  003445  E6 8A                   INC SIGNP
03432  003447  20 92 29      FINP3     JSR GETC	;ANOTHER CHAR
03433  00344A  C9 30         FINP2     CMP #$30	;'0' IS IT A DIGIT?
03434  00344C  90 24                   BCC FINP4	;NO
03435  00344E  C9 3A                   CMP #$3A	;':' MAYBE...
03436  003450  B0 20                   BCS FINP4	;NO
03437  003452  A2 91                   LDX #FTEN
03438  003454  A0 80                   LDY #X1
03439  003456  20 FF 33                JSR MOVXY	;FAC2*10.0=FAC1
03440  003459  20 A0 32                JSR FMUL
03441  00345C  20 29 32                JSR SWAP	;INTO FAC2
03442  00345F  E6 8C                   INC GOTFLG	;YES, WE HAVE INPUT
03443  003461  A5 2B                   LDA CHAR
03444  003463  29 0F                   AND #$0F	;MAKE NUMERIC
03445  003465  20 41 32                JSR FLT8	;AND FLOAT IT
03446  003468  20 79 32                JSR FADD	;ADD TO PARTIAL RESULT
03447  00346B  20 29 32                JSR SWAP	;BACK INTO FAC2
03448  00346E  E6 8D                   INC K		;COUNT DIGITS AFTER DECIMAL POINT
03449  003470  D0 D5                   BNE FINP3	;GET MORE
03450  003472  C9 2E         FINP4     CMP #$2E	;DECIMAL POINT?
03451  003474  D0 0C                   BNE FINP5	;NO, END OF #
03452  003476  A5 8B                   LDA DPFLG	;YES, ALREADY GOT ONE?
03453  003478  D0 08                   BNE FINP5	;THEN END OF #
03454  00347A  E6 8B                   INC DPFLG	;ELSE FLAG GOT ONE
03455  00347C  A9 00                   LDA #$00
03456  00347E  85 8D                   STA K		;RESET K
03457  003480  F0 C5                   BEQ FINP3	;AND GET FRACTION
03458  ;
03459  ; HERE ON END OF NUMBER
03460  ;
03461  003482  20 29 32      FINP5     JSR SWAP	;RESULT TO FAC1
03462  003485  A5 8B                   LDA DPFLG	;ANY DECIMAL POINTS?
03463  003487  F0 0B                   BEQ FINP6	;NO, ITS OK
03464  003489  A5 8D         FINP7     LDA K		;ELSE ADJUST
03465  00348B  F0 07                   BEQ FINP6	;ADJUST DONE
03466  00348D  20 11 34                JSR DIV10	;RESULT/10
03467  003490  C6 8D                   DEC K		;K TIMES
03468  003492  D0 F5                   BNE FINP7
03469  003494  A5 8A         FINP6     LDA SIGNP	;NOW ADD SIGN
03470  003496  F0 03                   BEQ FINP8	;WAS POS
03471  003498  20 B8 32                JSR FCOMPL	;WAS NEG
03472  00349B  4C 57 32      FINP8     JMP NORM	;PJUMP TO NORMALIZE
03473  ;
03474  ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
03475  ;
03476  ;     Here begins (again) code restoration by dhh
03477  ;
03478  ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
03479  ;
03480  ; from here, the Aresco version of V3D code (TTY) completely differs from
03481  ; the ProgramExchange/6502 Group TIM-monitor code upon which it is based.
03482  ; PE code occupies $24A6 to $24D0 (here $349E to $34E7), and seems to be
03483  ; related to video terminal output.  What follows here are KIM-1-specific
03484  ; initialization and I/O routines from the Aresco version of V3D.  -dhh 
03485  ;
03486  00349E  A9 E0         CONINI    LDA #$E0	; init BRK vector as $2CE0
03487  0034A0  8D FE 17                STA $17FE
03488  0034A3  A9 2C                   LDA #$2C
03489  0034A5  8D FF 17                STA $17FF
03490  0034A8  18                      CLC
03491  0034A9  60                      RTS
03492            ; This code has KIM-1 I/O patch from focal user notes applied
03493  0034AA  84 A5         TVOUT     STY SAVYR     ; save "Y"
03494  0034AC  20 A0 1E                JSR $1EA0     ; TTY OUTCH in KIM-1 ROM
03495  0034AF  A4 A5                   LDY SAVYR     ; restore "Y"
03496  0034B1  18                      CLC
03497  0034B2  60                      RTS
03498  0034B3  E6 76         KEYIN     INC HASH      ; bump random seed
03499  0034B5  2C 40 17                BIT $1740     ; test input port ((R)RIOT I/O register A)
03500  0034B8  30 F9                   BMI KEYIN     ; loop 'til start bit
03501  0034BA  A5 6B                   LDA ECHFLG    ; get echo flag
03502  0034BC  D0 05                   BNE NOECH     ; branch for no echo
03503  0034BE  20 5A 1E                JSR $1E5A     ; get character with echo (GETCH in KIM-1 ROM)
03504  0034C1  18                      CLC
03505  0034C2  60                      RTS
03506  NOECH
03507  0034C3  AD 42 17                LDA $1742     ; get port status ((R)RIOT I/O register B)
03508  0034C6  29 FE                   AND #$FE      ; turn off bit
03509  0034C8  8D 42 17                STA $1742
03510  0034CB  20 5A 1E                JSR $1E5A     ; GETCH in KIM-1 ROM
03511  0034CE  48                      PHA           ; save character
03512  0034CF  AD 42 17                LDA $1742     ; get port status
03513  0034D2  09 01                   ORA #$01      ; turn on bit
03514  0034D4  8D 42 17                STA $1742     
03515            ; make echo a rubout
03516  0034D7  A9 00                   LDA #0        ; get a null character
03517  0034D9  20 A0 1E                JSR $1EA0     ; echo it (OUTCH in KIM-1 ROM)
03518  0034DC  68                      PLA
03519  0034DD  18                      CLC
03520  0034DE  60                      RTS          ; 
03521  ;
03522  ;  The next bytes do not appear to be used for anything.
03523  ;  Perhaps leftover from Aresco conversion of Prog/Exch
03524  ;  version for KIM-1 (???).
03525  ;
03526          .BYTE $53,$EE,$CE,$FE,$EE,$EA,$EE,$06,$FE
03527  ;          BRK
03528  ;          ???                ;01000011 'C'
03529  ;          ORA ($51),Y
03530  ;          ORA ($11),Y
03531  ;          ???                ;00010111
03532  ;          ORA ($01,X)
03533  ;          ORA ($41),Y
03534  ;          ???                ;01010011 'S'
03535  ;          ORA ($51,X)
03536  ;          EOR ($11),Y
03537  ;          ???                ;01010011 'S'
03538  ;          INC $FECE
03539  ;          INC $EEEA
03540  ;          ASL $FE
03541  ;
03542  
03543  ;     SPECIAL TERMINATOR CHAR TABLE (see P/E code at $2401)
03544  ;
03545  TRMTAB   .BYTE ' '     ; LEVEL 0 (SPACE)
03546           .BYTE '+'     ; LEVEL 1 '+'
03547           .BYTE '-'     ; LEVEL 2 '-'
03548           .BYTE '/'     ; LEVEL 3 '/'
03549           .BYTE '*'     ; LEVEL 4 '*'
03550           .BYTE '^'     ; LEVEL 5 '^'
03551           .BYTE '('     ; LEVEL 6 '('
03552           .BYTE ')'     ; LEVEL 7 ')'  (START OF DELIMITERS)
03553           .BYTE ','     ; LEVEL 8 ','
03554           .BYTE ';'     ; LEVEL 9 ';'
03555           .BYTE $0D     ; LEVEL 10 'CR'
03556           .BYTE '='     ; LEVEL 11 '=' (TERMINATOR FOR 'SET')
03557           .BYTE LINCHR  ; LEVEL 1 '_'  ('LINE-DELETE IS HERE SO
03558                         ;             'ASK' CAN ALLOW RE-TYPEIN)
03559  ;
03560  ; here TRMAX=12 is defined in the ProgExch code
03561  ;
03562  ;      THESE FUNCTION DISPATCH TABLES MAY BE PATCHED BY A USER
03563  ;      TO CALL HIS OWN FUNCTIONS.
03564  ;
03565  ;      TABLE OF 'HASH CODES' FOR FUNCTION NAMES
03566  ;
03567  FUNTAB    .BYTE HFABS     ; ABSOLUTE VALUE FUNCTION
03568            .BYTE HFOUT     ; CHARACTER OUTPUT FUNCTION
03569            .BYTE HFRAN     ; RANDOM NUMBER FUNCTION
03570            .BYTE HFINT     ; INTEGERIZE FUNCTION
03571            .BYTE HFINR     ; INTEGERIZE WITH ROUNDING FUNCTION
03572            .BYTE HFIDV     ; INPUT DEVICE FUNCTION
03573            .BYTE HFODV     ; OUTPUT DEVICE FUNCTION
03574            .BYTE HFCHR     ; CHARACTER INPUT FUNCTION
03575            .BYTE HFCUR     ; CONSOLE CURSOR ADDRESSING FUNCTION
03576            .BYTE HFECH     ; ECHO CONTROL FUNCTION
03577            .BYTE HFPIC     ; SOFTWARE PRIORITY INTERRUPT FUNCTION
03578            .BYTE HFMEM     ; MEMORY EXAMINE-DEPOSIT FUNCTION
03579            .BYTE HFINI     ; INITIALIZE INPUT DEVICE FUNCTION
03580            .BYTE HFINO     ; INITIALIZE OUTPUT DEVICE FUNCTION
03581            .BYTE HFCLI     ; CLOSE INPUT DEVICE FUNCTION
03582            .BYTE HFCLO     ; CLOSE OUTPUT DEVICE FUNCTION
03583            .BYTE HFCON     ; SET CONSOLE DEVICE FUNCTION
03584            .BYTE HFSBR     ; 'SUBROUTINE' CALL FUNCTION
03585            .BYTE HFISL     ; INITIALIZE STRING LENGTH FUNCTION
03586            .BYTE HFSTI     ; STRING INPUT FUNCTION
03587            .BYTE HFSTO     ; STRING OUTPUT FUNCTION
03588            .BYTE HFSLK     ; STRING "LOOK" FUNCTION
03589            .BYTE 0	  ; SPARE LOCS FOR HACKERS
03590            .BYTE 0
03591            .BYTE 0
03592            .BYTE 0
03593            .BYTE 0
03594            .BYTE 0          ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03595  ;
03596  ;     FUNCTION DISPATCH TABLES - HIGH BYTE
03597  ;
03598  FUNADH     .BYTE >FABS     ; FABS
03599             .BYTE >FOUT     ; FOUT
03600             .BYTE >FRAN     ; FRAN
03601             .BYTE >FINT     ; FINT
03602             .BYTE >FINR     ; FINR
03603             .BYTE >FIDV     ; FIDV
03604             .BYTE >FODV     ; FODV
03605             .BYTE >FCHR     ; FCHR
03606             .BYTE >FCUR     ; FCUR
03607             .BYTE >FECH     ; FECH
03608             .BYTE >FPIC     ; FPIC
03609             .BYTE >FMEM     ; FMEM
03610             .BYTE >FINI     ; FINI
03611             .BYTE >FINO     ; FINO
03612             .BYTE >FCLI     ; FCLI
03613             .BYTE >FCLO     ; FCLO
03614             .BYTE >FCON     ; FCON
03615             .BYTE >FSBR     ; FSBR
03616             .BYTE >FISL     ; FISL
03617             .BYTE >FSTI     ; FSTI
03618             .BYTE >FSTO     ; FSTO
03619             .BYTE >FSLK     ; FSLK
03620             .BYTE $00       ; SPACE FOR HACKERS
03621  L3528      .BYTE 0
03622             .BYTE 0
03623             .BYTE 0
03624             .BYTE 0
03625             .BYTE 0          ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03626  ;
03627  ;     FUNCTION DISPATCH TABLES - LOW ORDER ADDR BYTE
03628  ;
03629  FUNADL     .BYTE <FABS     ; FABS
03630             .BYTE <FOUT     ; FOUT
03631             .BYTE <FRAN     ; FRAN
03632             .BYTE <FINT     ; FINT
03633             .BYTE <FINR     ; FINR
03634             .BYTE <FIDV     ; FIDV
03635             .BYTE <FODV     ; FODV
03636             .BYTE <FCHR     ; FCHR
03637             .BYTE <FCUR     ; FCUR
03638             .BYTE <FECH     ; FECH
03639             .BYTE <FPIC     ; FPIC
03640             .BYTE <FMEM     ; FMEM
03641             .BYTE <FINI     ; FINI
03642             .BYTE <FINO     ; FINO
03643             .BYTE <FCLI     ; FCLI
03644             .BYTE <FCLO     ; FCLO
03645             .BYTE <FCON     ; FCON
03646             .BYTE <FSBR     ; FSBR
03647             .BYTE <FISL     ; FISL
03648             .BYTE <FSTI     ; FSTI
03649             .BYTE <FSTO     ; FSTO
03650             .BYTE <FSLK     ; FSLK
03651  L3543      .BYTE 0             ; SPACE FOR HACKERS
03652             .BYTE 0
03653             .BYTE 0
03654             .BYTE 0
03655             .BYTE 0
03656             .BYTE 0               ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03657  ;
03658  ;     COMMAND DISPATCH TABLES
03659  ;
03660  ;     THESE COMMAND DISPATCH TABLES MAY BE PATCHED BY USER
03661  ;     TO ADD HIS OWN SPECIAL COMMAND HANDLERS
03662  ;
03663  ;     COMMAND CHARACTER TABLE
03664  ;
03665  
03666  COMTAB     .BYTE 'S'     ; 'S' SAVE COMMAND
03667             .BYTE 'I'     ; 'I' IF COMMAND
03668             .BYTE 'D'     ; 'D' DO COMMAND
03669             .BYTE 'O'     ; 'O' ON COMMAND
03670             .BYTE 'G'     ; 'G' GOTO COMMAND
03671             .BYTE 'F'     ; 'F' FOR COMMAND
03672             .BYTE 'R'     ; 'R' RETURN COMMAND
03673             .BYTE 'T'     ; 'T' TYPE COMMAND
03674             .BYTE 'A'     ; 'A' ASK COMMAND
03675             .BYTE 'C'     ; 'C' COMMENT COMMAND
03676             .BYTE 'E'     ; 'E' ERASE COMMAND
03677             .BYTE 'W'     ; 'W' WRITE COMMAND
03678             .BYTE 'M'     ; 'M' MODIFY COMMAND
03679             .BYTE 'Q'     ; 'Q' QUIT COMMAND
03680             .BYTE 0       ; SPACE FOR HACKERS
03681             .BYTE 0
03682             .BYTE 0
03683             .BYTE 0
03684             .BYTE 0
03685             .BYTE 0          ; MUST HAVE ONE ZERO TO END TABLE!
03686  ; 
03687  ;     HIGH ORDER ADDR OF COMMAND HANDLING ROUTINE
03688  ;
03689  COMADH     .BYTE >SET         ; SET    
03690             .BYTE >IF          ; IF     
03691             .BYTE >DO          ; DO     
03692             .BYTE >ON          ; ON     
03693             .BYTE >GOTO        ; GOTO   
03694             .BYTE >FOR         ; FOR    
03695             .BYTE >RETURN      ; RETURN 
03696             .BYTE >TYPE        ; TYPE   
03697             .BYTE >ASK         ; ASK    
03698             .BYTE >COMMNT      ; COMMENT
03699             .BYTE >ERASE       ; ERASE  
03700             .BYTE >WRITE       ; WRITE  
03701             .BYTE >MODIFY      ; MODIFY 
03702             .BYTE >QUIT        ; QUIT   
03703             .BYTE 0            ; SPACE FOR HACKERS
03704             .BYTE 0
03705             .BYTE 0
03706             .BYTE 0          ; MUST HAVE ZERO TO END TABLE!
03707  ;
03708  ;     LOW ORDER ADDR OF COMMAND HANDLING ROUTINE
03709  ;
03710  COMADL     .BYTE <SET         ; SET
03711             .BYTE <IF          ; IF
03712             .BYTE <DO          ; DO
03713             .BYTE <ON          ; ON
03714             .BYTE <GOTO        ; GOTO
03715             .BYTE <FOR         ; FOR
03716             .BYTE <RETURN      ; RETURN
03717             .BYTE <TYPE        ; TYPE
03718             .BYTE <ASK         ; ASK
03719             .BYTE <COMMNT      ; COMMENT
03720             .BYTE <ERASE       ; ERASE
03721             .BYTE <WRITE       ; WRITE
03722             .BYTE <MODIFY      ; MODIFY
03723             .BYTE <QUIT        ; QUIT
03724             .BYTE 0               ; SPACE FOR HACKERS
03725             .BYTE 0
03726             .BYTE 0
03727             .BYTE 0          ; MUST HAVE A ZERO TO END TABLE!
03728  ;
03729  ;     DISPATCH TABLE FOR 'EVBOP' ROUTINE
03730  ;
03731  ; two definitions here in the Prog/Exch code:
03732  ; at $2569 (3580 here) .DEF EVDSPH=.-1  and
03733  ; $256E (3585) .DEF EVDSPL=.-1
03734  ;
03735    3580              EVDSPH = * - 1
03736             .BYTE >FADD       ; FADD  
03737             .BYTE >FSUB       ; FSUB  
03738             .BYTE >FDIV       ; FDIV  
03739             .BYTE >FMUL       ; FMUL  
03740             .BYTE >EVPOWR     ; EVPOWR
03741  ;
03742    3585              EVDSPL = * - 1
03743             .BYTE <FADD       ; FADD
03744             .BYTE <FSUB       ; FSUB
03745             .BYTE <FDIV       ; FDIV
03746             .BYTE <FMUL       ; FMUL
03747             .BYTE <EVPOWR     ; EVPOWR
03748  ;
03749  ;          TABLES USED BY SOFTWARE INTERRUPT SYSTEM
03750  ;
03751  ; TABLE OF GROUP NUMBERS OF LINES TO 'DO' WHEN EVENT HAPPENS
03752  ; ONE ENTRY FOR EACH OF THE 8 PRIORITY CHANNELS
03753  ;
03754  INTGRP     .BYTE 0
03755             .BYTE 0
03756             .BYTE 0
03757             .BYTE 0
03758             .BYTE 0
03759             .BYTE 0
03760             .BYTE 0
03761             .BYTE 0
03762             .BYTE 0
03763  ;
03764  ; TABLE OF STEP NUMBERS OF LINES TO 'DO' WHEN AN EVENT HAPPENS
03765  ;
03766  INTLIN     .BYTE 0
03767             .BYTE 0
03768             .BYTE 0
03769             .BYTE 0
03770             .BYTE 0
03771             .BYTE 0
03772             .BYTE 0
03773             .BYTE 0
03774             .BYTE 0
03775  ;
03776  ; 'AND' MASKS USED TO DISABLE ALL BUT HIGHER PRIO CHANNELS.
03777  ; INDEXED BY CURRENT CHANNEL NUMBER
03778  ;
03779  INTTAB    .BYTE $FF     ; CHANNEL 0 ENABLES THEM ALL
03780            .BYTE $FE
03781            .BYTE $FC
03782            .BYTE $F8
03783            .BYTE $F0
03784            .BYTE $E0
03785            .BYTE $C0
03786            .BYTE $80
03787            .BYTE $00     ; CHANNEL 8 ENABLES NONE
03788  ;
03789  ; BIT TABLE CONTAINING A SINGLE BIT FOR EACH CHANNEL POSITION
03790  ;
03791  BITTAB    .BYTE $00
03792            .BYTE $01
03793            .BYTE $02
03794            .BYTE $04
03795            .BYTE $08
03796            .BYTE $10
03797            .BYTE $20
03798            .BYTE $40
03799            .BYTE $80
03800  ;
03801  ;     DISPATCH TABLE FOR I/O DEVICE NUMBERS
03802  ;
03803  ; handwritten note in P/E source: "READ/WRITE"
03804  ; Two definitions made here:
03805  ;     .DEF IDEWVM=3     .DEF ODEVM=3  ; MAX # OF I/O DEVICES
03806    0003              IDEVM = 3                  ; Original was IDEWVM - changed to IDEVM (Input DEVice Max)
03807    0003              ODEVM = 3
03808      
03809  ;
03810  IDSPH     .BYTE >KEYIN     ; DEVICE 0 - KEYBOARD INPUT ROUTINE
03811            .BYTE 0          ; DEVICE 1 - CASSETTE #0 INPUT ROUTINE
03812            .BYTE 0          ; DEVICE 2 - CASSETTE #1 INPUT ROUTINE
03813            .BYTE 0          ; SPACE FOR HACKERS
03814            .BYTE 0
03815  IDSPL     .BYTE <KEYIN
03816            .BYTE 0
03817            .BYTE 0
03818            .BYTE 0
03819            .BYTE 0
03820  ODSPH     .BYTE >TVOUT     ; DEVICE 0 - TV OUTPUT ROUTINE
03821            .BYTE 0          ; DEVICE 1 - CASSETTE #0 OUTPUT ROUTINE
03822            .BYTE 0          ; DEVICE 2 - CASSETTE #1 OUTPUT ROUTINE
03823            .BYTE 0          ; SPACE FOR HACKERS
03824            .BYTE 0
03825  ODSPL     .BYTE <TVOUT
03826            .BYTE 0
03827            .BYTE 0
03828            .BYTE 0
03829            .BYTE 0
03830  ;
03831  ; handwritten note in P/E source: "INITIALIZE IN/OUT"
03832  ;
03833  INIAH      .BYTE >RTS1     ; DON'T NEED TO INTIALIZE KEYBOARD
03834             .BYTE >RTS1     ; USER MUST PROVIDE ROUTINE
03835             .BYTE >RTS1     ;
03836             .BYTE $00       ; SPACE FOR HACKERS
03837             .BYTE $00
03838  ;
03839  INIAL      .BYTE <RTS1
03840             .BYTE <RTS1
03841             .BYTE <RTS1
03842             .BYTE 0
03843             .BYTE 0
03844  ;
03845  INOAH      .BYTE >CONINI	; USE TO STUFF VECTORS WITH BREAK HANDLERS
03846             .BYTE $29		; USER PROVIDES ROUTINES
03847             .BYTE $29
03848             .BYTE 0
03849             .BYTE 0
03850  ;
03851  INOAL      .BYTE <CONINI
03852             .BYTE $40
03853             .BYTE $40
03854             .BYTE 0
03855             .BYTE 0
03856  ;
03857  ; handwritten note in P/E source: "CLOSE IN/OUT"
03858  ;
03859  CLIAH     .BYTE >RTS1   ; KEYBOARD DOESN'T NEED A CLOSE ROUTINE
03860            .BYTE >RTS1   ; USER PROVIDES ROUTINE
03861            .BYTE >RTS1   ;
03862            .BYTE $00     ; SPACE FOR HACKERS
03863            .BYTE $00     ; SPACE FOR HACKERS
03864  ;
03865  CLIAL     .BYTE <RTS1
03866            .BYTE <RTS1
03867            .BYTE <RTS1
03868            .BYTE 0
03869            .BYTE 0
03870  ;
03871  CLOAH     .BYTE >RTS1	; TV DOESN'T NEED A CLOSE ROUTINE
03872            .BYTE >RTS1	; USER PROVIDES ROUTINE
03873            .BYTE >RTS1	;
03874            .BYTE $00	; SPACE FOR HACKERS
03875            .BYTE $00  
03876  ;                    
03877  CLOAL     .BYTE <RTS1
03878            .BYTE <RTS1
03879            .BYTE <RTS1
03880            .BYTE 0
03881            .BYTE 0
03882  
03883  PRGBEG    .BYTE 0	; LINE NUMBER OF 00.00
03884            .BYTE 0     
03885            .ASCII  " C FOCAL-65 (V3D) 26-AUG-77"
03886            .BYTE $0D	; 'CR'
03887  
03888  
03889  PBEG      .BYTE EOP     ; START OF PROGRAM TEXT AREA
03890  VEND      .BYTE EOV     ; END OF VARIABLE LIST
03891           .END     
