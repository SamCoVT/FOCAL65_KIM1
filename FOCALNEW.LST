00001    
00002    ; First disassembly by Paul R. Santa-Maria (2004)
00003    ; Initial comments added by Hans Otten, 2022
00004    ;
00005    ; New listing and comments from Wayne Wall's FOCAL-65 v3 (6502-TIM monitor ROM)
00006    ; and v4 (Apple II-specific) painstakingly typed in by Dave Hassler and
00007    ; Nils Andreas, 2023. (WAYNE'S COMMENTS, my/Nils's comments - dhh)
00008    ; v3d TIM source provided by Paul Bikle, v4 by Wayne Wall, both in 2023.
00009    ; Proofreading and corrections by SamCoVT, MIKE B., GAVIN D., AZin67
00010    ;
00011    
00012    ; Zero page block - *must* be loaded before main program executes
00013    
00014    ;0000  53 53 4C E0 2C 4C DF 2C-00 00 00 00 00 00 00 00
00015    ;0010  00 62 7B 66 EB 6B 3A 7B-6A 6B 6B 7B FB 7B 6B 6B
00016    ;0020  00 00 00 00 00 00 FF 00-00 01 00 00 00 00 00 E0
00017    ;0030  36 FE 36 00 00 00 00 00-00 00 00 00 00 00 FF 36
00018    ;0040  FF 36 FF 36 00 00 00 00-00 00 00 00 00 00 00 00
00019    ;0050  00 00 00 00 5F 00 00 00-00 00 00 00 00 00 4C 00
00020    ;0060  00 6C 00 00 48 00 00 00-00 00 00 00 00 00 00 C0
00021    ;0070  10 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00
00022    ;0080  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 05
00023    ;0090  05 83 50 00 00 00 7F 40-00 00 00 80 40 00 00 00
00024    ;00A0  00 00 00 00 00 FF 1C 3C-7C 5F 7F 7C 3E 7F 3E FF
00025    ;00B0  94 DD 84 D4 85 D4 95 04-DD 94 95 DF 8C 15 1D 94
00026    ;00C0  00 D3 E0 C1 80 90 D3 C0-C2 A3 00 C0 81 82 C3 80
00027    ;00D0  62 6A FB 6B 6A 6A 02 FF-5A 4B E3 10 EB 62 62 4B
00028    ;00E0  7F 6C 7F 7D 3F 7F 2E 7F-7F 7E 7F 36 5F 7E 3E 7F
00029    ;00F0  94 00 FF FF 84 A7 19 83-00 00 DF 10 A9 FF C7 01
00030    
00031    0000                       .ORG $0000
00032    
00033            .BYTE $53, $53, $4C, $E0, $2C, $4C, $DF, $2C, $00, $00, $00, $00, $00, $00, $00, $00        
00034            .BYTE $00, $62, $7B, $66, $EB, $6B, $3A, $7B, $6A, $6B, $6B, $7B, $FB, $7B, $6B, $6B
00035            .BYTE $00, $00, $00, $00, $00, $00, $FF, $00, $00, $01, $00, $00, $00, $00, $00, $E0
00036            .BYTE $36, $FE, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $FF, $36
00037            .BYTE $FF, $36, $FF, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00038            .BYTE $00, $00, $00, $00, $5F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $4C, $00
00039            .BYTE $00, $6C, $00, $00, $48, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $C0
00040            .BYTE $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00041            .BYTE $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05
00042            .BYTE $05, $83, $50, $00, $00, $00, $7F, $40, $00, $00, $00, $80, $40, $00, $00, $00
00043            .BYTE $00, $00, $00, $00, $00, $FF, $1C, $3C, $7C, $5F, $7F, $7C, $3E, $7F, $3E, $FF
00044            .BYTE $94, $DD, $84, $D4, $85, $D4, $95, $04, $DD, $94, $95, $DF, $8C, $15, $1D, $94
00045            .BYTE $00, $D3, $E0, $C1, $80, $90, $D3, $C0, $C2, $A3, $00, $C0, $81, $82, $C3, $80
00046            .BYTE $62, $6A, $FB, $6B, $6A, $6A, $02, $FF, $5A, $4B, $E3, $10, $EB, $62, $62, $4B
00047            .BYTE $7F, $6C, $7F, $7D, $3F, $7F, $2E, $7F, $7F, $7E, $7F, $36, $5F, $7E, $3E, $7F
00048            .BYTE $94, $00, $FF, $FF, $84, $A7, $19, $83, $00, $00, $DF, $10, $A9, $FF, $C7, $01
00049    
00050    ; ZERO PAGE USE:
00051    
00052    ; 00	= unused
00053    ; 02	= JMP INTSRV	- on IRQ
00054    ; 05	= JMP NMISRV	- on NMI
00055    ;    -- I have *no* idea what's going on with $10-$1F... dhh)
00056    
00057      0020             DEBGSW	= $20		; TRACE FLAG
00058      0021             DMPSW	= $21		; 'DUMP SWITCH'
00059      0022             ATSW	= $22		; ASK-TYPE CMDS FLAG
00060      0023             IFONSW	= $23		; IF-ON CMDS FLAG
00061      0024             INSW	= $24		; INPUT INDICATOR
00062      0025             MSCHAR	= $25		; 'MODIFY' SEARCH CHAR
00063    
00064    		; *** FOLLOWING MUST BE CONTIGUOUS ***
00065      0026             PC	= $26		; PROG COUNTER
00066      0028             TXTADR	= $28		; CHAR ADDR
00067      002A             TEXTP	= $2A		; TEXT POINTER
00068      002B             CHAR	= $2B		; CURRENT CHARACTER
00069      002C             GRPNO	= $2C		; GROUP NUMBER
00070      002D             LINENO	= $2D		; LINE (STEP) NUMBER
00071      002E             PRILVL	= $2E		; CURRENT S/W INTERUPT PRIORITY
00072    		; *** END OF MUST BE CONTIGUOUS ***
00073    
00074      002F             TXTBEG	= $2F		; POINTER TO BEGINNING OF STORED PROGRAM
00075      0031             PBADR	= $31		; ADDR OF START OF USER PROGRAM
00076      0033             TXTAD2	= $33
00077      0035             TEXTP2	= $35		; COUNTERPART TO 'CHAR,' ABOVE
00078    
00079    		; POINTERS TO VARIABLE LIST - *** MUST BE CONTIGUOUS ***
00080    
00081      0037             VARADR	= $37		; POINTER TO CURRENT VAR IN LIST
00082      0039             VSUB	= $39		; LOCATION TO HOLD SUBSCRIPT DURING VAR SEARCH
00083      003B             STRSWT 	= $3B		; FLAG IF CURR VAR IS $ (also label FSWIT)
00084      003B             FSWIT   = $3B
00085      003C             VSIZE	= $3C		; SIZE OF CURR STRING VAR (GETVAR)
00086      003D             VCHAR	= $3D		; PLACE TO HOLD VAR NAME DURING SEARCH (also TCHAR)
00087      003E             VARBEG	= $3E		; POINTER BEGINNING VAR LIST
00088      0040             VARST	= $40		; POINTS TO END OF VARS ON 'E ALL' COMMAND
00089      0042             VAREND	= $42		; POINTS TO END OF VAR LIST
00090    
00091    		; POINTERS FOR STRING I/O
00092    
00093      0044             STIADR	= $44		; HOLDS ADDR POINTER TO INPUT STRING
00094      0046             STIPNT	= $46		; OFFSET POINTER
00095      0047             STIMAX	= $47		; HOLDS SIZE OF INPUT STRING
00096      0048             STOADR	= $48		; HOLDS ADDR POINTER TO OUTPUT STRING
00097      004A             STOPNT	= $4A		; OFFSET POINTER
00098      004B             STOMAX	= $4B		; HOLDS SIZE OF OUTPUT STRING
00099    
00100    		; SOFTWARE PUSHDOWN LIST
00101    
00102      004C             PDPADR	= $4C		; ADDR TO LIST (software stack)
00103      004E             PDP	= $4E		; OFFSET POINTER TO LIST
00104      004F             PDPTMP	= $4F		; TEMP LOC. FOR 'ROOMCK'
00105      0051             TGRP	= $51		; HOLDS TEMPORARY GROUP NUMBER FOR SOME
00106      0051             TLINE	= $51		;   OPERATIONS. TEMP LINE # HERE
00107    
00108      0053             PDLIST	= $53		; STARTING ADDR OF SOFTWARE PDL
00109    			; ** effectively, the last page of FOCAL's user RAM.
00110    			;    Change to what suits your system. - dhh
00111      0055             STRAD1  = $55           ; DEFINE POINTERS TO STRING 1 IN 'FSLK'
00112      0055             STRCNT  = $55           ; TEMP COUNTER FOR SOME STRING OPERATIONS
00113      0055             ITMP1L	= $55		; TEMP1 LOW BYTE
00114      0056             ITMP1H	= $56		; TEMP1 HIGH BYTE (this is also STRCNT)
00115      0057             SBEG1	= $57		; START POS. OF STRING 1
00116      0058             SEND1	= $58		; END POS. STRING 1
00117    
00118      0059             STRAD2  = $59           ; DEFINE POINTERS TO STRING 2 IN 'FSLK'
00119      0059             STRMAX  = $59           ; TEMP FOR SOME STRING OPERATIONS
00120      0059             ITMP2L	= $59		; TEMP2 LOW BYTE
00121      005A             ITMP2H	= $5A		; TEMP2 HIGH BYTE (this is also STRMAX)
00122      005B             SBEG2	= $5B		; START POS. OF STRING 2
00123      005C             SEND2	= $5C		; END POS. STRING 2
00124      005D             STBSAV	= $5D		; PLACE TO SAVE BEGINNING SUBSCRIPT
00125      005E             JSRIND	= $5E		; JSR OPCODE ($4C) FOR 'JSRIND' - *MUST* BE PLACED
00126    			;   JUST BEFORE 'TEMP1'.
00127      005F             TEMP1	= $5F		;   *** VERY TEMPORARY STORAGE! NOT NECESSARILY
00128    			;   PRESERVED ACROSS SUBROUTINE CALLS!
00129      0061             JMPIND	= $61		; OPCODE FOR 'JMP INDIRECT' ($6C)
00130      0062             PJMPL	= $62		; LOW ORDER ADDR FOR 'JMPIND'
00131      0063             PJMPH	= $63		; HIGH ORDER BYTE
00132    
00133      0064             STRSIZ	= $64		; HOLDS DEFAULT STRING SIZE ($48)
00134      0065             ETEMP1	= $65		; TEMP USED BY 'EVAL'
00135      0066             IDEV	= $66		; SPECIFIES INPUT DEVICE
00136      0067             ODEV	= $67		; SPECIFIES OUTPUT DEVICE
00137      0068             IDVSAV	= $68		; SAVE INP DEV #
00138      0069             ODVSAV	= $69		; SAVE OUTPUT DEV #
00139      006A             CONDEV	= $6A		; SPECIFIES DEVICE # OF CONSOLE
00140      006B             ECHFLG	= $6B		; ECHO FLAG
00141      006C             DELSPL	= $6C		; SPECIAL DELETE FOR CRT
00142      006D             ACTMSK	= $6D		; MASK TO INDICATE WHICH S/W INTERRUPT CH ARE ACTIVE
00143      006E             EVMASK	= $6E		; HOLDS EVENT BITS SET BY EXTERNAL ROUTINES
00144    			;   WHEN THEY WANT FOCAL'S ATTENTION
00145      006F             BITV1	= $6F		; USED TO SET V=1, N=1 (#$C0)
00146      0070             MSKBRK	= $70		; BIT TEST MASK FOR BREAK (#$10)
00147      0071             ACSAV	= $71		; PLACE WHERE ACC IS SAVED ON INTERRUPT
00148      0072             STATUS	= $72		; PLACE WHERE PROC STATUS IS SAVED ON INTERRUPT
00149      0073             ITEMP1	= $73		; PLACE WHERE RET ADDR IS KEPT ON INTERRUPT
00150    
00151      0075             LASTOP	= $75		; USED BY 'EVAL'
00152      0076             HASH	= $76		; LOADED WITH A RANDOM HASH VALUE
00153    			;   *** NOTE: SOME ROUTINE IN YOUR SPECIFIC
00154    			;             COMPUTER SYSTEM SHOULD LOAD THIS
00155    			;	      LOC. WITH A PSEUDO-RANDOM 8-BIT VALUE.
00156      0077             SEED	= $77		; 3 BYTES. HOLDS A 23-BIT RANDOM # SEED - SEE 'FRAN'
00157    
00158    		; FLOATING POINT ROUTINES Z PG USE
00159    
00160      007A             SIGN	= $7A		; (also X2M1)
00161    
00162      007B             X2	= $7B		; FAC2 EXPONENT (also the *beginning of 'FAC2'*)
00163      007C             M2	= $7C		; FAC2 MANTISSA (3 bytes)
00164      007F             X1M1	= $7F
00165    
00166      0080             X1	= $80		; FAC1 EXPONENT (also the *beginning of 'FAC1'*)
00167      0080             FAC1    = $80
00168      0081             M1	= $81		; FAC1 MANTISSA (3 bytes, also 'FLCSGN')
00169      0081             FLCSGN  = $81
00170      0084             EM1	= $84
00171      0085             E	= $85		; SCRATCH AREA
00172      0089             EP4	= $89		; add'l scratch RAM alluded to elsewhere
00173    
00174    		; FLOATING POINT I/O ROUTINES
00175    
00176      008A             SIGNP	= $8A		; TEMPORARY SIGN
00177      008B             DPFLG	= $8B		; SAW DECIMAL POINT
00178      008C             GOTFLG	= $8C		; IF NON ZERO, WE ACTUALLY INPUT A NUMBER
00179      008D             K	= $8D		; MISC COUNTER
00180      008E             L	= $8E		; TEMP
00181      008F             M	= $8F		; # OF PLACES BEFORE DECIMAL POINT
00182      0090             N	= $90		; # OF PLACES AFTER DECIMAL POINT
00183    
00184      0091             FTEN	= $91		; CONSTANT 10.00
00185      0096             FHALF	= $96		; CONSTANT 2.50
00186      009B             FONE	= $9B		; CONSTANT 1.00
00187      00A0             T	= $A0		; TEMP (5 bytes)
00188    
00189    		; FLAG END OF OUR PAGE ZERO USAGE
00190    		; FOR ANYONE WHO NEEDS TO KNOW
00191    
00192    ;	$A5 = SAVYR  save for Y register (was $7F in v3 - RUBOUT)
00193    ;	also, end of zero page usage
00194    ;	TIM I/O package not in the Aresco version of v3d.
00195    
00196    		;		FOCAL SYMBOL DEFINITIONS
00197    		; 
00198    		; ALL POSSIBLE SYMBOLIC EQUATES SHOULD BE KEPT IN THIS MODULE
00199    		;
00200    		; FOCAL ERROR CODES - NEGATIVE
00201    		;
00202    
00203      00DB             BASTRF	= $DB		; -37 BAD OR MISSING ARGUMENT IN A STRING FUNCTION
00204      00DC             SVRQ	= $DC		; -36 STRING VARIABLE REQUIRED HERE
00205      00DD             SVNA	= $DD		; -35 STRING VARIABLE NOT ALLOWED HERE
00206      00DE             ERRO	= $DE		; -34 I-O ERROR ON OUTPUT DEVICE
00207      00DF             ARGM	= $DF		; -33 ARGUMENT MISSING IN FUNCTION
00208      00E0             XNU32	= $E0		; -32 CURRENTLY NOT USED
00209      00E1             WNEXG	= $E1		; -31 "WRITE" OF NON-EXISTANT GROUP
00210      00E2             UNRFUN	= $E2		; -30 UNRECOGNIZABLE FUNCTION NAME
00211      00E3             PFERR	= $E3		; -29 PARENTHESES ERROR IN FUNCTION
00212      00E4             MNEXL	= $E4		; -28 "MODIFY" OF NON-EXISTANT LINE
00213      00E5             DONEXG	= $E5		; -27 "DO" OF NON-EXISTANT GROUP
00214      00E6             DONEXL	= $E6		; -26 "DO" OF NON-EXISTANT LINE
00215      00E7             IFSYN	= $E7		; -25 SYNTAX ERROR IN "IF" OR "ON" COMMAND
00216      00E8             ENEXL	= $E8		; -24 "ERASE" OF NON-EXISTANT LINE
00217      00E9             ERRI	= $E9		; -23 I-O ERROR ON INPUT DEVICE
00218      00EA             WNEXL	= $EA		; -22 "WRITE" OF NON-EXISTANT LINE
00219      00EB             GONEXL	= $EB		; -21 "GOTO" NON-EXISTANT LINE
00220      00EC             BADLI	= $EC		; -20 BAD LINE NUMBER ON INPUT
00221      00ED             UNKINT	= $ED		; -19 UNKNOWN INTERRUPT REQUEST
00222      00EE             UNRBRK	= $EE		; -18 UNRECOGNIZABLE TRAP CODE
00223      00EF             RESBRK	= $EF		; -17 RESET BUTTON PRESSED
00224      00F0             DEVRNG	= $F0		; -16 DEVICE NUMBER OUT OF RANGE
00225      00F1             UFL	= $F1		; -15 USELESS "FOR" LOOP
00226      00F2             FBDTRM	= $F2		; -14 BAD TERMINATOR IN "FOR"
00227      00F3             NOEQLS	= $F3		; -13 NO "=" IN "FOR"
00228      00F4             BADVAR	= $F4		; -12 BAD VARIABLE NAME
00229      00F5             FUNILL	= $F5		; -11 FUNCTION ILLEGAL HERE
00230      00F6             XNU10	= $F6		; -10 NOT USED AT THIS TIME
00231      00F7             XNU9	= $F7		; -9 NOT USED AT THIS TIME
00232      00F8             FOVFL	= $F8		; -8 FLOATING POINT OVERFLOW
00233      00F9             OPNMIS	= $F9		; -7 OPERAND MISSING - EVAL
00234      00FA             PMATCH	= $FA		; -6 PARENTHESES MISMATCH - EVAL
00235      00FB             OPRMIS	= $FB		; -5 OPERATOR MISSING - EVAL
00236      00FC             ILLNO	= $FC		; -4 ILLEGAL LINE NUMBER
00237      00FD             BADCOM	= $FD		; -3 UNRECOGNIZABLE COMMAND
00238      00FE             EILLG0	= $FE		; -2 ILLEGAL GROUP ZERO USAGE
00239      00FF             LTL	= $FF		; -1 LINE TOO LONG
00240    
00241    		;
00242    		; FUNCTION HASH CODE DEFINITIONS
00243    		;
00244      0036             HFABS	= $36		; ABSOLUTE VALUE FUNCTION
00245      00F4             HFOUT	= $F4		; OUTPUT FUNCTION
00246      00B0             HFRAN	= $B0		; RANDOM NUMBER FUNCTION
00247      00A8             HFINT	= $A8		; INTERGERIZE FUNCTION
00248      00A4             HFINR	= $A4		; INTEGERIZE AFTER ROUNDING FUNCTION
00249      0084             HFIDV	= $84		; SET INPUT DEVICE FUNCTION
00250      00B4             HFODV	= $B4		; SET OUTPUT DEVICE FUNCTION
00251      005C             HFCHR	= $5C		; SINGLE ALPHA CHAR INPUT FUNCTION
00252      0090             HFCUR	= $90		; SPECIAL CLRSCR ADDRESSING FUNCTION
00253      0044             HFECH	= $44		; ECHO CONTROL FUNCTION
00254      00AA             HFPIC	= $AA		; PRIORITY INTERRUPT CONTROL FUNCTION
00255      0096             HFMEM	= $96		; MEMORY EXAMINE-DEPOSIT FUNCTION
00256      0092             HFINI	= $92		; INITIALIZE INPUT DEVICE FUNCTION
00257      009E             HFINO	= $9E		; INITIALIZE OUTPUT DEVICE FUNCTION
00258      005A             HFCLI	= $5A		; CLOSE INPUT DEVICE FUNCTION
00259      0066             HFCLO	= $66		; CLOSE OUTPUT DEVICE FUNCTION
00260      0073             HFCON	= $73		; SET CONSOLE DEVICE FUNCTION
00261      00C4             HFSBR	= $C4		; 'SUBROUTINE' CALL FUNCTION
00262      00AC             HFISL	= $AC		; INITIALIZE STRING LENGTH FUNCTION
00263      00FA             HFSTI	= $FA		; STRING INPUT FUNCTION
00264      0006             HFSTO	= $06		; STRING OUTPUT FUNCTION
00265      00DE             HFSLK	= $DE		; STRING "LOOK" FUNCTION
00266    
00267    		; MORE DEFINITIONS
00268    
00269      0005             NUMBF	= 5		; # BYTES IN A F.P. #
00270      0008             VARSIZ	= 3+NUMBF	; 1 BYTE FOR NAME, 2 BYTES SUBSCRIPT, THEN VALUE
00271      007F             LINEL	= 127		; MAX LENGTH FOCAL LINE +1; MUST NOT >127 (SEE 'PACKC')
00272      00FF             EOV	= $FF		; END OF VAR MARKER
00273      00FE             EOP	= $FE		; END OF PROG MARKER
00274      00FD             UMARK	= $FD		; ANOTHER UNIQUE MARKER
00275      00FC             STRMRK	= $FC		; MARKS A STRING VAR IN VAR LIST
00276      0048             STRLEN	= 72		; DEF STRING LENGTH
00277    
00278      005C             RUBECH	= $5C	; '\' ECHOED FOR RUBOUT (unused here for modern tty emu)
00279      005F             LINCHR	= $5F	; '_' ECHOED FOR LINE DELETE
00280      001B             ALTCHR	= $1B	; 'ESC' CHAR USED FOR 'ALTMODE' - MAY REQUIRE CHANGE
00281      007F             RUBCHR  = $7F
00282    
00283      00FF             DIRLIN	= $FF
00284      00FE             STRLIN	= $FE
00285      00FD             RETCMD	= $FD
00286    
00287      0100             STACK	= $0100
00288    
00289    ; self modifying code locations: (P.R.S-M)
00290    ;                H2350   EQU $2350
00291    ;                H2351   EQU $2351
00292    ;                H282F   EQU $282F
00293    ;                H2830   EQU $2830
00294    ;                H340A   EQU $340A
00295    ;                H340C   EQU $340C
00296    
00297    ;			***** 'FOCINT - FOCAL CODE INTERPRETER
00298    ;
00299    ;		THIS IS WHERE THE HEART OF FOCAL LIES.  INPUT PROCESSING,
00300    ;	COMMAND DECODING, CONTROL FLOW, AND EXECUTION ARE PERFORMED
00301    ;	IN THIS MODULE.
00302    ;		
00303    
00304    2000                      .ORG $2000
00305    
00306    ;	'FOCAL' COMES HERE ON A 'RESET' (PANIC RESTART)
00307    
00308    2000  78           FOCAL     SEI		; MAKE SURE INTERRUPTS ARE DISABLED
00309    2001  D8                     CLD		; AND DICIMAL MODE IS OFF
00310    2002  A2 FF                  LDX #$FF	; INIT STACK POINTER
00311    2004  9A                     TXS
00312    2005  20 0D 20               JSR SETUP	; SET UP SOME INITIAL PARAMETERS
00313    2008  20 27 20               JSR INIDEV	; INIT CONSOLE DEVICE
00314    200B  00                     BRK		; ENTER FOCAL VIA TRAP
00315              .BYTE $EF	; A DATA BYTE - INDICATE 'RESET' PRESSED
00316    200D  A2 FF        SETUP     LDX #$FF	; INIT SOFTWARE PUSHDOWN LIST
00317    200F  20 1C 20               JSR PDPINI     
00318    2012  E8                     INX		; FORM A ZERO IN X
00319    2013  86 6B                  STX ECHFLG	; TURNS ECHOING ON
00320    2015  A5 6A        CLRDEV    LDA CONDEV	; SET CONSOLE AS BOTH IN AND OUT DEVICES
00321    2017  85 66                  STA IDEV
00322    2019  85 67                  STA ODEV
00323    201B  60                     RTS
00324    ; 
00325    ; ROUTINE TO INIT SOFTWARE PUSHDOWN LIST POINTER
00326    ; 
00327    201C  86 4E        PDPINI    STX PDP	; ASSUMED TO CONTAIN '$FF' IN X REGISTER
00328    201E  A5 53                  LDA PDLIST	; RESET ADDR POINTER
00329    2020  85 4C                  STA PDPADR
00330    2022  A5 54                  LDA PDLIST+1
00331    2024  85 4D                  STA PDPADR+1
00332    2026  60                     RTS
00333    ; 
00334    ; ROUTINE TO INIT I/O DEVICES
00335    ; 
00336    2027  A5 66        INIDEV    LDA IDEV	; INIT INPUT DEVICE
00337    2029  20 8D 2E               JSR INI     
00338    202C  A5 67                  LDA ODEV	; INIT OUTPUT DEVICE
00339    202E  4C A2 2E               JMP INO	; * PJMP * AND RETURN
00340    ; 
00341    2031  A2 FF        START     LDX #$FF	; warm entry point. FOCAL comes here
00342    2033  9A                     TXS		; on an internal restart. INIT STACK
00343    2034  86 21                  STX DMPSW	; FLAG THE TRACE OFF
00344    2036  86 26                  STX PC	; INDICATE PROC. A DIRECT COMMAND
00345    2038  E8                     INX		; GET A ZERO
00346    2039  86 20                  STX DEBGSW	; ALLOW TRACE TO BE ENABLED
00347    203B  86 28                  STX TXTADR	; INIT TEXT POINTERS TO CMD BUFFER
00348    203D  86 2A                  STX TEXTP	; RESET OFFSET POINTER TO TEXT LINE
00349    203F  86 6D                  STX ACTMSK	; INDICATE ALL S/W INTER. CHNLS INACTIVE
00350    2041  86 6E                  STX EVMASK	; CLEAR ANY EXT. EVENT FLAGS
00351    2043  86 2E                  STX PRILVL	; SET TO LOWEST PRIORITY LEVEL
00352    2045  E8                     INX		; GET A 1
00353    2046  86 29                  STX TXTADR+1	; CMD BUFFER IS IN STACK AREA
00354    2048  A9 2A                  LDA #$2A	; LOAD PROMPT CHARACTER '*'
00355    204A  20 02 29               JSR PRINTC	;   AND ANNOUNCE OUR PRESENCE
00356    204D  20 C0 28     NEXTIC    JSR READC	; GO INPUT A CHAR FROM INPUT DEVICE
00357    2050  C9 0A                  CMP #$0A	; LF?
00358    2052  F0 F9                  BEQ NEXTIC	; YES, IGNORE LF ON COMMAND INPUT
00359    2054  20 2D 29               JSR PACKC1	; NO, STORE CHAR IN CMD BUFFER
00360    2057  C9 0D                  CMP #$0D	; CR?
00361    2059  D0 F2                  BNE NEXTIC	; IF NOT, GET ANOTHER
00362    ; 
00363    ; COMMAND/INPUT PROCESSOR
00364    ; 
00365    205B  A2 00        IRETN     LDX #$00	; RESET TEXT POINTER
00366    205D  86 2A                  STX TEXTP
00367    205F  86 24                  STX INSW	; FLAG TEXT CHAR TO COME FROM MEMORY
00368    2061  CA                     DEX		; SET TO $FF
00369    2062  20 1C 20               JSR PDPINI	; INIT SOFTWARE PDL POINTER
00370    2065  20 B1 29               JSR GSPNOR	; IGNORE LEADING BLANKS
00371    2068  20 C0 29               JSR TESTN1	; HAVE A NUMBER?
00372    206B  90 06                  BCC GOTNUM	; YES, BRANCH
00373    206D  C9 2E                  CMP #$2E	; NO, TEST '.'
00374    206F  D0 13                  BNE INPX1	; NOT # OR '.', MUST BE DIRECT CMD
00375    2071  00                     BRK		; TRAP
00376             .BYTE $FE	; CODE FOR ILL. GROUP 0 USEAGE
00377    2073  E6 20        GOTNUM    INC DEBGSW	; A DIGIT; DISABLE TRACE FOR PACKING
00378    2075  20 B6 25               JSR GETLNC	; GET THE LINE # FROM COMBUF
00379    2078  70 08                  BVS IBADL	; 00.00 IS A BAD LINE NUMBER
00380    207A  F0 06                  BEQ IBADL	; GG.00 IS A BAD LINE NUMBER
00381    207C  20 84 27     REPLIN    JSR INSERT	; GO INSERT THIS LINE IN THE TEXT AREA
00382    207F  4C 31 20     RSTART    JMP START	; AND START OVER FOR NEXT DIR. CMD
00383    2082  00           IBADL     BRK		; TRAP
00384             .BYTE $EC	; ?BAD LINE # ON INPUT
00385    
00386    2084  20 1C 28     INPX1     JSR PUSHJ	; PROCESS COMMAND
00387              .WORD PROC	; $2302
00388    2089  A5 26                  LDA PC	; GET PROGRAM LINE NUMBER
00389    208B  30 A4                  BMI START     ; START OVER IF DIRECT CMD
00390    208D  20 D7 26               JSR EATCR1	; EAT TO END OF LINE
00391    2090  20 32 27               JSR NXTLIN	; GO SET UP POINTERS TO NEXT LINE
00392    2093  B0 EF                  BCS INPX1     ; BRANCH IF MORE TO DO
00393    2095  90 9A                  BCC START     ; BRANCH IF END OF PROGRAM
00394    ; 
00395    ; ROUTINE TO 'DO' CODE STORED IN A STRING
00396    ; 
00397    ; THIS ROUTINE ALLOWS THE EXECUTION OF CODE STORED IN A
00398    ; STRING VARIABLE.  IF ONE PLACES CHARACTERS INTO A STRING
00399    ; VARIABLE, AND ENDS THEM WITH A CARRIAGE RETURN, THEN A
00400    ; 'DO' COMMAND CAN BE USED TO PERFORM THE LINE STORED IN THE
00401    ; STRING VARIABLE.
00402    ; 
00403    2097  20 B9 20     DOSTR     JSR PUSHDO	; SAVE CURRENT GOODIES ON STACK
00404    209A  A5 37                  LDA VARADR	; POINT TO SPEC. CHAR IN STRING
00405    209C  85 28                  STA TXTADR	;   WITH TEXT POINTERS
00406    209E  A5 38                  LDA VARADR+1
00407    20A0  85 29                  STA TXTADR+1
00408    20A2  A5 3A                  LDA VSUB+1	; GET CHAR POSITION IN STRING
00409    20A4  85 2A                  STA TEXTP     
00410    20A6  A9 FE                  LDA #STRLIN	; FLAG THIS SO 'FNDLIN' WILL ALWAYS LOOK
00411    20A8  85 26                  STA PC	;   FROM BEGINNING OF PROGRAM TEXT
00412    20AA  A5 3D                  LDA VCHAR	; STORE THE STRING VARIABLE'S NAME FOR
00413    20AC  85 27                  STA PC+1	;   ERROR MSG PRINT ROUTINE (BERROR)
00414    20AE  20 1C 28               JSR PUSHJ	; NOW 'DO' THE STRING (SHUD HAVE CR!)
00415              .WORD PROCES	; $22FF
00416    20B3  20 C0 20               JSR POPDO	; RESTORE CURRENT GOODIES
00417    20B6  20 4B 28               JSR POPJ	;   AND RETURN FROM 'DO'
00418    ; 
00419    ; ROUTINE TO SAVE NEEDED INFO ON STACK.  USED BY 'DO'
00420    ; 
00421    20B9  A2 26        PUSHDO    LDX #$26	; GET ADDR OF START OF SAVE AREA
00422    20BB  A0 09                  LDY #$09	;   AND # OF BYTES TO SAVE
00423    20BD  4C 6B 28               JMP PUSHB0	; * PJMP * PUSH THEM ON STACK & RET.
00424    ; 
00425    ; ROUTINE TO RESTORE NEEDED INFO AFTER THE 'DO'
00426    ; 
00427    20C0  A2 2E        POPDO     LDX #$2E	; GET BASE ADDR TO PUT INFO BACK INTO
00428    20C2  A0 09                  LDY #$09	;   AND # OF BYTES TO RESTORE
00429    20C4  4C 5B 28               JMP POPB0	; * PJMP * POP THEM OFF AND RETURN
00430    ; 
00431    ; 'IF' COMMAND PROCESSOR (CONDITIONAL GOTO)
00432    ; THROW IN THE 'QUIT' COMMAND HERE ALSO
00433    ; 
00434      2031             QUIT     = START
00435    
00436    ON
00437    ; 
00438    ; in WW source of '77, JSR PUSHA is here; not in Aresco binary --dhh
00439    ; 
00440    20C7  85 23        IFON      STA $23	; not in Aresco code
00441    20C9  20 B1 29               JSR GSPNOR	; MOVE TO NEXT NON-BLANK
00442    20CC  C9 28                  CMP #$28	; '('
00443    20CE  F0 02                  BEQ IFCNT1	; YES, BRANCH
00444    20D0  00                     BRK		; NO, TRAP
00445              .BYTE $E7	; SYNTAX ERROR IN 'IF' OR 'ON' CMD (IFSYN)
00446    20D2  20 1C 28     IFCNT1    JSR PUSHJ	; NOW EVALUATE WHAT'S IN PARENS
00447              .WORD EVALM1
00448    20D7  A5 2B                  LDA CHAR	; GET TERMINATOR
00449    20D9  C9 29                  CMP #$29	; ')'
00450    20DB  F0 02                  BEQ IFCNT2	; YES, CONTINUE
00451    20DD  00                     BRK		;NO, TRAP
00452              .BYTE PMATCH	; ?PARENTHESIS MISMATCH
00453    20DF  20 92 29     IFCNT2    JSR GETC	; MOVE PAST RIGHT PAREN
00454    20E2  A5 81                  LDA FLCSGN	; GET THE SIGN OF THE EXPRESSION
00455    20E4  30 2B                  BMI IFXCT	; IF NEGATIVE, GO DO IT NOW
00456    20E6  10 03                  BPL IF3	; OTHERWISE, LOOK FOR COMMA
00457    20E8  20 92 29     IFCOM     JSR GETC	; GET A CHAR
00458    20EB  A5 2B        IF3       LDA CHAR
00459    20ED  C9 2C                  CMP #$2C	; ','
00460    20EF  F0 0B                  BEQ IF1	; BRANCH IF YES
00461    20F1  C9 3B                  CMP #$3B	; ';'
00462    20F3  F0 31                  BEQ IFNOP	; YES, CONTINUE WITH NEXT CMD ON THIS LINE
00463    20F5  C9 0D                  CMP #$0D	; CR?
00464    20F7  D0 EF                  BNE IFCOM	; NO, KEEP LOOKING ('JSR POPA' in betw. orig)
00465    20F9  20 4B 28               JSR POPJ	; YES, THEN EXIT 'PROCESS'
00466    20FC  20 92 29     IF1       JSR GETC	; MOVE PAST THE COMMA
00467    20FF  A9 00                  LDA #$00	;          from here, the Aresco code is wildy
00468    2101  A2 03                  LDX #$03	; different from the original Program Exchange.  ...
00469    2103  15 81        L2103     ORA $81,X	; (left generic label from disassembly here)
00470    2105  CA                     DEX		;
00471    2106  10 FB                  BPL L2103	;
00472    2108  09 00                  ORA #$00	; ... to here.  --dhh
00473    210A  F0 05                  BEQ IFXCT	; BRANCH IF FAC1=0
00474    210C  20 CB 2C               JSR ZRFAC1	; SET IT TO ZERO, THIS TIME FOR SURE
00475    210F  30 DA                  BMI IF3 	; UNCONDITIONAL BRANCH
00476    2111  20 BC 25     IFXCT     JSR GETLNS	; GO GET THE LINE NUMBER
00477    2114  08                     PHP		; SAVE PROCESSOR FLAGS
00478    2115  20 FE 26               JSR EATECM	; NOW EAT UNTIL THE END OF A COMMAND
00479    2118  28                     PLP		; GET FLAGS BACK
00480    2119  70 0B                  BVS IFNOP	; BRANCH IF NO LINE NUMBER GIVEN
00481    211B  08                     PHP		; SAVE THEM AGAIN
00482    211C  A5 23                  LDA IFONSW	;   is 'JSR POPA' in orig.
00483    211E  C9 4F                  CMP #$4F	; 'O'
00484    2120  F0 07                  BEQ IFDO1	; YES, GO 'DO' THE LINE
00485    2122  28                     PLP		; ADJUST STACK
00486    2123  4C F5 22               JMP GOTO1	; NO, 'IF' CMD, THEN 'GOTO' LINE
00487    2126  4C 02 23     IFNOP     JMP PROC	; ADJUST STACK (then 'JMP PROC' in orig...)
00488    2129  68           IFDO1     PLA		; GET STATUS SAVED AFTER 'GETLN' CALL
00489    212A  AA                     TAX 		; SAVE IN THE X REGISTER
00490    212B  20 1C 28               JSR PUSHJ	; NOW PERFORM THE 'DO' OF THE LINE OR GROUP
00491              .WORD DO1	; $21B6
00492    2130  4C 02 23               JMP PROC	; AND THEN CONTINUE PROCESSING ON THIS LINE
00493    
00494      20C7             IF     = ON		; BOTH COMMANDS HAVE COMMON ENTRY POINT
00495    
00496    ; MODIFY CMD PROCESSOR: 'MODIFY' A LINE OF THE USER'S PROGRAM
00497    
00498    2133  20 BC 25     MODIFY    JSR GETLNS	; GET THE LINE NUMBER SPECIFIED
00499    2136  70 02                  BVS BADMOD	; BRANCH IF 00.00
00500    2138  D0 02                  BNE MODNOK	; BRANCH IF GG.LL
00501    213A  00           BADMOD    BRK		; TRAP
00502         	 .BYTE MNEXL	; ?MODIFY OF NON-EXISTANT LINE (#$E4)
00503    213C  20 80 26     MODNOK    JSR FINDLN	; TRY TO FIND THE LINE
00504    213F  90 F9                  BCC BADMOD	; BRANCH IF COULD NOT FIND
00505    2141  20 99 2D            	  JSR CRLF	; OUTPUT A BLANK LINE
00506    2144  20 31 26               JSR PRNTLN	; PRINT THE LINE NUMBER
00507    2147  A0 02                  LDY #$02	; SET OFFSET TO FIRST CHAR ON LINE
00508    2149  84 35                  STY TEXTP2
00509    214B  A9 00                  LDA #$00
00510    214D  85 28                  STA TXTADR	; INIT POINTERS TO COMBUF
00511    214F  85 2A                  STA TEXTP	; 
00512    2151  A9 01                  LDA #$01
00513    2153  85 29                  STA TXTADR+1
00514    2155  20 B0 28     MNXTC     JSR RNOECH	; GO WAIT FOR THE GUY TO TYPE A CHAR
00515    2158  C9 0A                  CMP #$0A	; LINE FEED?
00516    215A  F0 25                  BEQ MLOOK1	; YES, THEN GO FEED TO END OF LINE
00517    215C  C5 1B                  CMP ALTCHR	; ALTMODE?
00518    215E  F0 1E                  BEQ MLOOK	; YES, THEN PICK UP SEARCH CHAR
00519    2160  C5 7F                  CMP RUBCHR	; RUBOUT
00520    2162  F0 07                  BEQ MNOECH	; YES, THEN DON'T ECHO
00521    2164  C5 5F                  CMP LINCHR	; WAS CHAR THE 'LINE-DELETE' CHAR?
00522    2166  F0 03                  BEQ MNOECH	; BRANCH IF IT IS, DO NOT ECHO
00523    2168  20 02 29               JSR PRINTC	; ECHO THE CHARACTER
00524    216B  20 2D 29     MNOECH    JSR PACKC1	; PACK CHAR INTO COMBUF
00525    216E  C9 0D                  CMP #$0D	; WAS CHAR A CARRIAGE RETURN?
00526    2170  D0 E3                  BNE MNXTC	; NO, THEN PICK UP NEXT CNE
00527    2172  20 9E 2D     MENDL     JSR OUTLF	; FOLLOW WITH A LINE FEED
00528    2175  A9 01                  LDA #$01	; SET COMBUF OFFSET
00529    2177  85 2A                  STA TEXTP	; FOR 'INSERT'
00530    2179  E6 20                  INC DEBGSW	; DISABLE TRACE FOR INSERT
00531    217B  4C 7C 20               JMP REPLIN	; AND GO REPLACE OLD LINE WITH EDITED LINE
00532    
00533    217E  20 B0 28     MLOOK     JSR RNOECH	; SILENTLY GET THE SEARCH CHAR
00534    2181  85 25        MLOOK1    STA MSCHAR	; STORE SEARCH CHAR
00535    2183  A4 35        MLOOK2    LDY TEXTP2	; GET POINTER TO TEXT IN MEMORY
00536    2185  B1 33                  LDA (TXTAD2),Y	; GET CHAR
00537    2187  C8                     INY		; POINT TO NEXT
00538    2188  84 35                  STY TEXTP2	; 
00539    218A  20 2D 29               JSR PACKC1	; PACK THE CHAR
00540    218D  20 02 29               JSR PRINTC	; ECHO IT
00541    2190  C5 25                  CMP MSCHAR	; WAS IT THE SEARCH CHAR?
00542    2192  F0 C1                  BEQ MNXTC	; BRANCH IF YES
00543    2194  C9 0D                  CMP #$0D	; CR?
00544    2196  F0 DA                  BEQ MENDL	; YES, THEN THAT'S IT
00545    2198  D0 E9                  BNE MLOOK2	; NO, THEN KEEP LOOKING
00546    ;
00547    ;        'DO' RECURSIVE OPERATE, EXECUTE, OR CALL
00548    ;
00549    219A  20 1C 28     DO        JSR PUSHJ	; CALL THE 'DO' SUBROUTINE
00550              .WORD DOX	; $21A2
00551    219F  4C 02 23               JMP PROC	; AND CONTINUE PROCESSING
00552    21A2  A9 00        DOX       LDA #$00	; ZERO OUT THE STRING VARIABLE SWITCH
00553    21A4  85 3B                  STA STRSWT
00554    21A6  20 BC 25               JSR GETLNS	; GO GET THE LINE NUMBER TO 'DO'
00555    21A9  08                     PHP		; SAVE FLAGS FROM 'GETLNS'
00556    21AA  A5 3B                  LDA STRSWT	; WAS EXPRESSION A STRING VARIABLE?
00557    21AC  F0 04                  BEQ DOX1	; BRANCH IF NOT, PRESS ON
00558    21AE  28                     PLP		; YES, THEN ADJUST STACK
00559    21AF  4C 97 20               JMP DOSTR	; * PJMP * DO CODE STORED IN STRING, RET
00560    21B2  28           DOX1      PLP		; RESTORE FLAGS FROM 'GETLNS'
00561    21B3  4C B9 21               JMP DO2	;   AND ENTER ROUTINE
00562    21B6  8A           DO1       TXA		; ENTER HERE WITH STATUS FROM 'GETLN' IN X
00563    21B7  48                     PHA		; SAVE ON STACK
00564    21B8  28                     PLP		; MAKE CURRENT PROCESSOR STATUS
00565    21B9  08           DO2       PHP		; SAVE PROCESSOR STATUS ACROSS THE SAVE
00566    21BA  20 B9 20               JSR PUSHDO	; SAVE IMPORTANT STUFF ON STACK FOR LATER
00567    21BD  28                     PLP		; GET THE FLAGS BACK
00568    21BE  70 17                  BVS DOGRP	; BRANCH IF "DO ALL"
00569    21C0  F0 15                  BEQ DOGRP	; OR "DO" IS A GROUP
00570    21C2  20 80 26     DOONE     JSR FINDLN	; TRY TO FIND THE LINE TO "DO"
00571    21C5  B0 02                  BCS DOCNT1	; BRANCH IF WE FOUND IT
00572    21C7  00                     BRK		; TRAP
00573             .BYTE DONEXL	; ?"DO" OF NON-EXISTANT LINE (#$E6)
00574    21C9  20 25 27     DOCNT1    JSR NEWLIN	; SET UP THE NEW LINE
00575    21CC  20 1C 28               JSR PUSHJ	; AND EXECUTE IT
00576              .WORD PROCES	; $22FF
00577    21D1  20 C0 20     DOCONT    JSR POPDO	; NOW RESTORE IMPORTANT STUFF AS IT WAS
00578    21D4  20 4B 28               JSR POPJ	; AND RETURN
00579    ;
00580    ;        'DO' COMMAND PROCESSOR
00581    ;
00582    21D7  20 80 26     DOGRP     JSR FINDLN	; TRY TO LOCATE SMALLEST LINE OF THE GRP
00583    21DA  A5 51                  LDA TGRP	; IS IT THE SAME GRP WE'RE LOOKING FOR?
00584    21DC  C5 2C                  CMP GRPNO     
00585    21DE  F0 02                  BEQ DOGRP1	; BRANCH IF YES
00586    21E0  00                     BRK	; TRAP
00587             .BYTE DONEXG	; ?"DO" OF NON-EXISTANT GROUP (#$E5)
00588    21E2  A5 51        DOGRP1    LDA TGRP	; GET THE GROUP NUMBER WE ARE 'DO'ING
00589    21E4  20 31 28               JSR PUSHA	; SAVE ON STACK
00590    21E7  20 32 27     DOGRPC    JSR NXTLIN	; SET UP POINTERS FOR NEXT LINE
00591    21EA  90 1C                  BCC ENDGRP	; BRANCH IF END OF PROGRAM
00592    21EC  20 3F 28               JSR POPA	; GET GROUP NUMBER WE ARE 'DO'ING
00593    21EF  20 31 28               JSR PUSHA	; SAVE IT AGAIN
00594    21F2  09 00                  ORA #$00	; ARE WE DOING GROUP ZERO (ALL)?
00595    21F4  F0 04                  BEQ DONEXT	; YES, THEN ANY LINE IS OK
00596    21F6  C5 26                  CMP PC	; IS THIS LINE OF THE SAME GROUP?
00597    21F8  D0 0E                  BNE ENDGRP	; BRANCH IF NOT
00598    21FA  20 1C 28     DONEXT    JSR PUSHJ	; YES, THEN PROCESS THIS LINE
00599              .WORD PROCES	; $22FF
00600    21FF  20 D7 26               JSR EATCR1	; EAT UNTIL A CARRIAGE RETURN
00601    2202  A5 26                  LDA PC	; GET THE CURRENT LINE NUMBER
00602    2204  C5 FD                  CMP RETCMD	; 'RETURN' COMMAND SEEN?
00603    2206  D0 DF                  BNE DOGRPC	; BRANCH IF NOT, CONTINUE
00604    2208  20 3F 28     ENDGRP    JSR POPA	; ADJUST STACK
00605    220B  4C D1 21               JMP DOCONT	; AND RETURN FROM "DO"
00606    
00607    ; "RETURN" AND "RESTORE" COMMANDS
00608    
00609    220E  20 B4 29     RETURN    JSR SPNOR	; GET NEXT NON-BLANK
00610    2211  C9 49                  CMP #$49	; 'I' IS THIS A 'RESTORE INPUT' (R I)?
00611    2213  F0 0B                  BEQ RESINP	; BRANCH IF YES
00612    2215  C9 4F                  CMP #$4F	; 'O' IS THIS A 'RESTORE OUTPUT' (R O)?
00613    2217  F0 0E                  BEQ RESOUT	; BRANCH IF YES
00614    2219  A9 FD                  LDA #RETCMD	; NO, THEN IT MUST BE A "RETURN"
00615    221B  85 26                  STA PC	; SET PC TO SPECIAL VALUE
00616    221D  20 4B 28               JSR POPJ	; AND EXIT "PROCESS"
00617    
00618    2220  A5 68        RESINP    LDA IDVSAV	; RESTORE INPUT DEVICE # TO WHAT IT WAS
00619    2222  85 66                  STA IDEV	;   BEFORE LAST STRING INPUT
00620    2224  4C FF 22               JMP PROCES	;   AND CONTINUE EXECUTING ON THIS LINE
00621    2227  A5 69        RESOUT    LDA ODVSAV	; RESTORE OUTPUT DEVICE # TO WHAT IT WAS
00622    2229  85 67                  STA ODEV	;   BEFORE LAST STRING OUTPUT
00623    222B  4C FF 22               JMP PROCES	;   AND CONTINUE EXECUTING ON THIS LINE
00624    
00625    ; "ERASE" COMMAND PROCESSOR
00626    
00627    222E  20 B4 29     ERASE     JSR SPNOR	; GO GET NEXT NON-BLANK
00628    2231  A0 00                  LDY #$00	; this is not in the 6502 Group/ProgExch
00629    2233  C9 41                  CMP #$41	; 'A'   source code of 13-Oct-77   --dhh
00630    2235  F0 23                  BEQ EALL	;       occurs later at $225A
00631    2237  20 BF 25               JSR GETLN	; NO, GO GET THE LINE NUMBER TO ERASE
00632    223A  08                     PHP		; SAVE FLAGS
00633    223B  20 0A 27               JSR PUSHTP	; SAVE TEXT POINTERS
00634    223E  28                     PLP		; GET FLAGS BACK
00635    223F  70 0F                  BVS EVAR	; BRANCH IF JUST 'ERASE' WITH NO LINE NO.
00636    2241  F0 2C                  BEQ EGRP	; BRANCH IF WE ERASE A GROUP
00637    2243  20 80 26               JSR FINDLN	; NOW TRY AND LOCATE THE SPECIFIED LINE
00638    2246  B0 02                  BCS ERCONT	; BRANCH IF WE FOUND IT
00639    2248  00                     BRK	; TRAP
00640              .BYTE ENEXL	; ?ERASE OF NON-EXISTANT LINE (#$E8)
00641    224A  20 4B 27     ERCONT    JSR DELETE	; GO ZAP THE LINE
00642    224D  4C 31 20     ERDON     JMP START	; AND GO TO DIRECT COMMAND MODE
00643    2250  A9 FF        EVAR      LDA #EOV	; ERASE ALL THE VARIABLES
00644    2252  91 3E                  STA (VARBEG),Y	; BY FLAGGING LIST AS EMPTY
00645    2254  20 11 27               JSR POPTP	; RESTORE TEXT POINTERS
00646    2257  4C 02 23               JMP PROC	; AND CONTINUE PROCESSING THIS LINE
00647    225A  A9 FE        EALL      LDA #EOP	; ERASE PROGRAM TEXT
00648    225C  91 31                  STA (PBADR),Y	; EXCEPT GROUP ZERO
00649    225E  A5 40                  LDA VARST	; UPDATE VARBEG
00650    2260  85 3E                  STA VARBEG
00651    2262  A5 41                  LDA VARST+1
00652    2264  85 3F                  STA VARBEG+1
00653    2266  A9 FF                  LDA #EOV
00654    2268  91 3E                  STA (VARBEG),Y	; FLAG VARIABLE LIST AS EMPTY
00655    226A  D0 E1                  BNE ERDON	; AND START OVER
00656    226C  20 4B 27     ELINE     JSR DELETE	; DELETE THE LINE
00657    226F  20 18 27     EGRP      JSR TXTINI	; RESET TEXT POINTER TO START OF PROGRAM
00658    2272  20 80 26               JSR FINDLN	; TRY TO FIND THE GROUP
00659    2275  A5 51                  LDA TGRP	; GET GROUP NUMBER OF LINE FOUND
00660    2277  C5 2C                  CMP GRPNO     ; IS IT OF THE GROUP WE ARE DELETING?
00661    2279  F0 F1                  BEQ ELINE     ; BRANCH IF YES, GO DELETE IT
00662    227B  D0 D0                  BNE ERDON     ; AND RETURN IF ALL LINES IN GRP DELETED
00663    
00664    ; WRITE CMD PROCESSOR: 'WRITE' OUT PARTS OF THE PROGRAM TEXT
00665    
00666    227D  20 BC 25     WRITE     JSR GETLNS	; GO GET THE GROUP TO WRITE
00667    2280  08                     PHP		; SAVE CONDITION CODES
00668    2281  20 0A 27               JSR PUSHTP	; SAVE POSITION ON THIS LINE
00669    2284  E6 20                  INC DEBGSW	; DISABLE TRACE
00670    2286  28                     PLP		; GET CONDITION CODES AFTER 'GETLN'
00671    2287  70 2B                  BVS WALL	; BRANCH IF 'WRITE ALL'
00672    2289  D0 19                  BNE WLINE	; BRANCH IF WE WRITE A SINGLE LINE
00673    228B  20 80 26     WGRP      JSR FINDLN	; TRY TO FIND THE GROUP
00674    228E  A5 51                  LDA TGRP	; GET THE GROUP LOCATED IN MEMORY
00675    2290  C5 2C                  CMP GRPNO	; IS IT THE ONE WE ARE LOOKING FOR?
00676    2292  F0 02                  BEQ WGRP1	; BRANCH IF YES     
00677    2294  00                     BRK		; TRAP
00678              .BYTE WNEXG	; ?'WRITE' OF NON-EXISTANT GROUP (#$E1)
00679    2296  20 C0 22     WGRP1     JSR WGRPO	; OUTPUT THE GROUP
00680    2299  20 EB 22     WEXIT     JSR WCRLF	; BLANK LINE
00681    229C  C6 20                  DEC DEBGSW	; ENABLE TRACE AGAIN
00682    229E  20 11 27               JSR POPTP	; RESTORE TEXT POINTERS
00683    22A1  4C 02 23               JMP PROC	;   AND CONTINUE PROCESSING ON THIS LINE
00684    22A4  20 80 26     WLINE     JSR FINDLN	; TRY TO FIND THE LINE
00685    22A7  B0 02                  BCS WLINE1	; BRANCH IF WE FOUND IT
00686    22A9  00                     BRK		; TRAP
00687              .BYTE WNEXL	; ?'WRITE' OF NON-EXISTANT LINE (code #$EA)
00688    22AB  20 EB 22     WLINE1    JSR WCRLF	; OUTPUT BLANK LINE
00689    22AE  20 CD 22               JSR WONE	; OUTPUT THE SINGLE LINE
00690    22B1  4C 99 22               JMP WEXIT	;   THEN EXIT 'WRITE' 
00691    22B4  20 80 26     WALL      JSR FINDLN	; GO FIND GROUP ZERO (ALWAYS WINS)
00692    22B7  20 C0 22     WALL1     JSR WGRPO	; OUTPUT THIS GROUP
00693    22BA  F0 DD                  BEQ WEXIT	; BRANCH IF END OF PROGRAM
00694    22BC  85 51                  STA TGRP	; MAKE EXIT GROUP THE GROUP TO OUTPUT
00695    22BE  D0 F7                  BNE WALL1	;    AND GO OUTPUT IT
00696    22C0  20 EB 22     WGRPO     JSR WCRLF	; OUTPUT BLANK LINE
00697    22C3  20 CD 22     WGRPO1    JSR WONE	; OUTPUT THIS LINE
00698    22C6  F0 04                  BEQ WEXGRP	; BRANCH IF END OF PROGRAM
00699    22C8  C5 51                  CMP TGRP	; IS GROUP OF NEXT LINE THE SAME?
00700    22CA  F0 F7                  BEQ WGRPO1	; BRANCH IF YES
00701    22CC  60           WEXGRP    RTS		; OTHERWISE RETURN
00702    ;
00703    22CD  20 31 26     WONE      JSR PRNTLN	; OUTPUT THE LINE NUMBER
00704    22D0  20 92 29     WONEC     JSR GETC	; GET NEXT CHAR
00705    22D3  20 02 29               JSR PRINTC	; OUTPUT IT
00706    22D6  C9 0D                  CMP #$0D	; WAS IT THE END OF THE LINE?
00707    22D8  D0 F6                  BNE WONEC	; LOOP IF NOT
00708    22DA  A5 67                  LDA ODEV	; YES, ARE WE OUTPUTTING TO A STRING?
00709    22DC  30 03                  BMI WEOL	; BRANCH IF WE ARE, DON'T FOLLOW WITH $0A
00710    22DE  20 9E 2D               JSR OUTLF	; NO, THEN FOLLOW WITH A LINEFEED
00711    22E1  20 D7 26     WEOL      JSR EATCR1	; YES, POINT TO NEXT LINE
00712    22E4  A4 2A                  LDY TEXTP	; LOAD Y WITH OFFSET
00713    22E6  B1 28                  LDA (TXTADR),Y	; PICK OF GRP NUMBER OF NEXT LINE
00714    22E8  C9 FE                  CMP #EOP	; COMPARE TO END-OF-PROGRAM FLAG
00715    22EA  60           WRET      RTS		; RETURN WITH Z=1 IF END OF PROGRAM
00716    			; RETURN WITH Z=0 IF NOT END OF PROGRAM
00717    22EB  A5 67        WCRLF     LDA ODEV	; ARE WE OUTPUTTING TO A STRING?
00718    22ED  30 FB                  BMI WRET	; BRANCH IF WE ARE, DON'T ADVANCE
00719    22EF  4C 99 2D               JMP CRLF	; * PJMP * ELSE OUTPUT A CRLF AND RETURN
00720    
00721    ; MAIN CONTROL AND TRANSFER: 'GOTO' COMMAND
00722    
00723    22F2  20 BC 25     GOTO      JSR GETLNS	; GO GET THE LINE NUMBER
00724    22F5  20 80 26     GOTO1     JSR FINDLN	; NOW GO TRY TO FIND IT
00725    22F8  B0 02                  BCS GCONT	; BRANCH IF WE FOUND IT
00726    22FA  00                     BRK	; TRAP
00727              .BYTE $EB	; ?GOTO NON-EXISTANT LINE
00728    22FC  20 25 27     GCONT     JSR NEWLIN	; GO SET UP THE NEW LINE
00729                            ; * PFALL * INTO PROCESS
00730    22FF  20 92 29     PROCES    JSR GETC	; GET NEXT CHARACTER
00731    2302  A5 2B        PROC      LDA CHAR	; JUST IN CASE CALLED FROM ELSEWHERE
00732    2304  C9 0D                  CMP #$0D	; 'CR' END OF LINE?
00733    2306  F0 5B                  BEQ PC1	; IF SO, THEN RETURN
00734    2308  20 52 23               JSR GLTEST	; IS CHAR A TERMINATOR?
00735    230B  F0 F2                  BEQ PROCES	; IF SO, IGNORE IT
00736    230D  A6 2E                  LDX PRILVL	; GET CURRENT SOFTWARE INTERRUPT PRIO LVL
00737    230F  A5 6D                  LDA ACTMSK	; GET BYTE THAT INDICATES WHICH CHAN ACTIVE
00738    2311  F0 13                  BEQ PROC1	; NONE ALLOWED TO HAPPEN, PRESS ON
00739    2313  3D 9D 35               AND $359D,X	; MASK OUT ANY NOT ALLOWED TO HAPPEN
00740    2316  F0 0E                  BEQ PROC1	; BRANCH IF NONE PENDING, PRESS ON
00741    2318  25 6E                  AND EVMASK	; NOW SEE IF ANY EVENT PENDING ON CHANNEL
00742    231A  F0 0A                  BEQ PROC1	; BRANCH IF NONE PENDING, PRESS ON
00743    231C  A2 08                  LDX #$08	; WE HAVE AN EVENT TO SERVICE (AT LEAST 1)
00744    231E  DD A6 35     PRILOP    CMP BITTAB,X	; FIND HIGHEST PRIORITY ONE TO SERVICE
00745    2321  B0 43                  BCS EVNTDO	; BRANCH WHEN WE HAVE IT
00746    2323  CA                     DEX		; NOT THIS LEVEL, TRY LOWER
00747    2324  D0 F8                  BNE PRILOP	;   AND LOOP UNTIL WE FIND IT
00748    			; *** SHOULD NEVER FALL OUT THIS END! ***
00749    2326  A5 2B        PROC1     LDA CHAR	; GET CHARACTER WHICH STARTED COMMAND
00750    			;          handwritten note here in ProgExch code:
00751    			;                 " --* JMP EXIT" 
00752    2328  48                     PHA		; TEMPORARILY SAVE COMMAND CHARACTER
00753    2329  20 52 23     PTERM1    JSR GLTEST	; TERMINATOR?
00754    232C  F0 05                  BEQ PTERM2	; BRANCH IF YES
00755    232E  20 92 29               JSR GETC	; OTHERWISE, SKIP OVER REST OF COMMAND NAME
00756    2331  10 F6                  BPL PTERM1	; UNCONDITIONAL BRANCH
00757    2333  68           PTERM2    PLA		; GET 1ST CHAR OF CMD NAME BACK AGAIN
00758    2334  A2 00                  LDX #$00	; INIT TABLE OFFSET TO ZERO
00759    2336  BC 49 35     NXTCOM    LDY COMTAB,X	; GET THE COMMAND CHARACTER
00760    2339  F0 26                  BEQ ILLCOM	; ZERO ENDS THE TABLE
00761    233B  DD 49 35               CMP COMTAB,X	; IS THIS CHARACTER THE COMMAND WE WANT?
00762    233E  F0 03                  BEQ GOTCOM	; BRANCH IF YES
00763    2340  E8                     INX		; NO, POINT TO NEXT ONE
00764    2341  D0 F3                  BNE NXTCOM	; UNCONDITIONAL LOOP FOR NEXT ONE
00765    2343  BC 6F 35     GOTCOM    LDY COMADL,X	; GET LOW ORDER ADDR OF ROUTINE
00766    2346  8C 50 23               STY $2350     ; SAVE IN DUMMY JUMP (below)
00767    2349  BC 5D 35               LDY COMADH,X	; GET HIGH ORDER ADDR OF ROUTINE
00768    234C  8C 51 23               STY $2351     ; SAVE IN DUMMY JUMP (next)
00769    234F  4C 00 00               JMP $0000     ; DISPATCH TO COMMAND ROUTINE
00770    
00771    ; GLTEST EXITS WITH Z SET IF CHARACTER IN THE ACCUMULATOR
00772    ; IS A TERMINATOR (SPACE, COMMA, OR SEMI-COLON).
00773    
00774    2352  C9 20        GLTEST    CMP #$20	; SPACE?
00775    2354  F0 0A                  BEQ RTS2	; RETURN IF YES
00776    2356  C9 2C                  CMP #$2C	; COMMA?
00777    2358  F0 06                  BEQ RTS2	; RETURN IF YES
00778    235A  C9 3B        TSTEOC    CMP #$3B	; SEMI-COLON?
00779    235C  F0 02                  BEQ RTS2	; RETURN IF YES
00780    235E  C9 0D                  CMP #$0D	; CARRIAGE RETURN?
00781    2360  60           RTS2      RTS		; RETURN WITH Z=1 IF ANY OF THESE
00782    2361  00           ILLCOM    BRK		; TRAP
00783              .BYTE $FD	; ?UNRECOGNIZABLE COMMAND
00784    2363  20 4B 28     PC1       JSR POPJ	; EXIT 'PROCESS'
00785      2363             COMMNT = PC1
00786    
00787    ; ROUTINE TO PERFORM A 'DO' OF A SPECIFIED LINE OR GROUP
00788    ; WHEN AN EXTERNAL EVENT HAPPENS ON A SOFTWARE INTERRUPT CHANNEL.
00789    
00790    2366  8A           EVNTDO    TXA		; SAVE X AS IT HAS LVL OF INTERUPT
00791    2367  48                     PHA		;   THEN SET UP RETURN ADDR ON STACK
00792    2368  A9 0C                  LDA #$0C	; label EVRET, def. as =PROCX-1
00793    236A  20 31 28               JSR PUSHA	; ALA 'PUSHJ'
00794    236D  A9 23                  LDA #$23	; MSB of EVRET address
00795    236F  20 31 28               JSR PUSHA
00796    2372  20 B9 20               JSR PUSHDO	; SAVE IMPORTANT STUFF AT THIS LEVEL
00797    2375  68                     PLA		; GET NEW PRIO LEVEL OF GRP OR LN TO 'DO'
00798    2376  AA                     TAX
00799    2377  86 2E                  STX PRILVL	; SET IT AS OUT NEW PRIO LEVEL
00800    2379  BD A6 35               LDA BITTAB,X	; GET BIT MASK FOR THIS NEW LEVEL
00801    237C  49 FF                  EOR #$FF	; COMPLIMENT TO MAKE 'AND' MASK
00802    237E  08                     PHP		; SAVE STATE OF 'I' BIT IN CASE IRQS ARE ON
00803    237F  78                     SEI		; DISABLE IRQ GRANTING
00804    2380  25 6E                  AND EVMASK	;   WHILE WE UPDATE EVENT MASK
00805    2382  85 6E                  STA EVMASK
00806    2384  28                     PLP		; WE CAN ALLOW IRQS AGAIN (IF ON)
00807    2385  BD 8B 35               LDA INTGRP,X	; GET THE GROUP NUMBER TO 'DO'
00808    2388  85 2C                  STA GRPNO
00809    238A  BD 94 35               LDA INTLIN,X	;   AND THE LINE NUMBER
00810    238D  85 2D                  STA LINENO
00811    238F  20 05 26               JSR GOTLNO	; NOW SET FLAGS TO DETERMINE WHAT TO 'DO'
00812    2392  70 05                  BVS EVDALL	; BRANCH IF WE ARE 'DO'ING ALL
00813    2394  F0 03                  BEQ EVDALL	;   OR 'DO' OF A GROUP
00814    2396  4C C2 21               JMP DOONE	; *PJMP * 'DO' 1 LINE, RETURN TO 'EVRET'
00815    2399  4C D7 21     EVDALL    JMP DOGRP	; *PJMP * 'DO' A GROUP, RETURN TO 'EVRET'
00816    ;
00817    ; 'TYPE - ASK COMMAND PROCESSOR'
00818    ;
00819    239C  20 76 2C     TDUMP     JSR VARINI	; INIT POINTER TO START OF VARIABLE LIST
00820    239F  20 99 2D     TDNEXT    JSR CRLF	; START ON NEW LINE
00821    23A2  A0 00                  LDY #$00	; POINT TO VARIABLE NAME
00822    23A4  84 3B                  STY STRSWT	; MAKE SURE STRING SWITCH IS OFF
00823    23A6  B1 37                  LDA (VARADR),Y	; PICK UP THE VARIABLE NAME
00824    23A8  C9 FF                  CMP #EOV	; END OF VARIABLE LIST?
00825    23AA  F0 52                  BEQ JTASK4	; BRANCH IF END OF VARIABLE LIST
00826    23AC  C9 FC                  CMP #STRMRK	; STRING VARIABLE?
00827    23AE  D0 05                  BNE TDCONT	; BRANCH IF NOT, PRESS ON
00828    23B0  85 3B                  STA STRSWT	; YES, THEN FLAG IT
00829    23B2  C8                     INY		;   AND MOVE PAST MARKER, POINT TO NAME
00830    23B3  B1 37                  LDA (VARADR),Y	; AND PICK UP THE NAME
00831    23B5  20 E7 23     TDCONT    JSR PRTVNM	; PRINT THE VARIABLE'S NAME
00832    23B8  A5 3B                  LDA STRSWT	; IS THIS VARIABLE A STRING VARIABLE?
00833    23BA  D0 45                  BNE TPSTR	; BRANCH IF YES, DO SPECIAL OUTPUT
00834    23BC  A9 28                  LDA #$28	; '(' AND THEN START OF SUBSCRIPT
00835    23BE  20 02 29               JSR PRINTC
00836    23C1  A0 01                  LDY #$01	; POINT TO SUBSCRIPT
00837    23C3  B1 37                  LDA (VARADR),Y	; GET HIGH ORDER SUBSCRIPT
00838    23C5  85 81                  STA M1	; SAVE IN FAC1
00839    23C7  C8                     INY		; POINT TO LOW ORDER SUBSCRIPT
00840    23C8  B1 37                  LDA (VARADR),Y	; GET IT
00841    23CA  85 82                  STA M1+1
00842    23CC  20 4D 32               JSR FLT16	; FORM A FLOATING POINT NUMBER
00843    23CF  20 5E 26               JSR OUTLN0	;   AND OUTPUT IT
00844    23D2  A9 29                  LDA #$29	; ')' CLOSING PAREN
00845    23D4  20 02 29               JSR PRINTC
00846    23D7  A9 3D                  LDA #$3D	; '=' PUT IN AN EQUALS FOR FORM
00847    23D9  20 02 29               JSR PRINTC
00848    23DC  20 AE 2C               JSR FETVAR	; GET THE VARIABLE'S VALUE INTO FLAC
00849    23DF  20 1F 33               JSR FPRNT	; PRINT IT
00850    23E2  20 7F 2C               JSR NXTVAR	; POINT TO NEXT VARIABLE IN THE LIST
00851    23E5  D0 B8                  BNE TDNEXT	; UNCONDITIONALLY LOOP FOR MORE
00852    ;
00853    ; ROUTINE TO PRINT OUT A VARIABLE'S NAME
00854    ;
00855    23E7  48           PRTVNM    PHA		; SAVE COMPOSITE FORM
00856    23E8  4A                     LSR  		; EXTRACT ALPHA PART
00857    23E9  4A                     LSR  
00858    23EA  4A                     LSR  
00859    23EB  09 40                  ORA #$40	; FORM ASCII
00860    23ED  C9 46                  CMP #$46	; 'F', ACTUALLY '&', SINCE 'F' IS ILLEGAL
00861    23EF  D0 02                  BNE TPNAM	; NOT SPECIAL, SO PRINT IT
00862    23F1  A9 26                  LDA #$26	; '&' PRINT A '&' AS SPECIAL VARIB NAME
00863    23F3  20 02 29     TPNAM     JSR PRINTC	;   AND PRINT IT
00864    23F6  68                     PLA		; GET BACK HASH
00865    23F7  29 07                  AND #$07	; EXTRACT NUMBER
00866    23F9  09 30                  ORA #$30	; FORM ASCII
00867    23FB  4C 02 29               JMP PRINTC	; * PJMP * PRINT THE VARIB # THEN RETURN
00868    23FE  4C D3 24     JTASK4    JMP TASK4	; BRANCH AID
00869    ; *** BEGIN MIKE B'S SECTION
00870    
00871                            ;
00872            ; HERE TO TYPE OUT A STRING VARIABLE
00873                            ;
00874    2401  A9 24        TPSTR   LDA #$24        ; '$' INDICATE IT'S A STRING VARIABLE
00875    2403  20 02 29             JSR PRINTC      ;
00876    2406  A9 3D                LDA #$3D        ; '=' DON'T PRINT A SUBSCRIPT ON A $ VARIB
00877    2408  20 02 29             JSR PRINTC      ;
00878    240B  A9 22                LDA #$22        ; '"' DELIMIT STRING WITH QUOTES
00879    240D  20 02 29             JSR PRINTC      ;
00880    2410  A0 02                LDY #$02        ; POINT TO STRING LENGTH
00881    2412  B1 37                LDA (VARADR),Y  ; PICK UP THE STRING LENGTH
00882    2414  85 3C                STA VSIZE       ; SAVE IT
00883    2416  C8                   INY             ; POINT TO FIRST BYTE OF STRING
00884    2417  98                   TYA             ; NOW UPDATE 'VARADR' TO BASE ADDR OF $
00885    2418  20 81 2C             JSR UPDVAR      ;
00886    241B  A0 00                LDY #$00        ; POINT TO FIRST BYTE OF STRING
00887    241D  98           TPNXTC  TYA             ; SAVE OFFSET
00888    241E  48                   PHA             ;
00889    241F  B1 37                LDA (VARADR),Y  ; GET BYTE FROM STRING
00890    2421  20 02 29             JSR PRINTC      ; PRINT THE BYTE
00891    2424  68                   PLA             ; RESTORE POINTER
00892    2425  A8                   TAY             ;
00893    2426  C8                   INY             ; POINT TO NEXT BYTE
00894    2427  C4 3C                CPY VSIZE       ; PRINTED ALL OF STRING YET?
00895    2429  D0 F2                BNE TPNXTC      ; BRANCH IF MORE TO PRINT
00896    242B  98                   TYA             ; YES, THEN SKIP OVER STRING BY
00897    242C  20 81 2C             JSR UPDVAR      ;   UPDATING 'VARADR'
00898    242F  A9 22                LDA #$22        ; '"' CLOSE OFF STRING WITH CLOSING QUOTE
00899    2431  20 02 29             JSR PRINTC      ;
00900    2434  4C 9F 23             JMP TDNEXT      ; AND DUMP NEXT VARIABLE
00901                            ;
00902    2437  4C 9C 23     JTDUMP  JMP TDUMP       ; BRANCH AID
00903                            ;
00904            ; 'TYPE - ASK COMMAND PROCESSOR'
00905                            ; 
00906    243A  20 1C 28     TASK1   JSR PUSHJ       ; GO GET THE VARIABLE
00907            .WORD GETVAR    ; ($1B43 in ww -- mtb)
00908    243F  20 9B 2C             JSR BOMSTV      ; BOMB OUT IF A $ VARIABLE IS USED IN 'ASK'
00909    2442  A5 2B                LDA CHAR        ; SAVE DELIMITER
00910    2444  48                   PHA             ;   ON HARDWARE STACK
00911    2445  E6 24                INC INSW        ; FLAG INPUT FROM KEYBOARD
00912    2447  A2 37        ASKAGN  LDX #VARADR     ; SAVE THE VARIABLE'S ADDRESS
00913    2449  20 69 28             JSR PUSHB2      ;
00914    244C  20 1C 28             JSR PUSHJ       ; NOW GO GET USER SUPPLIED DATA
00915            .WORD EVALM1    ; ($19F5 in ww -- mtb)
00916                            ;
00917    ;        LDA #$41        ; RESTORE 'ATSW' (SINCE WE MUST BE RECURSIVE!)
00918    ;        STA ATSW        ; (in ww -- mtb)
00919    2451  A2 38                LDX #VARADR+1   ; RESTORE VARIABLE'S ADDRESS
00920    2453  20 59 28             JSR POPB2       ;
00921    2456  A5 2B                LDA CHAR        ; GET DELIMITER FROM EVAL
00922    2458  C9 5F                CMP #LINCHR     ; WAS IT 'LINE-DELETE' CHARACTER?
00923    245A  D0 0B                BNE STODAT      ; BRANCH IF NOT, STORE VALUE AWAY
00924    245C  A5 66                LDA IDEV        ; YES, IS THE INPUT DEVICE
00925    245E  C5 6A                CMP CONDEV      ;   THE CONSOLE?
00926    2460  D0 E5                BNE ASKAGN      ; BRANCH IF NOT, ASK AGAIN
00927    2462  20 99 2D             JSR CRLF        ; YES, ADVANCE A LINE
00928    2465  10 E0                BPL ASKAGN      ;   AND ASK AGAIN
00929    2467  20 A1 2C     STODAT  JSR PUTVAR      ; PLACE DATA IN VARIABLE
00930    246A  C6 24                DEC INSW        ; FLAG INPUT FROM CORE AGAIN
00931    246C  68                   PLA             ; GET DELIMITER BACK AGAIN
00932    246D  85 2B                STA CHAR        ;
00933    246F  10 13                BPL TASK        ; UNCONDITIONALLY CONTINUE PROCESSING
00934                            ;
00935    2471  20 92 29     TFORM   JSR GETC        ; MOVE PAST '%'
00936    2474  20 BC 25             JSR GETLNS      ; GET GG.SS
00937    2477  A5 2C                LDA GRPNO       ; GET GG
00938    2479  85 8F                STA M           ; SAVE AS NUMBER BEFORE DECIMAL POINT
00939    247B  A5 2D                LDA LINENO      ; GET SS
00940    247D  85 90                STA N           ; SAVE AS NUMBER AFTER DECIMAL POINT
00941    247F  4C 84 24             JMP TASK        ;   AND CONTINUE PROCESSING
00942                            ;
00943    2482  85 22        TYPE    STA ATSW        ; FLAG WHICH ONE IT IS
00944    2484  A9 00        TASK    LDA #$00        ; ENABLE THE TRACE
00945    2486  85 20                STA DEBGSW      ;
00946    2488  20 B4 29             JSR SPNOR       ; LOOK FOR NEXT NON-BLANK
00947    248B  C9 24                CMP #$24        ; '$'
00948    248D  F0 A8                BEQ JTDUMP      ; DUMP OUT THE VARIABLE LIST
00949    248F  C9 25                CMP #$25        ; '%' FORMAT CONTROL?
00950    2491  F0 DE                BEQ TFORM       ; BRANCH IF YES
00951    2493  C9 21                CMP #$21        ; '!' SEE IF SPECIAL
00952    2495  F0 32                BEQ TCRLF       ; GIVE OUT A CARRIAGE RETURN-LINE FEED
00953    2497  C9 23                CMP #$23        ; '#'
00954    2499  F0 33                BEQ TCR         ; CARRIAGE RETURN ONLY
00955    249B  C9 22                CMP #$22        ; '"'
00956    249D  F0 39                BEQ TQUOT       ; TYPE OUT A QUOTED STRING
00957    249F  C9 2C                CMP #$2C        ; ','
00958    24A1  F0 30                BEQ TASK4       ; IGNORE IN CASE USER WANTS IT TO LOOK PRETTY
00959    24A3  C9 3B                CMP #$3B        ; ';' END OF COMMAND?
00960    24A5  F0 4A                BEQ TPROC       ; YES, THEN BRANCH
00961    24A7  C9 0D                CMP #$0D        ; 'CR' END OF LINE?
00962    24A9  F0 3F                BEQ TPC1        ; YES, THEN GO HANDLE IT
00963    24AB  A5 22                LDA ATSW        ; NOT SPECIAL CHAR, GET COMMAND SWITCH
00964    24AD  C9 41                CMP #$41        ; 'A' WHICH COMMAND ARE WE DOING?
00965    24AF  F0 89                BEQ TASK1       ; BRANCH IF 'ASK', AS IT DIFFERS
00966    24B1  20 1C 28             JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE THE EXPRESSION
00967            .WORD EVAL      ; ($19F8 in ww -- mtb)
00968    ;        LDA #$54        ; RESTORE 'ATSW' (SINCE WE MUST BE RECURSIVE!)
00969    ;        STA ATSW        ; (in ww -- mtb)
00970    24B6  20 1F 33             JSR FPRNT       ; GO OUTPUT IT
00971    24B9  A5 2B                LDA CHAR        ; GET TERMINATOR FROM 'EVAL'
00972    24BB  C9 29                CMP #$29        ; ')' SO "TYPE 3)" DOESN'T DIE!
00973    24BD  F0 14                BEQ TASK4       ; FLUSH IF WE DON'T LIKE IT
00974    24BF  C9 3D                CMP #$3D        ; '=' ALSO FLUSH OTHER NASTIES
00975    24C1  F0 10                BEQ TASK4       ;
00976    24C3  C9 2E                CMP #$2E        ; '.'
00977    24C5  F0 0C                BEQ TASK4       ;
00978    24C7  D0 BB                BNE TASK        ; OTHERWISE, CONTINUE PROCESSING
00979                            ;
00980      2482             ASK     = TYPE          ; ($1488 in ww -- mtb)
00981                            ;
00982    24C9  20 99 2D     TCRLF   JSR CRLF        ; OUTPUT A CR FOLLOWED BY A LF
00983    24CC  10 05                BPL TASK4       ; UNCONDITIONAL BRANCH
00984    24CE  A9 0D        TCR     LDA #$0D        ; 'CR' OUTPUT A CARRIAGE RETURN
00985    24D0  20 02 29             JSR PRINTC      ;
00986    24D3  20 92 29     TASK4   JSR GETC        ; SKIP OVER THIS CHARACTER
00987    24D6  10 AC                BPL TASK        ; UNCONDITIONALLY CONTINUE PROCESSING
00988                            ;
00989    24D8  E6 20        TQUOT   INC DEBGSW      ; DISABLE TRACE SO LITERAL ONLY PRINTS ONCE
00990    24DA  20 92 29     TQUOT1  JSR GETC        ; GET NEXT CHAR
00991    24DD  C9 22                CMP #$22        ; '"' CLOSING QUOTE?
00992    24DF  F0 F2                BEQ TASK4       ; BRANCH IF YES
00993    24E1  C9 0D                CMP #$0D        ; 'CR' END OF LINE?
00994    24E3  F0 05                BEQ TPC1        ; BRANCH IF YES (IT TERMINATES STRING)
00995    24E5  20 02 29             JSR PRINTC      ; OTHERWISE, PRINT THE CHARACTER
00996    24E8  10 F0                BPL TQUOT1      ; UNCONDITIONALLY LOOP UNTIL DONE
00997    24EA  A9 00        TPC1    LDA #$00        ; ENABLE TRACE JUST IN CASE
00998    24EC  85 20                STA DEBGSW      ;
00999    24EE  4C 63 23     FPC1    JMP PC1         ; EXIT 'PROCESS'
01000    24F1  4C FF 22     TPROC   JMP PROCES      ; CONTINUE PROCESSING ON THIS LINE
01001                            ;
01002            ; "FOR" LOOP ITERATION COMMAND
01003                            ;
01004    24F4  20 1C 28     FOR     JSR PUSHJ       ; GO GET THE VARIABLE (mtb)
01005            .WORD GETVAR    ; ($2B51; $1B43 in ww -- mtb)
01006    24F9  A5 2B                LDA CHAR        ; GET TERMINATOR
01007    24FB  C9 3D                CMP #$3D        ; '=' SIGN?
01008    24FD  F0 02                BEQ FOR2        ; BRANCH IF YES
01009    24FF  00                   BRK             ; NO, TRAP
01010            .BYTE NOEQLS    ; ?NO '=' IN 'FOR' OR 'SET' (#$F3)
01011    2501  A2 37        FOR2    LDX #VARADR     ; SAVE THE ADDRESS OF THE VARIABLE
01012    2503  A0 05                LDY #$05        ;   AND ITS PROPERTIES
01013    2505  20 6B 28             JSR PUSHB0      ;   ON STACK
01014    2508  20 1C 28             JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE RIGHT HAND
01015            .WORD EVALM1    ;    SIDE OF '=' ($2A03; $19F5 in ww -- mtb)
01016    250D  A2 3B                LDX #VARADR+4   ; GET ADDR OF VARIABLE BACK AGAIN
01017    250F  A0 05                LDY #$05        ;
01018    2511  20 5B 28             JSR POPB0       ;
01019    2514  20 9B 2C             JSR BOMSTV      ; BOMB OUT IF LOOP COUNTER IS STR. VARIB.
01020    2517  20 A1 2C             JSR PUTVAR      ; NOT A STRING, SO STORE INITIAL VALUE
01021    251A  A5 2B                LDA CHAR        ; GET THE EXPRESSION TERMINATOR
01022    251C  C9 2C                CMP #$2C        ; ',' COMMA?
01023    251E  F0 10                BEQ FINCR       ; BRANCH IF IT'S A 'FOR' COMMAND
01024    2520  00           BTFOR   BRK             ; TRAP
01025            .BYTE FBDTRM    ; ?BAD TERMINATOR IN 'FOR' (#$F2)
01026                            ;
01027            ; "SET" COMMAND
01028                            ;
01029    ;SET1    JSR GETC        ; SKIP OVER COMMA (in ww -- mtb)
01030    2522  20 1C 28     SET     JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE EXPRESSION
01031            .WORD EVALM1    ; 'EVALM1' ($2A03; $19F5 was 'EVAL' $19F8 in ww -- mtb)
01032    2527  A5 2B                LDA CHAR        ; GET TERMINATOR
01033    2529  C9 2C                CMP #$2C        ; ',' COMMA?
01034    252B  F0 F5                BEQ SET         ; BRANCH IF YES, LOOP FOR ANOTHER EXPRESS (SET1 in ww -- mtb)
01035    252D  4C 02 23             JMP PROC        ; NO. ALL DONE, CONTINUE ON THIS LINE
01036                            ;
01037    ; there is a handwritten note here: 'Best cmmd exit points $1304'
01038    ; ($2302 in this Aresco version code)
01039                            ;
01040                            ;
01041            ; 'FOR' COMMAND PROCESSING
01042                            ;
01043    2530  A2 37        FINCR   LDX #VARADR     ; SAVE THE ADDR OF THE LOOP VARIABLE ON STACK
01044    2532  20 69 28             JSR PUSHB2      ;
01045    2535  20 1C 28             JSR PUSHJ       ; GO GET THE INCREMENT
01046            .WORD EVALM1    ; ($2A03; $19F5 in ww -- mtb)
01047    253A  A5 2B                LDA CHAR        ; GET TERMINATOR
01048    253C  C9 2C                CMP #$2C        ; ',' DID WE GET AN INCREMENT?
01049    253E  F0 16                BEQ FLIMIT      ; YES, GO GET THE UPPER LIMIT OF LOOP
01050    2540  C9 3B                CMP #$3B        ; ';' WAS NO INCREMENT SPECIFIED?
01051    2542  F0 06                BEQ FINCR1      ; BRANCH IF NO INCREMENT GIVEN
01052    2544  C9 0D                CMP #$0D        ; 'CR' CARRIAGE RETURN?
01053    2546  D0 D8                BNE BTFOR       ; NO, THEN BAD TERMINATOR
01054    2548  00                   BRK             ; YES, TRAP
01055            .BYTE UFL       ; ?USELESS 'FOR' LOOP (#$F1)
01056    254A  A2 FB        FINCR1  LDX #$FB        ; GET NEGATIVE OF NUMBER OF BYTES (-5)
01057    254C  B5 A0        FI1C    LDA FONE+NUMBF,X ; GET NEXT BYTE
01058    254E  20 31 28             JSR PUSHA       ; PUSH IT ON STACK
01059    2551  E8                   INX             ; POINT TO NEXT ONE
01060    2552  30 F8                BMI FI1C        ;   AND LOOP UNTIL ALL PUSHED
01061    2554  10 08                BPL FSHORT      ; UNCONDITIONAL BRANCH
01062    2556  20 79 28     FLIMIT  JSR PHFAC1      ; SAVE INCREMENT ON STACK
01063    2559  20 1C 28             JSR PUSHJ       ; NOW EVALUATE THE UPPER LIMIT
01064            .WORD EVALM1    ; ($2A03; $19F5 in ww -- mtb)
01065    255E  20 79 28     FSHORT  JSR PHFAC1      ; SAVE UPPER LIMIT ON STACK AND ENTER LOOP
01066                            ;
01067            ; 'LOOP PROCESSOR FOR "FOR" COMMAND'
01068                            ;
01069    2561  20 0A 27     FCONT   JSR PUSHTP      ; NOW SAVE THE TEXT POINTERS ON STACK
01070    2564  A5 26                LDA PC          ; SAVE PC ACROSS CALL
01071    2566  20 31 28             JSR PUSHA       ;
01072    2569  20 1C 28             JSR PUSHJ       ; NOW EXECUTE THE REST OF THE LINE
01073            .WORD PROCES    ; 'PROCES' ($22FF; $1301 in ww -- mtb)
01074    256E  20 3F 28             JSR POPA        ; SET PC BACK
01075    2571  85 73                STA ITEMP1      ; SAVE IT IN TEMPORARY
01076    2573  20 11 27             JSR POPTP       ; SAVE POINTERS FOR POSSIBLE RE-ENTRY
01077    2576  20 A5 28             JSR PLTMP       ; RESTORE UPPER LOOP LIMIT INTO TEMPORARY
01078    2579  20 C3 2C             JSR POPIV       ; RESTORE INCREMENT AND VARIABLE ADDR
01079    257C  A5 26                LDA PC          ; GET PC
01080    257E  C9 FD                CMP #RETCMD     ; WAS A 'RETURN' COMMAND JUST EXECUTED?
01081    2580  F0 22                BEQ FORXIT      ; BRANCH IF YES, THEN EXIT THE LOOP NOW!
01082    2582  A5 7C                LDA M2          ; GET THE SIGN OF THE INCREMENT (+ OR -)
01083    2584  08                   PHP             ; SAVE STATUS ON STACK FOR LATER
01084    2585  20 BB 2C             JSR PUSHIV      ; SAVE AGAIN FOR POSSIBLE REPEAT OF LOOP
01085    2588  20 AE 2C             JSR FETVAR      ; GO GET THE VARIABLE'S CURRENT VALUE
01086    258B  20 79 32             JSR FADD        ; ADD THE INCREMENT TO FLAC
01087    258E  20 A1 2C             JSR PUTVAR      ; STORE AS NEW LOOP COUNTER VALUE
01088    2591  20 8F 28             JSR PHTMP       ; SAVE TEMPORARY ON STACK
01089    2594  20 9A 28             JSR PLFAC2      ; PLACE INTO FAC2
01090    2597  20 73 32             JSR FSUB        ; SUBTRACT COUNTER FROM UPPER LIMIT (mtb)
01091    259A  28                   PLP             ; GET SIGN OF THE INCREMENT
01092    259B  30 0E                BMI CNTDWN      ; BRANCH IF NEGATIVE, WE ARE COUNTING DOWN
01093    259D  A5 81                LDA FLCSGN      ; GET THE SIGN OF THE NUMBER
01094    259F  10 10                BPL MORFOR      ; BRANCH IF REPEAT NECESSARY
01095    25A1  20 C3 2C     FOREND  JSR POPIV       ; CLEAN UP STACK
01096    25A4  A5 73        FORXIT  LDA ITEMP1      ; RESTORE PC
01097    25A6  85 26                STA PC          ;   IN CASE 'RETURN' ENCOUNTERED
01098    25A8  20 4B 28             JSR POPJ        ; EXIT 'FOR' COMMAND
01099    25AB  A5 81        CNTDWN  LDA FLCSGN      ; ARE WE LESS THAN THE LOOP LIMIT?
01100    25AD  F0 02                BEQ MORFOR      ; NO, THEN KEEP GOING
01101    25AF  10 F0                BPL FOREND      ; YES, THEN THAT'S ALL
01102    25B1  20 8F 28     MORFOR  JSR PHTMP       ; PLACE UPPER LIMIT BACK ON THE STACK
01103    25B4  10 AB                BPL FCONT       ; UNCONDITIOANALLY REPEAT LOOP
01104                            ;
01105            ; LINE NUMBER MANIPULATION ROUTINES
01106                            ;
01107            ; "GETLN" GET A LINE NUMBER FROM PROGRAM TEXT.
01108            ; RETURNS WITH V=1 IF "ALL" (00.00), OTHERWISE
01109            ; IT RETURNS WITH Z=1 IF GROUP NUMBER ONLY (GG.00)
01110            ; AND Z=0 IF INDIVIDUAL LINE NUMBER (GG.LL).
01111                            ;
01112    25B6  20 27 34     GETLNC  JSR FINP        ; ONLY ALLOW NUMERIC INPUT
01113    25B9  4C DF 25             JMP GETLN1      ;   AND ENTER REST OF CODE
01114                            ;
01115    25BC  20 B4 29     GETLNS  JSR SPNOR       ; GET NEXT NON-BLANK
01116    25BF  A9 00        GETLN   LDA #$00        ; ASSUME LINE NUMBER IS ZERO
01117    25C1  85 2C                STA GRPNO       ;
01118    25C3  85 2D                STA LINENO      ;
01119    25C5  A5 2B                LDA CHAR        ; GET FIRST CHARACTER OF EXPRESSION?
01120    25C7  C9 2C                CMP #$2C        ; ',' IS EXPRESSION NULL?
01121    25C9  F0 3A                BEQ GOTLNO      ; BRANCH IF YES, THEN WE HAVE THE NUMBER
01122    25CB  C9 0D                CMP #$0D        ; 'CR' ANOTHER FORM OF NULL?
01123    25CD  F0 36                BEQ GOTLNO      ; BRANCH IF YES, THEN WE HAVE THE NUMBER
01124    25CF  20 BE 29             JSR TESTN       ; DOES EXPRESSION BEGIN WITH A NUMBER?
01125    25D2  B0 06                BCS GETLNX      ; BRANCH IF NOT, THEN MUST BE COMPLEX 
01126    25D4  20 A3 2D             JSR GETILN      ; CALL INTEGER LINE NUMBER INPUT FOR SPEED
01127    25D7  4C 05 26             JMP GOTLNO      ; WE NOW HAVE THE LINE NUMBER
01128    25DA  20 1C 28     GETLNX  JSR PUSHJ       ; CALL 'EVAL' TO EVALUATE EXPRESSION
01129            .WORD EVAL      ; ($2A06; $19F8 in ww -- mtb)
01130    25DF  20 79 28     GETLN1  JSR PHFAC1      ; SAVE EXPRESSION VALUE ON STACK
01131    25E2  20 16 26             JSR GETL        ; INTEGERIZE AND RANGE CHECK
01132    25E5  85 2C                STA GRPNO       ; SAVE AS GROUP NUMBER
01133    25E7  20 39 32             JSR FLOAT       ; NOW FLOAT THE GROUP NUMBER
01134    25EA  20 9A 28             JSR PLFAC2      ; POP FULL GG.SS INTO FAC2
01135    25ED  20 73 32             JSR FSUB        ; SUBTRACT OFF THE GROUP NUMBER (mtb)
01136    25F0  20 27 26             JSR GMUL10      ; MULTIPLY BY 100
01137    25F3  20 27 26             JSR GMUL10      ;
01138    25F6  A2 96                LDX #FHALF      ; MOVE CONSTANT .50
01139    25F8  A0 7B                LDY #X2         ;
01140    25FA  20 FF 33             JSR MOVXY       ;
01141    25FD  20 79 32             JSR FADD        ; NOW ADD IN THE .50 FOR ROUNDING
01142    2600  20 16 26             JSR GETL        ; INTEGERIZE AND RANGE CHECK
01143    2603  85 2D                STA LINENO      ; SAVE AS LINE NUMBER (STEP NUMBER)
01144    2605  B8           GOTLNO  CLV             ; ASSUME NOT 00.00
01145    2606  A5 2C                LDA GRPNO       ; GET GROUP NUMBER
01146    2608  05 2D                ORA LINENO      ; 'OR' IN THE LINE NUMBER
01147    260A  F0 07                BEQ GOTALL      ; BRANCH IF BOTH ARE ZERO
01148    260C  A5 2C                LDA GRPNO       ; GET GROUP NUMBER AGAIN
01149    260E  F0 15                BEQ BADLNO      ; BAD LINE NUMBER IS GROUP ONLY IS ZERO
01150    2610  A5 2D                LDA LINENO      ; GROUP NUMBER OK, GET LINE (STEP) NO.
01151    2612  60           RTS3    RTS             ; RETURN WITH Z=1 IF GROUP ONLY
01152                            ;
01153    2613  24 6F        GOTALL  BIT BITV1       ; EXIT WITH V=1, (n=1 ??)
01154    2615  60                   RTS             ;
01155                            ;
01156            ; 'LINE NUMBER MANIPULATION ROUTINES'
01157                            ;
01158    2616  20 18 33     GETL    JSR FIX         ; FIX THE NUMBER IN FAC1
01159    2619  A5 81                LDA M1          ; GET HIGH ORDERS
01160    261B  05 82                ORA M1+1        ; SMASH THEM TOGETHER
01161    261D  D0 06                BNE BADLNO      ; LINE NUMBER CAN ONLY BE POSITIVE
01162    261F  A5 83                LDA M1+2        ;
01163    2621  C9 64                CMP #$64        ; AND < 100 ?
01164    2623  30 ED                BMI RTS3        ;
01165    2625  00           BADLNO  BRK             ; TRAP
01166            .BYTE ILLNO     ; ILLEGAL LINE NUMBER (#$FC)
01167    2627  A2 91        GMUL10  LDX #FTEN       ; MOVE 10.0
01168    2629  A0 7B                LDY #X2         ;   INTO FAC2
01169    262B  20 FF 33             JSR MOVXY       ;
01170    262E  4C A0 32             JMP FMUL        ; * PJMP *  FAC1*FAC2=FAC1
01171                            ;
01172            ; 'PRINTLN - PRINT A LINE NUMBER'
01173                            ; 
01174            ; "PRINTLN" PRINT A LINE NUMBER TO OUTPUT DEVICE
01175                            ; 
01176    2631  A4 2A        PRNTLN  LDY TEXTP       ; GET TEXT POINTER
01177    2633  B1 28                LDA (TXTADR),Y  ; GET GROUP NUMBER
01178    2635  D0 05                BNE PRNTL1      ; BRANCH IF NOT ZERO
01179    2637  C8                   INY             ; DO NOT PRINT GROUP ZERO LINE NUMBERS
01180    2638  C8                   INY             ;
01181    2639  84 2A                STY TEXTP       ; POINT TO FIRST CHARACTER IN LINE
01182    263B  60                   RTS             ;   AND RETURN
01183                            ;
01184    263C  48           PRNTL1  PHA             ; SAVE THE GROUP NUMBER FOR LATER
01185    263D  C8                   INY             ; POINT TO THE STEP NUMBER
01186    263E  B1 28                LDA (TXTADR),Y  ; GET STEP NUMBER
01187    2640  C8                   INY             ; MOVE PAST IT
01188    2641  84 2A                STY TEXTP       ; SAVE POINTER
01189    2643  20 77 26             JSR PFLT        ; FLOAT THE STEP NUMBER
01190    2646  20 11 34             JSR DIV10       ; DIVIDE BY 100
01191    2649  20 11 34             JSR DIV10       ;
01192    264C  20 79 28             JSR PHFAC1      ; SAVE 00.SS FOR LATER
01193    264F  68                   PLA             ; GET THE GROUP NUMBER BACK
01194    2650  20 77 26             JSR PFLT        ; FLOAT IT
01195    2653  20 9A 28             JSR PLFAC2      ; RESTORE 00.SS INTO FAC2
01196    2656  20 79 32             JSR FADD        ; ADD TOGETHER TO FORM GG.SS
01197                            ; * PFALL * INTO OUTPUT ROUTINE
01198    2659  A9 02                LDA #$02        ; ASSUME TWO DIGITS BEFORE THE DECIMAL PT.
01199    265B  AA                   TAX             ;   AND TWO DIGITS AFTER
01200    265C  D0 04                BNE OUTLN       ; UNCONDITIONAL BRANCH
01201    265E  A9 02        OUTLN0  LDA #$02        ; ASSUME TWO DIGITS BEFORE DECIMAL
01202    2660  A2 00        OUTLN1  LDX #$00        ; ASSUME NO DECIMAL POINT (mtb)
01203    2662  A8           OUTLN   TAY             ; SAVE NUMBER BEFORE DECIMAL IN Y REG
01204    2663  A5 8F                LDA M           ; SAVE OLD FORMAT ON HARDWARE STACK (mtb)
01205    2665  48                   PHA             ; (COULD BE CALLED FROM ERROR TRAP)
01206    2666  A5 90                LDA N           ;
01207    2668  48                   PHA             ;
01208    2669  84 8F                STY M           ; STORE NEW FORMAT
01209    266B  86 90                STX N           ;
01210    266D  20 1F 33             JSR FPRNT       ; PRINT NUMBER IN TEMPORARY FORMAT
01211    2670  68                   PLA             ; RESTORE OLD FORMAT
01212    2671  85 90                STA N           ;
01213    2673  68                   PLA             ;
01214    2674  85 8F                STA M           ;
01215    2676  60                   RTS             ; AND RETURN
01216                            ;
01217    2677  85 82        PFLT    STA M1+1        ; SAVE IN LOW ORDER
01218    2679  A9 00                LDA #$00        ; MAKE HIGH ORDER ZERO
01219    267B  85 81                STA M1          ;
01220    267D  4C 4D 32             JMP FLT16       ; * PJMP * AND FLOAT IT
01221                            ;
01222            ; 'FINDLN - FIND A LINE IN THE STORED PROGRAM'
01223                            ; 
01224            ; "FINDLN"  RETURNS WITH C=1 IF THE LINE WAS FOUND.
01225            ;           TXTAD2 POINTS TO THE GROUP NUMBER,
01226            ;           RETURNS WITH C=0 IF THE LINE WAS NOT LOCATED
01227            ;           TXTAD2 POINTS TO THE GROUP NUMBER OF THE NEXT HIGHEST NO.
01228            ;           (I.E., WHERE YOU WOULD INSERT THIS LINE)
01229                            ; 
01230    2680  A5 2C        FINDLN  LDA GRPNO       ; PLACE LINE NUMBER OF LINE WE ARE
01231    2682  85 5A                STA ITMP2H      ;   LOOKING FOR INTO TEMPORARY
01232    2684  A5 2D                LDA LINENO      ; STEP PART ALSO
01233    2686  85 59                STA ITMP2L      ;
01234    2688  A9 00                LDA #$00        ; SET FLAG INDICATING FIRST SEARCH
01235    268A  85 3B                STA FSWIT       ;
01236    268C  85 2A                STA TEXTP       ; ALSO RESET TEXT POINTER TO BEGINNING OF
01237    268E  A5 26                LDA PC          ;   CURRENT LINE. IS CURR LN DIRECT CMD?
01238    2690  10 05                BPL CHKLIN      ; NO, THEN START SEARCHING FOR PRESENT POS
01239    2692  20 18 27     FNDINI  JSR TXTINI      ; YES, THEN RESET TEXT POINTERS TO START
01240    2695  E6 3B                INC FSWIT       ;   OF PROGRAM, INDICATE LAST SEARCH
01241    2697  A4 2A        CHKLIN  LDY TEXTP       ; GET TEXT POINTER
01242    2699  B1 28                LDA (TXTADR),Y  ; GET THE GROUP NUMBER
01243    269B  C9 FE                CMP #EOP        ; END OF TEXT?
01244    269D  F0 23                BEQ NOFIND      ; BRANCH IF YES
01245    269F  85 56                STA ITMP1H      ; SAVE FOR COMPARISON
01246    26A1  85 51                STA TGRP        ; ALSO SAVE IN CASE THIS ONE IS IT
01247    26A3  C8                   INY             ; POINT TO STEP NUMBER
01248    26A4  B1 28                LDA (TXTADR),Y  ; GET IT
01249    26A6  85 55                STA ITMP1L      ; SAVE IT FOR COMPARISON
01250    26A8  85 51                STA TLINE       ; ALSO SAVE IN CASE THIS IS IT
01251    26AA  C8                   INY             ; POINT TO FIRST CHAR IN LINE
01252    26AB  84 2A                STY TEXTP       ; UPDATE TEXT POINTER
01253    26AD  38                   SEC             ; SET UP FOR SUBTRACT
01254    26AE  A5 55                LDA ITMP1L      ; GET LOW ORDER
01255    26B0  E5 59                SBC ITMP2L      ;
01256    26B2  85 55                STA ITMP1L      ; SAVE FOR LATER
01257    26B4  A5 56                LDA ITMP1H      ; NOW HIGH ORDERS
01258    26B6  E5 5A                SBC ITMP2H      ;
01259    26B8  30 0E                BMI FNEXT       ; BRANCH IF THE ONE IN THE TEXT AREA IS <
01260    26BA  05 55                ORA ITMP1L      ; NOT BIGGER, IS IT EQUAL?
01261    26BC  F0 0F                BEQ FOUNDL      ; BRANCH IF WE LOCATE THE LINE
01262    26BE  A5 3B                LDA FSWIT       ; LAST SEARCH ATTEMPT?
01263    26C0  F0 D0                BEQ FNDINI      ; BRANCH IF NOT, TRY AGAIN FROM START OF
01264                            ;   PROGRAM
01265    26C2  18           NOFIND  CLC             ; FLAG THE FACT WE DIDN'T FIND IT
01266    26C3  A0 00        FNEXIT  LDY #$00        ; RESET POINTER TO GROUP NUMBER
01267    26C5  84 2A                STY TEXTP       ;
01268    26C7  60                   RTS             ;
01269    26C8  20 D0 26     FNEXT   JSR EATCR       ; FLUSH TO START OF NEXT LINE
01270    26CB  10 CA                BPL CHKLIN      ; UNCONDITIONALLY LOOP FOR MORE
01271    26CD  38           FOUNDL  SEC             ; FLAG THE FACT WE FOUND IT
01272    26CE  B0 F3                BCS FNEXIT      ;   AND RETURN
01273                            ;
01274            ; UTILITY ROUTINES FOR TEXT MANIPULATION
01275                            ;
01276            ; FLUSH UNTIL A CARRIAGE RETURN
01277                            ;
01278    26D0  E6 20        EATCR   INC DEBGSW      ; DISABLE TRACE
01279    26D2  20 92 29     EATCRC  JSR GETC        ; GET NEXT CHAR
01280    26D5  10 02                BPL EATCNT      ; UNCONDITIONAL BRANCH
01281    26D7  E6 20        EATCR1  INC DEBGSW      ; DISABLE TRACE
01282    26D9  A5 2B        EATCNT  LDA CHAR        ; GET THE CHAR
01283    26DB  C9 0D                CMP #$0D        ; 'CR' ?
01284    26DD  D0 F3                BNE EATCRC      ; BRANCH IF NOT
01285    26DF  A5 28                LDA TXTADR      ; YES, CALCULATE THE START OF NEXT LINE
01286    26E1  18                   CLC             ;
01287    26E2  65 2A                ADC TEXTP       ; ADD IN THE TEXT POINTER
01288    26E4  85 28                STA TXTADR      ; SAVE IN POINTER
01289    26E6  85 33                STA TXTAD2      ;   AND ALTERNATE POINTER
01290    26E8  A5 29                LDA TXTADR+1    ; NOW HIGH ORDER
01291    26EA  69 00                ADC #$00        ;
01292    26EC  85 29                STA TXTADR+1    ;
01293    26EE  85 34                STA TXTAD2+1    ; AND ALTERNATE POINTER
01294    26F0  A9 00                LDA #$00        ; AND RESET THE POINTER
01295    26F2  85 2A                STA TEXTP       ;
01296    26F4  85 35                STA TEXTP2      ;
01297    26F6  C6 20                DEC DEBGSW      ; ALLOW TRACE AGAIN
01298    26F8  60                   RTS             ;   AND RETURN
01299                            ;
01300            ; FLUSH UNTIL END OF COMMAND (SEMI-COLON OR CARRIAGE RETURN)
01301                            ;
01302    26F9  20 92 29     EATEC1  JSR GETC        ; GET NEXT CHAR
01303    26FC  10 02                BPL EATECC      ; UNCONDITIONAL BRANCH
01304    26FE  E6 20        EATECM  INC DEBGSW      ; TURN OFF TRACE
01305    2700  A5 2B        EATECC  LDA CHAR        ; GET THE CHAR
01306    2702  20 5A 23             JSR TSTEOC      ; GO SEE IF ';' OR CARRIAGE RETURN
01307    2705  D0 F2                BNE EATEC1      ; BRANCH IF NOT
01308    2707  C6 20                DEC DEBGSW      ; ENABLE TRACE AGAIN
01309    2709  60                   RTS             ;   AND RETURN
01310                            ;
01311            ; PUSH THE TEXT POINTERS ON THE STACK
01312                            ;
01313    270A  A2 28        PUSHTP  LDX #TXTADR     ;
01314    270C  A0 04                LDY #$04        ; THREE PLUS 'CHAR'
01315    270E  4C 6B 28             JMP PUSHB0      ; * PJMP *
01316                            ;
01317            ; POP THE TEXT POINTERS OFF THE STACK
01318                            ;
01319    2711  A2 2B        POPTP   LDX #TXTADR+3   ;
01320    2713  A0 04                LDY #$04        ;
01321    2715  4C 5B 28             JMP POPB0       ; * PJMP *
01322                            ;
01323            ; INIT TEXT POINTER TO BEGINNING OF TEXT
01324                            ;
01325    2718  A5 2F        TXTINI  LDA TXTBEG      ; POINT TO START OF STORED TEXT
01326    271A  85 28                STA TXTADR      ;
01327    271C  A5 30                LDA TXTBEG+1    ;
01328    271E  85 29                STA TXTADR+1    ;
01329    2720  A9 00                LDA #$00        ; INIT OFFSET TO ZERO
01330    2722  85 2A                STA TEXTP       ;
01331    2724  60                   RTS             ;
01332                            ;
01333            ; 'NEWLIN' SETUP TEXT POINTERS AND PC FOR NEW LINE NUMBER
01334                            ;
01335    2725  A5 2C        NEWLIN  LDA GRPNO       ; GET THE LINE NUMBER
01336    2727  85 26                STA PC          ; STORE IN THE PROGRAM COUNTER
01337    2729  A5 2D                LDA LINENO      ;
01338    272B  85 27                STA PC+1        ;
01339    272D  A0 02                LDY #$02        ; POINT TO FIRST CHAR 0N LINE
01340    272F  84 2A                STY TEXTP       ;
01341    2731  60                   RTS             ; AND RETURN
01342                            ;
01343            ; 'NXTLIN' SETUP TEXT POINTERS AND PC FOR NEXT LINE NUMBER
01344                            ;
01345    2732  A4 2A        NXTLIN  LDY TEXTP       ; GET TEXT POINTER
01346    2734  B1 28                LDA (TXTADR),Y  ; PICK UP GROUP NUMBER
01347    2736  C9 FE                CMP #EOP        ; END OF PROGRAM?
01348    2738  F0 0F                BEQ NONEXT      ; BRANCH IF NO NEXT LINE
01349    273A  85 26                STA PC          ; SAVE AS NEW LINE NUMBER
01350    273C  C8                   INY             ;
01351    273D  B1 28                LDA (TXTADR),Y  ; GET STEP NUMBER
01352    273F  85 27                STA PC+1        ; STORE IT
01353    2741  C8                   INY             ; POINT TO FIRST CHAR ON THE LINE
01354    2742  84 2A                STY TEXTP       ;
01355    2744  20 92 29             JSR GETC        ; GET THE FIRST CHAR OF NEW LINE
01356    2747  38                   SEC             ; FLAG THE FACT WE HAVE A NEW LINE
01357    2748  60                   RTS             ;   AND RETURN
01358    2749  18           NONEXT  CLC             ; INDICATE WE HAVE NO NEW LINE
01359    274A  60                   RTS             ;   AND RETURN
01360                            ;
01361            ; 'DELETE' A LINE OF STORED PROGRAM
01362                            ;
01363    274B  20 0A 27     DELETE  JSR PUSHTP      ; SAVE TEXT POINTERS
01364    274E  A0 02                LDY #$02        ; SKIP OVER LINE NUMBER
01365    2750  84 2A                STY TEXTP       ;
01366    2752  20 D0 26             JSR EATCR       ; SKIP TO THE CARRIAGE RETURN
01367    2755  20 11 27             JSR POPTP       ; RESTORE POINTER TO START OF LINE TO ZAP
01368    2758  20 0A 27             JSR PUSHTP      ;   BUT KEEP THEM AROUND
01369    275B  A0 00                LDY #$00        ; SET OFFSET TO ZERO
01370    275D  B1 33        DMVLOP  LDA (TXTAD2),Y  ; GET A CHAR
01371    275F  91 28                STA (TXTADR),Y  ; MOVE IT DOWN
01372    2761  C9 FE                CMP #EOP        ; END OF TEXT REACHED YET?
01373    2763  F0 09                BEQ DELDON      ; BRANCH IF YES
01374    2765  C8                   INY             ; NO, POINT TO NEXT CHAR TO MOVE
01375    2766  D0 F5                BNE DMVLOP      ; BRANCH IF NO OVERFLOW ON OFFSET
01376    2768  E6 29                INC TXTADR+1    ; OVERFLOW, BUMP HIGH ORDERS
01377    276A  E6 34                INC TXTAD2+1    ;
01378    276C  D0 EF                BNE DMVLOP      ; UNCONDITIONALLY MOVE NEXT BYTE
01379    276E  C8           DELDON  INY             ;
01380    276F  84 2A                STY TEXTP       ; SAVE OFFSET
01381    2771  A5 28                LDA TXTADR      ; GET BASE ADDR
01382    2773  18                   CLC             ;
01383    2774  65 2A                ADC TEXTP       ; ADD IN THE OFFSET
01384    2776  85 3E                STA VARBEG      ; SAVE AS START OF VARIABLE LIST
01385    2778  A5 29                LDA TXTADR+1    ; GET HIGH ORDER
01386    277A  69 00                ADC #$00        ; ADD IN THE CARRY
01387    277C  85 3F                STA VARBEG+1    ; SAVE IT
01388    277E  20 0D 28             JSR INSDON      ; FLAG VARIABLE LIST AS EMPTY
01389    2781  4C 11 27             JMP POPTP       ; * PJMP * RESTORE POINTERS TO POINT TO
01390                            ;   WHERE WE WOULD INSERT LINE.
01391                            ;
01392            ; 'INSERT' A LINE IN THE STORED PROGRAM TEXT AREA
01393                            ;
01394    2784  20 0A 27     INSERT  JSR PUSHTP      ; SAVE TEXT POINTERS ACROSS CALL
01395    2787  20 80 26             JSR FINDLN      ; TRY TO LOCATE THE LINE
01396    278A  90 06                BCC INSCNT      ; BRANCH IF LINE DOES NOT EXIST
01397    278C  20 4B 27             JSR DELETE      ; LINE EXISTS, DELETE IT
01398    278F  20 80 26             JSR FINDLN      ; RE-FIND TO SET UP POINTERS AGAIN
01399    2792  20 11 27     INSCNT  JSR POPTP       ; GET COMBUF POINTERS BACK
01400    2795  C6 2A                DEC TEXTP       ; POINT TO THE LINE NUMBER DELIMITER
01401    2797  20 0A 27             JSR PUSHTP      ;   BUT KEEP THEM AROUND
01402    279A  A2 33                LDX #TXTAD2     ; SAVE POINTER TO PLACE TO INSERT
01403    279C  A0 04                LDY #$04        ;   ON STACK
01404    279E  20 6B 28             JSR PUSHB0      ;
01405    27A1  A2 02                LDX #$02        ; SET COUNTER FOR 3 BYTES MINIMUM
01406    27A3  E8           IFCR    INX             ; COUNT THIS BYTE
01407    27A4  20 92 29             JSR GETC        ; GET IT FROM COMMAND BUFFER
01408    27A7  C9 0D                CMP #$0D        ; 'CR' ?
01409    27A9  D0 F8                BNE IFCR        ; NO, KEEP COUNTING
01410    27AB  86 5F                STX TEMP1       ; SAVE COUNTER TEMPORARILY
01411    27AD  A0 00                LDY #$00        ; OFFSET TO ZERO
01412    27AF  B1 33                LDA (TXTAD2),Y  ; GET THE LAST CHAR TO SLIDE DOWN
01413    27B1  48                   PHA             ; SAVE FOR LATER
01414    27B2  A9 FD                LDA #UMARK      ; FLAG THE LOC WITH ALL ONES
01415    27B4  91 33                STA (TXTAD2),Y  ;
01416    27B6  A5 3E                LDA VARBEG      ; GET ADDR OF START OF VARIABLE LIST
01417    27B8  85 28                STA TXTADR      ; SAVE FOR LATER
01418    27BA  18                   CLC             ;
01419    27BB  65 5F                ADC TEMP1       ; ADD IN AMOUNT TO MOVE DOWNWARD
01420    27BD  85 33                STA TXTAD2      ; SAVE FOR LATER
01421    27BF  85 3E                STA VARBEG      ; SAVE AS NEW START OF VARIABLE LIST
01422    27C1  A5 3F                LDA VARBEG+1    ; NOW HIGH ORDER
01423    27C3  85 29                STA TXTADR+1    ;
01424    27C5  69 00                ADC #$00        ;
01425    27C7  85 34                STA TXTAD2+1    ;
01426    27C9  85 3F                STA VARBEG+1    ; AND FALL INTO MOVE LOOP
01427    27CB  B1 28        IMVLOP  LDA (TXTADR),Y  ; PICK UP A BYTE
01428    27CD  C9 FD                CMP #UMARK      ; END OF MOVE?
01429    27CF  F0 0D                BEQ IMVDON      ; BRANCH IF YES
01430    27D1  91 33                STA (TXTAD2),Y  ; NO, THEN SLIDE IT DOWN
01431    27D3  88                   DEY             ; DECREMENT OFFSET?
01432    27D4  C0 FF                CPY #$FF        ; OVERFLOW?
01433    27D6  D0 F3                BNE IMVLOP      ; BRANCH IF NOT
01434    27D8  C6 29                DEC TXTADR+1    ; OVERFLOW, BUMP HIGH ORDER
01435    27DA  C6 34                DEC TXTAD2+1    ;   ADDRESSES
01436    27DC  D0 ED                BNE IMVLOP      ; UNCONDITIONALLY LOOP FOR MORE
01437    27DE  68           IMVDON  PLA             ; GET THE LAST BYTE BACK AGAIN
01438    27DF  91 33                STA (TXTAD2),Y  ; STORE IT AWAY
01439    27E1  20 11 27             JSR POPTP       ; RESTORE POINTERS TO PLACE TO INSERT
01440    27E4  A2 36                LDX #TXTAD2+3   ; RESTORE POINTERS TO COMBUF
01441    27E6  A0 04                LDY #$04        ;
01442    27E8  20 5B 28             JSR POPB0       ;
01443    27EB  A4 2A                LDY TEXTP       ; GET OFFSET
01444    27ED  A5 2C                LDA GRPNO       ; GET THE GROUP NUMBER
01445    27EF  91 28                STA (TXTADR),Y  ; STRORE IT IN PROGRAM AREA
01446    27F1  C8                   INY             ;
01447    27F2  A5 2D                LDA LINENO      ; GET THE STEP NUMBER
01448    27F4  91 28                STA (TXTADR),Y  ; STRORE IT IN PROGRAM AREA
01449    27F6  C8                   INY             ; POINT TO WHERE FIRST CHARACTER GOES
01450    27F7  84 2A                STY TEXTP       ; SAVE IT FOR LATER
01451    27F9  A4 35        INSLOP  LDY TEXTP2      ; GET POINTER TO CHAR
01452    27FB  B1 33                LDA (TXTAD2),Y  ; PICK IT UP
01453    27FD  C8                   INY             ; BUMP IT
01454    27FE  84 35                STY TEXTP2      ; STORE IT BACK
01455    2800  A4 2A                LDY TEXTP       ; POINT TO WHERE IT GOES
01456    2802  91 28                STA (TXTADR),Y  ; PUT IT THERE
01457    2804  C9 0D                CMP #$0D        ; CARRIAGE RETURN YET?
01458    2806  F0 05                BEQ INSDON      ; BRANCH IF YES
01459    2808  C8                   INY             ; NO, POINT TO NEXT
01460    2809  84 2A                STY TEXTP       ; SAVE POINTER
01461    280B  D0 EC                BNE INSLOP      ; UNCONDITIONALLY LOOP FOR MORE
01462    280D  A0 00        INSDON  LDY #$00        ; OFFSET TO ZERO
01463    280F  A9 FF                LDA #EOV        ; FLAG VARIABLE LIST AS EMPTY
01464    2811  91 3E                STA (VARBEG),Y  ;
01465    2813  A5 3E                LDA VARBEG      ; AND UPDATE 'VAREND'
01466    2815  85 42                STA VAREND      ;
01467    2817  A5 3F                LDA VARBEG+1    ;
01468    2819  85 43                STA VAREND+1    ;
01469    281B  60                   RTS             ; AND RETURN
01470                            ;
01471    
01472    ; *** BEGIN AZIN67 SECTION (COMPLETED BY DAVE. H)
01473    
01474    ; 
01475    ; 
01476    ;           'SOFTWARE STACK MANIPULATION ROUTINES'
01477    ; 
01478    ; "PUSHJ" - PUSH-JUMP TO A ROUTINE
01479    ; 
01480    ; CALLING SEQUENCE IS:
01481    ; 
01482    ; JSR  PUSHJ	; CALL THIS SUBROUTINE
01483    ; .WORD ROUTINE	; TWO BYTE ADDR OF ROUTINE TO GO TO
01484    ;               ; *** NOTE! THIS WORD CANNOT OVERLAP
01485    ;               ; *** A PAGE BOUNDARY.
01486    ;        <----- ; RETURN IS HERE VIA "POPJ" ROUTINE
01487    ; 
01488    ; *** this routine has self-modifying code at $282F.
01489    ;     (I'm unsure how to write this in 'modern' assembly) --dhh
01490    ; 
01491    281C  68           PUSHJ     PLA		; GET LOW ORDER RETURN ADDR FROM STACK
01492    281D  A8                     TAY		; PLACE IN Y REGISTER
01493    281E  C8                     INY		; INCREMENT TO GET LOW ORDER TO JUMP INDIR
01494    281F  8C 2F 28               STY PJADR1	; STORE IN JUMP INDIRECT INSTRUCTION
01495    2822  C8                     INY		; BUMP FOR THE RTS IN "POPJ"
01496    2823  98                     TYA		; PLACE IN ACCUMULATOR
01497    2824  20 31 28               JSR PUSHA	; SAVE ON STACK FOR LATER
01498    2827  68                     PLA		; GET HIGH ORDER RETURN ADDR
01499    2828  8D 30 28               STA PJADR1+1	; STORE IN JUMP INDIRECT INSTRUCTION
01500    282B  20 31 28               JSR PUSHA	; SAVE FOR LATER RETURN VIA "POPJ"
01501      282F             PJADR1 = * + 1
01502    282E  6C 00 00               JMP ($0000)	; ADDR IS OVERWRITTEN FROM ABOVE CODE
01503                		; THIS JUMP WILL GO TO "ROUTINE".
01504    ; 
01505    ; "PUSHA" - PUSH THE ACCUMULATOR ON THE SOFTWARE STACK
01506    ; 
01507    ; CALLING SEQUENCE IS:
01508    ; JSR  PUSHA
01509    ; 
01510    2831  A4 4E        PUSHA     LDY PDP	; GET THE SOFTWARE STACK POINTER
01511    2833  91 4C                  STA (PDPADR),Y	; STORE THE ACC VIA POINTER
01512    2835  88                     DEY		; DECREMENT THE SOFT STACK POINTER
01513    2836  C0 FF                  CPY #$FF	; IS NEW VALUE $FF ?
01514    2838  D0 02                  BNE PUSHRT	; NO, THEN BASE ADDR IS OK
01515    283A  C6 4D                  DEC PDPADR+1	; YES, DEC BASE ADDR BY ONE
01516    283C  84 4E        PUSHRT    STY PDP	; STORE UPDATED POINTER
01517    283E  60                     RTS		; AND RETURN
01518    ; 
01519    ; "POPA" - POP ITEM OFF SOFTWARE STACK INTO THE ACCUMULATOR
01520    ; 
01521    ; CALLING SEQUENCE IS:
01522    ; JSR  POPA
01523    ; 
01524    283F  A4 4E        POPA      LDY PDP	; load software stack pointer
01525    2841  C8                     INY		; increment so it points to new item
01526    2842  D0 02                  BNE PHOK	; branch if high-order base addr is OK
01527    2844  E6 4D                  INC PDPADR+1	; if not OK, increment by one page
01528    2846  B1 4C        PHOK      LDA (PDPADR),Y	; get item from soft stack
01529    2848  84 4E                  STY PDP	; store updated pointer
01530    284A  60                     RTS		; and return
01531    ; 
01532    ; "POPJ" - RETURN TO ADDRESS SAVED BY A CALL TO "PUSHJ"
01533    ; 
01534    ; CALLING SEQUENCE IS:
01535    ; JSR  POPJ
01536    ; 
01537    284B  BA           POPJ      TSX		; load X w/ hw stack pointer
01538    284C  20 3F 28               JSR POPA	; get hi order addr to ret to
01539    284F  9D 02 01               STA STACK+2,X	; overwrite return addr
01540    2852  20 3F 28               JSR POPA	; get lo order byte to ret to
01541    2855  9D 01 01               STA STACK+1,X	; overwrite return addr
01542    2858  60                     RTS		; return to proper place, past
01543                            ;   JSR PUSHJ and .WORD routine
01544                            ; SEQUENCE --->
01545    ; 
01546    ; "POPB0"  pop bytes off of stack into zero page
01547    ; 
01548    2859  A0 02        POPB2     LDY #$02	; entry point when we need 2 bytes only
01549    285B  84 5F        POPB0     STY TEMP1	; save Y register
01550    285D  20 3F 28               JSR POPA	; get a byte from stack
01551    2860  95 00                  STA $00,X	; store it in zero page
01552    2862  A4 5F                  LDY TEMP1	; get Y register back
01553    2864  CA                     DEX		; count X down
01554    2865  88                     DEY		; done yet?
01555    2866  D0 F3                  BNE POPB0	; loop for more
01556    2868  60                     RTS		; yes, return
01557    ; 
01558    ; "PUSHB0"  push bytes from page zero onto stack   
01559    ; 
01560    2869  A0 02        PUSHB2    LDY #$02	; entry point, 2 bytes only
01561    286B  84 5F        PUSHB0    STY TEMP1	; save Y
01562    286D  B5 00                  LDA $00,X	; get value from Z Pg
01563    286F  20 31 28               JSR PUSHA	; save on stack
01564    2872  A4 5F                  LDY TEMP1	; get Y back
01565    2874  E8                     INX		; next byte
01566    2875  88                     DEY		; done yet?
01567    2876  D0 F3                  BNE PUSHB0	; loop if >0
01568    2878  60                     RTS		; return
01569    ; 
01570    ; PUSH AND POP F.P. NUMBERS
01571    ; 
01572    ; PUSH FAC1 ONTO STACK
01573    ; 
01574    2879  A2 FB        PHFAC1    LDX #$FB	; get neg of num of bytes to push
01575    287B  B5 85        PHF1B     LDA $85,X	; get a byte of number
01576    287D  20 31 28               JSR PUSHA	; push onto software stack
01577    2880  E8                     INX		; point to next one
01578    2881  30 F8                  BMI PHF1B	; loop til all pushed
01579    2883  60                     RTS               
01580    ; 
01581    ; PUSH FAC2 ONTO STACK
01582    ; 
01583    2884  A2 FB        PHFAC2    LDX #$FB	; get neg of num of bytes to push
01584    2886  B5 80        PHF2B     LDA $80,X	; get a byte of number
01585    2888  20 31 28               JSR PUSHA	; etc
01586    288B  E8                     INX
01587    288C  30 F8                  BMI PHF2B
01588    288E  60                     RTS
01589    ; 
01590    ; PUSH F.P. TEMP ONTO STACK
01591    ; 
01592    288F  A2 FB        PHTMP     LDX #$FB	; get neg of num of bytes to push
01593    2891  B5 A5        PHTB      LDA $A5,X	; get a byte of number
01594    2893  20 31 28               JSR PUSHA	; etc
01595    2896  E8                     INX
01596    2897  30 F8                  BMI PHTB
01597    2899  60                     RTS
01598    ; 
01599    ; POP NUMBER ON STACK INTO FAC2
01600    ; 
01601    289A  A2 04        PLFAC2    LDX #$04	; point to last byte
01602    289C  20 3F 28     PLF2B     JSR POPA	; pop item from stack into ACC
01603    289F  95 7B                  STA X2,X	; store into FAC2
01604    28A1  CA                     DEX		; point to next byte
01605    28A2  10 F8                  BPL PLF2B	; loop until all popped 
01606    28A4  60                     RTS
01607    ; 
01608    ; POP NUMBER ON STACK INTO F.P. TEMP
01609    ; 
01610    28A5  A2 04        PLTMP     LDX #$04	; point to last byte
01611    28A7  20 3F 28     PLTB      JSR POPA	; get item from stack into ACC
01612    28AA  95 A0                  STA $A0,X	; store in temp area
01613    28AC  CA                     DEX		; point to next byte
01614    28AD  10 F8                  BPL PLTB	; loop til done
01615    28AF  60                     RTS
01616    ; 
01617    ;           'CHARACTER MANIPULATING ROUTINES'
01618    ; 
01619    ; READ ONE CHARACTER WITH NO ECHO
01620    ; 
01621    28B0  A5 6B        RNOECH    LDA ECHFLG	; get echo ctrl flag
01622    28B2  48                     PHA		; save on stack
01623    28B3  A9 01                  LDA #$01	; no disable echo
01624    28B5  85 6B                  STA ECHFLG
01625    28B7  20 C0 28               JSR READC	; get a char from input device
01626    28BA  AA                     TAX		; save char into X
01627    28BB  68                     PLA		; get old echo flag value back
01628    28BC  85 6B                  STA ECHFLG
01629    28BE  8A                     TXA		; get the char input
01630    28BF  60                     RTS
01631    ; 
01632    ; "READC" - READ ONE CHARACTER FROM INPUT DEVICE
01633    ; 
01634    28C0  A6 66        READC     LDX IDEV	; GET CURRENT INPUT DEVICE NUMBER
01635    28C2  10 03                  BPL READC1	; BRANCH IF DEVICE NUMBER IS POSITIVE
01636    28C4  4C CB 30               JMP RSTRNG	; * PJMP * NEG, READ FROM STRING AND RET
01637    28C7  BD AF 35     READC1    LDA IDSPH,X	; GET HIGH ORDER DISPATCH ADDRESS
01638    28CA  85 60                  STA TEMP1+1	; STORE IT AWAY
01639    28CC  BD B4 35               LDA IDSPL,X	; GET LOW ORDER
01640    28CF  85 5F                  STA TEMP1	; STORE IT AWAY
01641    28D1  20 5E 00               JSR JSRIND	;   AND CALL THE INPUT ROUTINE
01642    28D4  90 05                  BCC READCC	; BRANCH IF NO ERRORS
01643    28D6  20 15 20     IERRI     JSR CLRDEV	; RESET DEVICES ON AN I-O ERROR
01644    28D9  00                     BRK		; TRAP
01645              .BYTE ERRI	; ?I-O ERROR ON INPUT DEVICE (#$E9)
01646    28DB  85 2B        READCC    STA CHAR	; SAVE CHAR
01647    28DD  C9 7F                  CMP #$7F	; here the Aresco code differs from the
01648    28DF  F0 5F                  BEQ RTS1	; ProgExch/6502Grp original. Was only a
01649    28E1  C9 5F                  CMP #$5F	; test for CR, but now testing for RUBOUT,
01650    28E3  F0 5B                  BEQ RTS1	; LF and CXL LINE.
01651    28E5  C9 0A                  CMP #$0A	;   --dhh
01652    28E7  F0 57                  BEQ RTS1
01653    28E9  A5 6B                  LDA ECHFLG	; ECHO FLAG
01654    28EB  F0 03                  BEQ READCE
01655    28ED  A5 2B        READCR    LDA CHAR	; GET CHAR BACK
01656    28EF  60                     RTS
01657    
01658    28F0  A5 2B        READCE    LDA CHAR	; this is also not in original ProgExch code...
01659    28F2  20 02 29               JSR PRINTC
01660    28F5  C9 0D                  CMP #$0D
01661    28F7  D0 47                  BNE RTS1	; ... to here. Next line was label READCE
01662    28F9  A9 0A                  LDA #$0A	; FOLLOW CARRIAGE RETS WITH A LINE FEED
01663    28FB  20 02 29               JSR PRINTC	; PRINT IT
01664    28FE  10 ED                  BPL READCR	; UNCONDITIONAL BRANCH
01665    ; 
01666    ; PRINTC - PRINT THE CHAR IN ACCUMULATOR OR 'CHAR'
01667    ; 
01668    2900  A9 20        PSPACE    LDA #$20	; OUTPUT A SPACE
01669    2902  29 FF        PRINTC    AND #$FF	; here we're testing for a null ($00),
01670    2904  D0 02                  BNE PRNTC	; otherwise, routine branches to the
01671    2906  A5 2B                  LDA CHAR	; original ProgExch 'PRINTC'
01672    2908  48           PRNTC     PHA		; SAVE THE CHAR IN THE AC
01673    2909  A6 67                  LDX ODEV	; GET CURRENT OUTPUT DEVICE NUMBER
01674    290B  10 06                  BPL PUSEA1	; BRANCH IF DEVICE NUMBER IS POSITIVE
01675          
01676           ; ProgExch source has a 'patch' here (literally pasted on!)
01677           ; covering the next six bytes:
01678           ; LDY STOPNT   ; get pntr to next char
01679           ; JMP WSTRNG   ; *PJMP* write to string
01680           ; NOP            ; patch fill
01681    
01682    290D  20 BE 30               JSR WSTRNG     
01683    2910  4C 29 29               JMP PRRET
01684    2913  BD B9 35     PUSEA1    LDA ODSPH,X	; GET HIGH ORDER ADDR OF OUTPUT ROUTINE
01685    2916  85 60                  STA TEMP1+1	; SAVE IT
01686    2918  BD BE 35               LDA ODSPL,X	; GET LOW ORDER ADDR OF OUTPUT ROUTINE
01687    291B  85 5F                  STA TEMP1	; SAVE IT
01688    291D  68                     PLA		; GET CHAR BACK
01689    291E  48                     PHA		; BUT SAVE ACROSS CALL
01690    291F  20 5E 00               JSR JSRIND	; CALL THE ROUTINE TO DO THE OUTPUT
01691    2922  90 05                  BCC PRRET	; BRANCH IF NO ERRORS
01692    2924  20 15 20     OERRO     JSR CLRDEV	; RESET I-O DEVICES IF ERROR
01693    2927  00                     BRK		; TRAP
01694              .BYTE ERRO	; ?I-O ERROR ON OUTPUT DEVICE (#$DE)
01695    2929  68           PRRET     PLA		; RESTORE THE CHARACTER
01696    292A  60                     RTS		; AND RETURN
01697    ; 
01698    ; PACKC - PACK A CHAR INTO MEMORY
01699    ; 
01700    292B  A5 2B        PACKC     LDA CHAR	; get character
01701    292D  A4 2A        PACKC1    LDY TEXTP	; get text pointer
01702    292F  C9 7F                  CMP #$7F	; rubout?
01703    2931  F0 10                  BEQ RUB1	; yes, branch
01704    2933  C9 5F                  CMP #LINCHR	; 'line delete' char?
01705    2935  F0 29                  BEQ RUBLIN	; yes, branch
01706    2937  91 28                  STA (TXTADR),Y     ; store char to memory
01707    2939  C8           PCKRUB    INY		; +1 text pointer
01708    293A  C0 7F                  CPY #$7F	; over max line length?
01709    293C  10 03                  BPL PBIG	; yes, branch
01710    293E  84 2A        PCKRET    STY TEXTP	; save text pointer
01711    2940  60           RTS1      RTS		; and return
01712    2941  00           PBIG      BRK		; trap
01713              .BYTE LTL	; ?line too long
01714    ; 
01715    ; ROUTINE TO RUB OUT ONE CHARACTER
01716    ; 
01717    2943  C0 00        RUB1      CPY #$00	; anything to rubout?
01718    2945  F0 F7                  BEQ PCKRET	; nope, branch
01719    2947  A4 6B                  LDY ECHFLG	; has user enabled character echo?
01720    2949  D0 0E                  BNE RUB1CC	; branch if disabled
01721    294B  A4 6C                  LDY DELSPL	; need special CRT rubout?          
01722    294D  F0 05                  BEQ RUB1C	; branch if not
01723    294F  20 7D 29               JSR EATTVC	; yes, eat the char          
01724    2952  10 05                  BPL RUB1CC	; uncond. branch
01725    2954  A9 5C        RUB1C     LDA #$5C	; echo sp char '\' for rubout
01726    2956  20 08 29               JSR PRNTC
01727    2959  A4 2A        RUB1CC    LDY TEXTP	; load Y with text pointer
01728    295B  88                     DEY		; -1
01729    295C  10 E0                  BPL PCKRET	; RET if positive
01730    295E  30 D9                  BMI PCKRUB	; if past beginning, set to 0
01731    ; 
01732    ; ROUTINE TO RUB OUT THE ENTIRE LINE
01733    ; 
01734    ;	*** this routine is visibly patched in the ProgExch code; Aresco code
01735    ;	    below is different.  -dhh
01736    ;
01737    2960  C0 00        RUBLIN    CPY #$00	; anything to rubout?
01738    2962  F0 DA                  BEQ PCKRET	; branch if not
01739    2964  A4 6B                  LDY ECHFLG	; has user enabled char echo?
01740    2966  D0 11                  BNE RUBLR	; branch if disabled
01741    2968  A4 6C                  LDY DELSPL	; need special CRT rubout proc?
01742    296A  F0 08                  BEQ RUBLC	; branch if not
01743    296C  20 7D 29     RUBLCL    JSR EATTVC	; eat a char off CRT screen
01744    296F  C6 2A                  DEC TEXTP	; zap it from buffer
01745    2971  D0 F9                  BNE RUBLCL	; loop til all zapped
01746    2973  60                     RTS     
01747    2974  A9 5F        RUBLC     LDA #$5F	; echo 'line del' character
01748    2976  20 08 29               JSR PRNTC
01749    2979  A0 00        RUBLR     LDY #$00	; reset text pointer
01750    297B  F0 C1                  BEQ PCKRET	; and RET
01751    ; 
01752    ; EAT A CRT CHAR WITH BS-SPC-BS SEQUENCE
01753    ; 
01754    297D  20 83 29     EATTVC    JSR BACKSP	; output a BS
01755    2980  20 00 29               JSR PSPACE	; followed by a space
01756    2983  A9 08        BACKSP    LDA #$08	; get BS char
01757    2985  4C 02 29               JMP PRINTC	; * PJMP * output it and return
01758    ; 
01759    ; 'GETC' GET A CHAR FROM MEMORY, ECHO IF TRACE ON
01760    ; 
01761    2988  A4 20        GETCX     LDY DEBGSW	; is trace disabled?
01762    298A  D0 17                  BNE GETC1	; yes, don't look at flag
01763    298C  A5 21                  LDA DMPSW	; flip state of the dump switch
01764    298E  49 FF                  EOR #$FF
01765    2990  85 21                  STA DMPSW	; and store it back
01766    2992  A5 24        GETC      LDA INSW	; where do we get the char from?
01767    2994  F0 03                  BEQ GETCC	; from memory
01768    2996  4C C0 28               JMP READC	; * PJMP * go get from input dev
01769    2999  A4 2A        GETCC     LDY TEXTP	; get text pointer
01770    299B  E6 2A                  INC TEXTP	; +1 to next char
01771    299D  B1 28                  LDA (TXTADR),Y	; get it
01772    299F  C9 3F                  CMP #$3F	; is it '?'
01773    29A1  F0 E5                  BEQ GETCX	; yes, go handle
01774    29A3  85 2B        GETC1     STA CHAR	; store away for others
01775    29A5  A5 20                  LDA DEBGSW	; check to see if we print it
01776    29A7  05 21                  ORA DMPSW	; for debugging
01777    29A9  D0 03                  BNE GETRT1	; no
01778    29AB  20 F0 28               JSR READCE	; print only if both are 0
01779    29AE  A5 2B        GETRT1    LDA CHAR	; get char back
01780    29B0  60                     RTS		; and RET
01781    ;
01782        ; the ProgramExchange/6502Group code has a 'patch'
01783        ; over GETC1:
01784        ; GETC1     STA CHAR     ; STORE IT
01785        ;           PHA          ; SAVE ON STACK
01786        ;           LDA DEBGSW     ; DO WE PRINT IT?
01787        ;           ORA DMPSW     ; FOR DEBUGGING
01788        ;           BNE TESTN+7     ; NO
01789        ;           PLA          ; GET CHAR BACK
01790        ;           JSR TRACBG     ; FIX FOR TRACE BUG
01791        ;           RTS          ; CHAR IS RETURNED
01792    ; 
01793    ; 'SPNOR' ROUTINE TO IGNORE LEADING SPACES
01794    ; 
01795    29B1  20 92 29     GSPNOR    JSR GETC	; CALL GETC FIRST
01796    29B4  A5 2B        SPNOR     LDA CHAR	; GET THE CHAR
01797    29B6  C9 20                  CMP #$20	; IS IT A SPACE?
01798    29B8  F0 F7                  BEQ GSPNOR	; YES, THEN IGNORE
01799    29BA  60                     RTS		; NO, RETURN
01800    ; 
01801    ; "TESTN"  TESTS TO SEE IF CHARACTER IS A NUMBER
01802    ; 
01803    29BB  20 B1 29     TESTNS    JSR GSPNOR	; GET NEXT NON-BLANK
01804    29BE  A5 2B        TESTN     LDA CHAR	; GET CHAR
01805    29C0  48           TESTN1    PHA		; SAVE CHAR ON STACK
01806    29C1  49 30                  EOR #$30	; CONVERT TO BCD (IF A NUMBER)
01807    29C3  C9 0A                  CMP #$0A	; SET C BIT IF GREATER THAN 9
01808    29C5  68                     PLA		; RETORE CHARACTER TO ACCUMULATOR
01809    29C6  60                     RTS		; RETURN (C BIT CLEAR IF NUMBER)
01810    ; 
01811    ;           'EVAL' - EXPRESSION EVALUATOR
01812    ; 
01813    ; 'EVAL' - EVALUATE AN EXPRESSION (RECURSIVE)
01814    ; 
01815    29C7  A9 00        EFUN      LDA #$00	; GET A ZERO
01816    29C9  0A           EFUNL     ASL		; ROTATE LEFT TO HASH
01817    29CA  85 65                  STA ETEMP1	; SAVE IT
01818    29CC  20 92 29               JSR GETC	; GET NEXT CHARACTER OF FUNCTION NAME
01819    29CF  20 3E 2B               JSR TTERMS	; TERMINATOR?
01820    29D2  F0 07                  BEQ EFNAME	; BRANCH IF END OF NAME
01821    29D4  29 1F                  AND #$1F	; KEEP ONLY 5 BITS
01822    29D6  18                     CLC
01823    29D7  65 65                  ADC ETEMP1	; ADD IN THE HASH
01824    29D9  D0 EE                  BNE EFUNL     ; UNCONDITIONALLY LOOP FOR MORE
01825    29DB  C9 28        EFNAME    CMP #$28	; '(' LEFT PAREN?
01826    29DD  F0 02                  BEQ EFUNC     ; BRANCH IF YES
01827    29DF  00                     BRK		; TRAP
01828              .BYTE PFERR	; ?PARENTHESES ERROR IN FUNCTION
01829    29E1  A5 65        EFUNC     LDA ETEMP1	; GET THE HASH CODE FOR FUNCTION NAME
01830    29E3  20 31 28               JSR PUSHA     ; SAVE FOR LATER
01831    29E6  20 1C 28               JSR PUSHJ     ; MOVE PAST PAREN, EVALUATE 1ST ARGUMENT
01832              .BYTE $3,$2A
01833    29EB  20 3F 28               JSR POPA	; GET THE NAME BACK AGAIN
01834    29EE  AA                     TAX		; TRANSFER TO X REGISTER
01835    29EF  20 1C 28               JSR PUSHJ     ; AND GO DO THE FUNCTION
01836              .WORD	EVALM1
01837    29F4  4C CD 2A               JMP ERPAR     ; GO SEE IF TERMINATOR IS A RIGHT PAREN.
01838    ; 
01839    ; HERE FOR A QUOTED CONSTANT
01840    ; 
01841    29F7  20 92 29     ECHAR     JSR GETC	; GET CHARACTER FOLLOWING QUOTE
01842    29FA  20 41 32               JSR FLT8	; AND MAKE IT A FLOATING POINT NUMBER
01843    29FD  20 92 29               JSR GETC	; MOVE PAST CHARACTER
01844    2A00  4C 83 2A               JMP OPNEXT	; AND CHECK FOR OPERATOR
01845    ; 
01846    ; *** MAIN ENTRY POINT(S) TO 'EVAL' ***
01847    ; 
01848    2A03  20 92 29     EVALM1    JSR GETC	; ENTER HERE TO GET PAST CURRENT CHARACTER
01849    2A06  A9 00        EVAL      LDA #$00	; ASSUME LOWEST LEVEL ARITHMETIC OPERATION
01850    2A08  85 75                  STA LASTOP
01851    2A0A  85 3B                  STA STRSWT	; MAKE SURE STRING VAR SWITCH IS OFF
01852    2A0C  20 CB 2C               JSR ZRFAC1	; ASSUME VALUE OF EXPRESSION IS ZERO
01853    2A0F  A5 75        ARGNXT    LDA LASTOP	; SAVE LAST OPERATION ON STACK
01854    2A11  20 31 28               JSR PUSHA
01855    2A14  20 3E 2B               JSR TTERMS	; GO SEE IF THIS CHARACTER IS A TERMINATOR
01856    2A17  D0 03                  BNE ECHKC	; BRANCH IF NOT
01857    2A19  4C C4 2A               JMP ETERM1	; YES, THEN HANDLE
01858    2A1C  C9 46        ECHKC     CMP #$46	; 'F' IS IT A FUNCTION?
01859    2A1E  F0 A7                  BEQ EFUN	; BRANCH IF YES
01860    2A20  C9 27                  CMP #$27	; ''' IS IT A CHARACTER CONSTANT?
01861    2A22  F0 D3                  BEQ ECHAR     ; BRANCH IF YES
01862    2A24  C9 2E                  CMP #$2E	; '.' IS IT A FRACTION?
01863    2A26  F0 1C                  BEQ ENUM	; BRANCH IF YES, CALL FLOATING P. ROUTINE
01864    2A28  20 C0 29               JSR TESTN1	; NO, BUT IS IT A NUMBER?
01865    2A2B  B0 28                  BCS EGTVAR	; BRANCH IF NOT A NUMBER
01866                  ; *** START OF KLUDGE HACK
01867                  ;     TO SPEED THINGS UP ***
01868    2A2D  A5 24                  LDA INSW	; ARE WE INPUTTING FROM INPUT DEVICE?
01869    2A2F  D0 13                  BNE ENUM	; BRANCH IF YES, CALL FLOAT PT ROUTINE
01870    2A31  A2 02                  LDX #$02	; NO, THEN WE CAN LOOK AHEAD TO SEE IF
01871    2A33  A4 2A                  LDY TEXTP     ;   CONSTANT IS IN RANGE 0-99
01872    2A35  B1 28        KLOOP     LDA (TXTADR),Y	; GET NEXT CHAR
01873    2A37  C8                     INY		; BUMP POINTER
01874    2A38  C9 2E                  CMP #$2E	; '.' DOES NUMBER HAVE A FRACTIONAL PART
01875    2A3A  F0 08                  BEQ ENUM	; BRANCH IF IT DOES, CALL F.P. ROUTINE
01876    2A3C  20 C0 29               JSR TESTN1	; IS THIS CHAR A DIGIT 0-9 ALSO?
01877    2A3F  B0 09                  BCS FSTNUM	; BRANCH IF NOT, THEN CALL FAST INPUT
01878    2A41  CA                     DEX		; CAN ONLY HAVE UP TO TWO DIGITS
01879    2A42  D0 F1                  BNE KLOOP     ; LOOK AT NEXT ONE
01880                            ; IF WE FALL OUT OF THE LOOP, WE HAVE TO
01881    2A44  20 27 34     ENUM      JSR FINP	;   CALL FLOAT PT. INPUT ROUTINE (SLOW!)
01882    2A47  4C 83 2A               JMP OPNEXT	; AND LOOP FOR OPERATOR
01883    2A4A  A5 2B        FSTNUM    LDA CHAR	; GET FIRST DIGIT OF NUMBER
01884    2A4C  20 C2 2D               JSR GETIN     ; CALL FAST INPUT ROUTINE FOR #S 0-99
01885    2A4F  20 41 32               JSR FLT8	; CALL FAST ONE-BYTE FLOAT ROUTINE
01886    2A52  4C 83 2A               JMP OPNEXT	;    AND LOOK FOR OPERATOR
01887    		; *** END OF KLUDGE HACK ***
01888    2A55  20 1C 28     EGTVAR    JSR PUSHJ     ; IT MUST BE A VARIABLE, GET VALUE
01889              .WORD GETVAR	; or .WORD GETVAR
01890    2A5A  A5 2B                  LDA CHAR	; GET CHARACTER THAT TERMINATED THE VARIB
01891    2A5C  C9 3D                  CMP #$3D	; '=' DOES HE WANT SUBSTITUTION?
01892    2A5E  D0 23                  BNE OPNEXT	; BRANCH IF NOT, JUST A TERM
01893    2A60  A2 37                  LDX #VARADR	; YES, THEN SAVE THE INFO ABOUT THIS VARIB
01894    2A62  A0 05                  LDY #$05
01895    2A64  20 6B 28               JSR PUSHB0	;   ONTO THE STACK
01896    2A67  20 1C 28               JSR PUSHJ     ; CALL OURSELVES TO EVAL THE EXPRESSION
01897              .WORD EVALM1	; or .WORD EVALM1
01898    2A6C  A2 3B                  LDX #VARADR+4	; RESTORE POINTERS TO VARIABLE
01899    2A6E  A0 05                  LDY #$05
01900    2A70  20 5B 28               JSR POPB0
01901    2A73  A5 3B                  LDA STRSWT	; WAS THE VARIABLE A STRING VARIABLE?
01902    2A75  D0 05                  BNE SETSTR	; BRANCH IF IT WAS
01903    2A77  20 A1 2C               JSR PUTVAR	; NO, THEN STORE EXPRESS VALUE AS VARIB'S
01904    2A7A  F0 07                  BEQ OPNEXT	;   VALUE - IS ALSO VALUE OF THIS TERM
01905    2A7C  20 93 2F     SETSTR    JSR INTGER	; KEEP ONLY 8 BITS FOR VALUE
01906    2A7F  A4 3A                  LDY VSUB+1	; POINT TO POSITION IN STRING
01907    2A81  91 37                  STA (VARADR),Y	; STORE IT INTO $, FALL INTO...
01908    2A83  20 3E 2B     OPNEXT    JSR TTERMS	; GO SEE IF NEXT NON-SPACE IS SPECIAL
01909    2A86  D0 04                  BNE MISOPR	; BRANCH IF NOT
01910    2A88  E0 06                  CPX #$06	; LEFT PAREN?
01911    2A8A  D0 08                  BNE OPNXT1	; NO, THAT'S GOOD AS WE CAN'T HAVE 1 HERE
01912    2A8C  00           MISOPR    BRK		; TRAP TO ERROR HANDLER
01913              .BYTE OPRMIS	; ?OPERATOR MISSING - EVAL
01914    2A8E  4C 0F 2A     JARGN     JMP ARGNXT	; BRANCH AID
01915    2A91  20 4B 28     EVALRT    JSR POPJ	; RETURN FROM CALL TO "EVAL"
01916    
01917    2A94  E0 07        OPNXT1    CPX #$07	; IS THIS A DELIMITER?
01918    2A96  30 02                  BMI OPNXT2	; BRANCH IF NOT
01919    2A98  A2 00                  LDX #$00	; YES, THEN THE OPERATION LEVEL IS LOWEST
01920    2A9A  20 3F 28     OPNXT2    JSR POPA	; GET LAST OPERATION LEVEL
01921    2A9D  85 5F                  STA TEMP1     ; SAVE IT FOR COMPARE
01922    2A9F  E4 5F                  CPX TEMP1     ; IS THIS OPER LVL < OR = TO LAST ONE?
01923    2AA1  30 02                  BMI DOBOP     ; BRANCH IF YES
01924    2AA3  D0 12                  BNE ESTACK	; BRANCH IF NO
01925    2AA5  09 00        DOBOP     ORA #$00	; TO RESET FLAGS AFTER CPX
01926    2AA7  85 75                  STA LASTOP	; YES, THEN GET THE LAST OPERATOR
01927    2AA9  F0 E6                  BEQ EVALRT	; IF LOWEST LEVEL, THEN WE ARE ALL DONE
01928    2AAB  8A                     TXA		; SAVE 'THISOP'
01929    2AAC  48                     PHA		; ON HARDWARE STACK
01930    2AAD  20 9A 28               JSR PLFAC2	; POP PARTIAL RESULT BACK INTO FAC2
01931    2AB0  20 E8 2A               JSR EVBOP     ; AND GO DO THE OPERATION LEAVING THE
01932    			;   RESULT IN FLAC
01933    2AB3  68                     PLA		; GET 'THISOP' BACK
01934    2AB4  AA                     TAX
01935    2AB5  10 E3                  BPL OPNXT2	; UNCOND. BRANCH WITH NEW PARTIAL RESULT.
01936    
01937    2AB7  20 31 28     ESTACK    JSR PUSHA	; SAVE BACK ON STACK FOR LATER COMPUTATION
01938    2ABA  86 75                  STX LASTOP	; NOW UPDATE 'LASTOP' TO 'THISOP'
01939    2ABC  20 79 28               JSR PHFAC1	; SAVE PARTIAL RESULT ON STACK
01940    2ABF  20 92 29               JSR GETC	; SKIP OVER THE OPERATOR
01941    2AC2  10 CA                  BPL JARGN	; UNCOND. BRANCH TO PICK UP NEXT ARGUMENT
01942    2AC4  E0 06        ETERM1    CPX #$06	; LEFT PAREN?
01943    2AC6  D0 12                  BNE ETERM2	; BRANCH IF NOT
01944    2AC8  20 1C 28               JSR PUSHJ	; ENTERING NEW LEVEL OF NESTING, SO CALL
01945              .WORD EVALM1	; OURSELVES TO EVALUATE IT!
01946    2ACD  A5 2B        ERPAR     LDA CHAR	; GET THE DELIMITER THAT ENDED THIS LEVEL
01947    2ACF  48                     PHA		; SAVE IT MOMENTARILY
01948    2AD0  20 92 29               JSR GETC	; MOVE PAST IT
01949    2AD3  68                     PLA		; GET DELIMITER BACK
01950    2AD4  C9 29                  CMP #$29	; ')' RIGHT PAREN?
01951    2AD6  F0 AB                  BEQ OPNEXT	; YES. GO PICK UP NEXT OPERATOR
01952    2AD8  00           EPMISS    BRK		; TRAP TO ERROR HANDLER
01953              .BYTE PMATCH	; ?PARENTHESIS MISMATCH - EVAL
01954    2ADA  E0 07        ETERM2    CPX #$07	; DELIMITER ON RIGHT-HAND SIDE?
01955    2ADC  10 04                  BPL ETERM3	; BRANCH IF YES
01956    2ADE  E0 03                  CPX #$03	; OR UNARY OPERATOR
01957    2AE0  10 04                  BPL MISOPN	; NO, THEN IT CAN'T BE HERE
01958    2AE2  A5 75        ETERM3    LDA LASTOP	; PICK UP OPERATION LEVEL
01959    2AE4  F0 AE                  BEQ OPNXT1	; ONLY ALLOW IF AT LOWEST LEVEL
01960    2AE6  00           MISOPN    BRK		; TRAP TO ERROR HANDLER
01961              .BYTE OPNMIS	; ?OPERAND MISSING - EVAL
01962    
01963    2AE8  A6 75        EVBOP     LDX LASTOP	; GET THE ARITHMETIC OPERATION TO PERFORM
01964    2AEA  BD 80 35               LDA EVDSPH,X	; GET THE HIGH-ORDER ADDR OF ROUTINE
01965    2AED  85 60                  STA TEMP1+1	; STORE IT
01966    2AEF  BD 85 35               LDA EVDSPL,X	; GET THE LOW-ORDER ADDR OF ROUTINE
01967    2AF2  85 5F                  STA TEMP1	; STORE IT
01968    2AF4  6C 5F 00               JMP ($005F)	; * PJMP * TO ROUTINE TO DO THE OPERATION
01969    ; 
01970    ; 
01971    ;           EVALUATE A POWER
01972    ; 
01973    ; *** NOTE: THIS ROUTINE IS CURRENTLY RESTRICTED TO RAISING
01974    ;           THE NUMBER TO AN INTEGER POWER WITHIN THE RANGE
01975    ;           OF + OR - 32,767          (label: EVPOWR)
01976    ; 
01977    2AF7  20 A7 2F     EVPOWR    JSR INTFIX	; GET EXPONENT
01978    2AFA  85 55                  STA ITMP1L	; STORE IT AWAY
01979    2AFC  A5 82                  LDA M1+1	; AS NUMBER OF TIMES TO DO OPERATION
01980    2AFE  85 56                  STA ITMP1H
01981    2B00  A2 9B                  LDX #FONE	; GET THE CONSTANT 1.0 INTO FAC1
01982    2B02  A0 80                  LDY #FAC1
01983    2B04  20 FF 33               JSR MOVXY
01984    2B07  A5 56                  LDA ITMP1H	; RAISING TO A NEGATIVE POWER?
01985    2B09  30 1A                  BMI NPOWR	; BRANCH IF WE ARE
01986    2B0B  A9 FF        POWRLP    LDA #$FF	; POSITIVE POWER, ARE WE DONE YET?
01987    2B0D  C6 55                  DEC ITMP1L
01988    2B0F  C5 55                  CMP ITMP1L
01989    2B11  D0 02                  BNE POWR1	; BRANCH IF HIGH ORDER OK
01990    2B13  C6 56                  DEC ITMP1H	; DECREMENT HIGH ORDER
01991    2B15  C5 56        POWR1     CMP ITMP1H	; DONE YET?
01992    2B17  F0 32                  BEQ TTRET	; YES, THEN RETURN
01993    2B19  20 84 28               JSR PHFAC2	; NO, SAVE FAC2
01994    2B1C  20 A0 32               JSR FMUL	; NUMBER TIMES ITSELF (EXCEPT FIRST TIME)
01995    2B1F  20 9A 28               JSR PLFAC2	; RESTORE NUMBER TO FAC2
01996    2B22  4C 0B 2B               JMP POWRLP	; AND KEEP MULTIPLYING
01997    ; 
01998    ; HERE IF RAISING TO A NEGATIVE POWER
01999    ; 
02000    2B25  A5 56        NPOWR     LDA ITMP1H	; DONE YET?
02001    2B27  F0 22                  BEQ TTRET     ; BRANCH IF ALL DONE
02002    2B29  E6 55                  INC ITMP1L	; NO, THEN COUNT UP SINCE COUNT IS NEG.
02003    2B2B  D0 02                  BNE NPOWR1
02004    2B2D  E6 56                  INC ITMP1H	; INCREMENT HIGH ORDER ALSO
02005    2B2F  20 29 32     NPOWR1    JSR SWAP	; PUT PARTIAL INTO FAC2, 'X' INTO FAC1
02006    2B32  20 79 28               JSR PHFAC1	; SAVE 'X'
02007    2B35  20 CA 32               JSR FDIV	; 1/(X*X*X*X...)
02008    2B38  20 9A 28               JSR PLFAC2	; RESTORE 'X'
02009    2B3B  4C 25 2B               JMP NPOWR     ; AND LOOP TILL DONE
02010    ; 
02011    ;           'ROUTINES USED BY "EVAL" '
02012    ; 
02013    ; TEST TO SEE IF CHARACTER IS A SPECIAL TERMINATOR
02014    ; 
02015    2B3E  20 B4 29     TTERMS    JSR SPNOR     ; IGNORE SPACES, GET NEXT NON-BLANK CHAR
02016    2B41  A2 0C                  LDX #$0C	; GET MAX TABLE OFFSET; 'trmax in ProgExch code'
02017    2B43  DD E8 34     TRMCHK    CMP TRMTAB,X	; MATCH?
02018    2B46  F0 03                  BEQ TTRET	; YES, RETURN WITH Z=1
02019    2B48  CA                     DEX		; POINT TO NEXT ENTRY
02020    2B49  10 F8                  BPL TRMCHK	; AND CHECK IT
02021    2B4B  60           TTRET     RTS		; RETURN (NOTE: Z=0 IF CANNOT FIND)
02022    ; 
02023    ;           'GETVAR' - GET A VARIABLE FROM VARIABLE LIST
02024    ; 
02025    ; "GETVAR" - GET A VARIABLE FROM THE VARIABLE LIST
02026    ;            OTHERWISE CREATE IT AND ASSIGN IT A VALUE OF ZERO
02027    ; 
02028    2B4C  4C D8 2A     GPMISS    JMP EPMISS	; BRANCH AID
02029    2B4F  00           GTERR3    BRK		; TRAP
02030              .BYTE FUNILL	; ?FUNCTION ILLEGAL HERE
02031    2B51  A9 00        GETVAR    LDA #$00	; ASSUME VARIABLE IS NOT A STRING
02032    2B53  85 3B                  STA STRSWT
02033    2B55  20 B4 29               JSR SPNOR	; (DEFENSIVE!) GET THE CHARACTER
02034    2B58  C9 26                  CMP #$26	; '&' IS IT SPECIAL 'FSBR' SCRATCH VARIB?
02035    2B5A  F0 0A                  BEQ VAROK	; YES, THEN NAME IS OK
02036    2B5C  C9 41                  CMP #$41	; 'A' IS IT ALPHABETIC?
02037    2B5E  30 04                  BMI VARBAD	; BRANCH IF NOT
02038    2B60  C9 5B                  CMP #$5B	; '[' Z+1
02039    2B62  30 02                  BMI VAROK     ; BRANCH IF ALPHABETIC
02040    2B64  00           VARBAD    BRK		; NOT ALPHABETIC
02041              .BYTE BADVAR	; ?BAD VARIABLE NAME
02042    2B66  C9 46        VAROK     CMP #$46	; 'F' FUNCTION?
02043    2B68  F0 E5                  BEQ GTERR3	; BRANCH IF YES
02044    2B6A  0A                     ASL 
02045    2B6B  0A                     ASL 
02046    2B6C  0A                     ASL 		; SHIFT ALPHA LEFT 3
02047    2B6D  48                     PHA		; SAVE IT
02048    2B6E  20 92 29               JSR GETC	; GET NEXT CHARACTER
02049    2B71  49 30                  EOR #$30	; CONVERT TO BCD IF A NUMBER
02050    2B73  C9 08                  CMP #$08	; IS IT 0-7?
02051    2B75  B0 09                  BCS VARDUN	; IF NOT, NAME IS ON STACK
02052    2B77  85 3D                  STA VCHAR	; IF YES, SAVE IT
02053    2B79  68                     PLA		; GET BACK ALPHA PART
02054    2B7A  05 3D                  ORA VCHAR	; PUT THE PARTS TOGETHER
02055    2B7C  48                     PHA		; AND STICK ON STACK
02056    2B7D  20 92 29               JSR GETC	; GET A NEW CHARACTER IN CHAR
02057    ; 
02058    ; 
02059    ; X X X X X X X X X X X X X X X X X X X X X X X X X X X
02060    ;
02061    ; *** here begins transcription work done by Nils Andreas (2023)
02062    ; 
02063    ; 
02064    
02065    
02066    2B80  A5 2B        VARDUN    LDA CHAR
02067    2B82  C9 24                  CMP #$24	; '$' STRING VARIABLE?
02068    2B84  D0 05                  BNE VARDN1	;BRANCH IF NOT, PRESS ON
02069    2B86  85 3B                  STA STRSWT	;YES, FLAG THE FACT
02070    2B88  20 92 29               JSR GETC	;AND MOVE TO THE '3'
02071    2B8B  68           VARDN1    PLA		;GET VARIABLE OFF STACK
02072    2B8C  20 31 28               JSR PUSHA	;PUT NAME ON SOFT STACK
02073    2B8F  20 B4 29               JSR SPNOR	;GET NEXT NON-BLANK
02074    2B92  C9 28                  CMP #$28	; '(' LEFT PAREN?
02075    2B94  F0 06                  BEQ VARSUB	;BRANCH IF VARIABLE HAS A SUBSCRIPT
02076    2B96  A9 00                  LDA #$00	;OTHERWISE ASSUME 0
02077    2B98  85 3A                  STA VSUB+1	;ZERO THE SUBSCRIPT
02078    2B9A  F0 21                  BEQ VARSOK	;AND PROCESS IT
02079    2B9C  A5 3B        VARSUB    LDA STRSWT	;SAVE STRING FLAG
02080    2B9E  20 31 28               JSR PUSHA
02081    2BA1  20 1C 28               JSR PUSHJ	;CALL EAVL TO CALCULATE SUBSCRIPT
02082              .WORD EVALM1          
02083    2BA6  20 3F 28               JSR POPA	;RESTORE STRING FLAG
02084    2BA9  85 3B                  STA STRSWT
02085    2BAB  A5 2B                  LDA CHAR	;GET TERMINATOR
02086    2BAD  C9 29                  CMP #$29	; ')' PAREN MATCH?
02087    2BAF  D0 9B                  BNE GPMISS	;BRANCH IF NOT
02088    2BB1  20 92 29               JSR GETC	;MOVE PAST THE RIGHT PAREN (TYPO?)
02089    2BB4  20 18 33               JSR FIX	;MAKE SUBSCRIPT AN INTEGER
02090    2BB7  A5 83                  LDA X1+3	;GET LOW ORDER BYTE
02091    2BB9  85 3A                  STA VSUB+1	;STORE IT
02092    2BBB  A5 82                  LDA X1+2	;GET HIGH ORDER BYYTE (NOTE:16 BIT)
02093    2BBD  85 39        VARSOK    STA VSUB	;SAVE FOR LATER
02094    2BBF  20 3F 28               JSR POPA	;GET THE VARIABLE NAME BACK
02095    2BC2  85 3D                  STA VCHAR	;SAVE IT
02096    2BC4  20 76 2C     FNDVAR    JSR VARINI	;SET ADDR TO START OF VARIABLE LIST
02097    2BC7  A0 00        CHKVAR    LDY #$00	;SET OFFSET TO ZERO
02098    2BC9  B1 37                  LDA(VARADR),Y	;GET THE VARIABLE NAME
02099    2BCB  C9 FF                  CMP #EOV	;IS THIS THE END OF THE VARIABLE LIST?     
02100    2BCD  F0 57                  BEQ NOVAR	;BRANCH IF END OF LIST
02101    2BCF  C9 FC                  CMP #STRMRK	;IS THIS VARIABLE IN THE LIST A STRING VARIABLE?
02102    2BD1  F0 09                  BEQ CHKSTR	;BRANCH IF YES, WE HANDLE DIFFERENTLY
02103    2BD3  C5 3D                  CMP VCHAR	;ARE THE NAMES THE SAME
02104    2BD5  F0 37                  BEQ CHKSUB	;YES, GO SEE IF THE SUBSCRIPTS ARE EQUAL
02105    2BD7  20 7F 2C     NOTVAR    JSR NXTVAR	;POINT TO NEXT VARIABLE IN LIST
02106    2BDA  D0 EB                  BNE CHKVAR	;UNCONDITIONAL BRANCH TO CHECK NEXT VARIABLE
02107    2BDC  A5 3B        CHKSTR    LDA STRSWT	;ARE WE LOOKING FOR A STRING VARIABLE?
02108    2BDE  F0 1E                  BEQ SKPSTR	;BRANCH IF NOT, JUST SKIP OVER THIS STRING VARIB
02109    2BE0  A5 3D                  LDA VCHAR	;YES, THEN GET IT'S NAME
02110    2BE2  C8                     INY		;POINT TO NAME OF STRING VARIABLE IN VAR LIST 
02111    2BE3  D1 37                  CMP(VARADR),Y	;IS THIS THE ONE WE ARE LOOKING FOR?
02112    2BE5  D0 18                  BNE SKPST1	;BRANCH IF NOT, JUST SKIP IT OVER
02113    2BE7  C8                     INY		;YES, THIS IS THE ONE, GET THE SIZE OF THE
02114    2BE8  B1 37                  LDA(VARADR),Y	;STRING
02115    2BEA  85 3C                  STA VSIZE	;STORE FOR THOSE WHO NEED IT
02116    2BEC  C8                     INY		;AND UPDATE
02117    2BED  98                     TYA
02118    2BEE  20 81 2C               JSR UPDVAR	;'VARADR' TO POINT TO BASE ADDR OF STRING
02119    2BF1  A4 3A        GETSTC    LDY VSUB+1	;GET SUBSCRIPT (POSITION) OF BYTE WE WANT
02120    2BF3  B1 37                  LDA(VARADR),Y	;GET THE BYTE WE WANT
02121    2BF5  85 82                  STA M1+1	;STORE AS LOW ORDER 8 BITS
02122    2BF7  A9 00                  LDA #$00
02123    2BF9  85 81                  STA M1	;ZERO HIGH ORDER
02124    2BFB  4C E3 2E               JMP FL16PJ	;*PJMP* FLOAT AND RETURN THE VALUE
02125    2BFE  C8           SKPSTR    INY		;MOVE OVER STRING VARIABLE'S NAME
02126    2BFF  C8           SKPST1    INY		;POINT TO STRING VARIABLE'S LENGTH
02127    2C00  B1 37                  LDA(VARADR),Y	;GET THE STRING LENGTH
02128    2C02  48                     PHA		;SAVE IT
02129    2C03  C8                     INY		;POINT TO FIRST BYTE IN STRING
02130    2C04  98                     TYA		;UPDATE 'VARADR' TO BASE OF STRING
02131    2C05  20 81 2C               JSR UPDVAR               
02132    2C08  68                     PLA		;GET SIZE OF STRING
02133    2C09  20 81 2C               JSR UPDVAR	;UPDATE 'VARADR' BY PROPER AMOUNT
02134    2C0C  D0 B9                  BNE CHKVAR	;AND LOOK FOR NEXT VARIABLE IN LIST
02135    2C0E  A5 3B        CHKSUB    LDA STRSWT	;ARE WE LOOKING FOR A STRING VARIABLE
02136    2C10  D0 C5                  BNE NOTVAR	;BRANCH IF WE ARE, CAN'T BE THIS NUMERIC VARIABLE
02137    2C12  A5 39                  LDA VSUB	;GET HIGH ORDER SUBSCRIPT WE ARE LOOKING FOR
02138    2C14  C8                     INY		;POINT TO SUBSCRIPT IN LIST
02139    2C15  D1 37                  CMP(VARADR),Y	;ARE THEY THE SAME?     
02140    2C17  D0 BE                  BNE NOTVAR	;BRANCH IF THIS ONE IS NOT IT
02141    2C19  A5 3A                  LDA VSUB+1	;ARE LOW ORDERS ALSO THE SAME?
02142    2C1B  C8                     INY
02143    2C1C  D1 37                  CMP(VARADR),Y          
02144    2C1E  D0 B7                  BNE NOTVAR	;BRANCH IF THEY ARE NOT THE SAME
02145    2C20  20 AE 2C     LOCVAR    JSR FETVAR	;GET THE VARIABLE'S VALUE INTO FLAC
02146    2C23  20 4B 28               JSR POPJ	;AND RETURN TO CALLER 
02147    2C26  A5 3B        NOVAR     LDA STRSWT	;IS THIS STRING A VARIABLE 
02148    2C28  D0 21                  BNE NOSTR	;BRANCH IF IT IS A STRING VARIABLE 
02149    2C2A  A5 3D                  LDA VCHAR	;GET THE VARIABLE'S NAME 
02150    2C2C  91 37                  STA (VARADR),Y	;STORE IT IN LIST
02151    2C2E  C8                     INY		;POINT TO NEXT IN LIST
02152    2C2F  A5 39                  LDA VSUB	;GET HIGH ORDER SUBSCRIPT
02153    2C31  91 37                  STA (VARADR),Y	;SAVE IT IN LIST
02154    2C33  C8                     INY		;POINT TO NEXT
02155    2C34  A5 3A                  LDA VSUB+1	;GET LOW ORDER SUBSCRIPT
02156    2C36  91 37                  STA (VARADR),Y	;SAVE IT IN LIST
02157    2C38  A9 00                  LDA #$00	;GET A ZERO
02158    2C3A  A2 06                  LDX #NUMBF+1	;GET COUNT OF NUMBER OF BYTES IN NUMBER
02159    2C3C  C8           ZERVAR    INY		;POINT TO THE NEXT VARIABLE
02160    2C3D  91 37                  STA (VARADR),Y	;ZERO OUT VARIABLES VALUE
02161    2C3F  CA                     DEX		;COUNT THIS BYTE
02162    2C40  D0 FA                  BNE ZERVAR	;LOOP TILL DONE. NOTE: EXTRA ZERO AT END
02163    2C42  A9 FF                  LDA #EOV	;FLAG END OF VARIABLE LIST
02164    2C44  91 37                  STA (VARADR),Y	;FLAG END OF VARIABLE LIST
02165    2C46  20 8D 2C               JSR UPDEND	;UPDATE THE END OF THE VARIABLE LIST
02166    2C49  D0 D5                  BNE LOCVAR	;UNCONDITIONAL BRANCH, AS WE HAVE FOUND
02167    			;THE VARIABLE
02168    
02169    ; *** BEGIN GAVIN D. SECTION
02170    
02171    ;
02172    ; 
02173    ;  HERE WHEN STRING VARIABLE WAS NOT FOUND
02174    ; 
02175    
02176    2C4B  A9 FC        NOSTR     LDA #STRMRK	;ADD A STRING MARKER AT THE END OF VARIABLE LIST
02177    2C4D  91 37                  STA (VARADR),Y
02178    2C4F  C8                     INY
02179    2C50  A5 3D                  LDA VCHAR	;ADD IT'S NAME
02180    2C52  91 37                  STA (VARADR),Y
02181    2C54  C8                     INY
02182    2C55  A5 64                  LDA STRSIZ	;GET DEFAULT STRING SIZE
02183    2C57  91 37                  STA (VARADR),Y	;STORE AS SIZE OF STRING
02184    2C59  85 3C                  STA VSIZE	;ALSO STORE FOR OTHERS WHO NEED TO KNO
02185    2C5B  C8                     INY		;POINT TO FIRST BYTE OF STRING
02186    2C5C  98                     TYA		;UPDATE 'VARADR'
02187    2C5D  20 81 2C               JSR UPDVAR
02188    2C60  A0 00                  LDY #$00	;POINT TO FIRST BYTE OF STRING
02189    2C62  A9 20                  LDA #$20	;GET A BLANK
02190    2C64  91 37        STRINI    STA (VARADR),Y	;SET STRING TO ALL BLANKS
02191    2C66  C8                     INY
02192    2C67  C4 64                  CPY STRSIZ	;DONE YET?
02193    2C69  D0 F9                  BNE STRINI	;NO, LOOP TILL STRING IS ALL BLANKS
02194    2C6B  A9 FF                  LDA #EOV	;GET THE END OF VARIABLE LIST MARKER
02195    2C6D  91 37                  STA (VARADR),Y	;FLAG END OF LIST
02196    2C6F  98                     TYA		;UPDATE 'VARADR'
02197    2C70  20 8F 2C               JSR UBDENV
02198    2C73  4C F1 2B               JMP GETSTC	;GET BYTE FROM STRING AND RETURN
02199    2C76  A5 3E        VARINI    LDA VARBEG	;GET ADDR OF START OF VARIABLE LIST
02200    2C78  85 37                  STA VARADR	;AND SET POINTER
02201    2C7A  A5 3F                  LDA VARBEG+1
02202    2C7C  85 38                  STA VARADR+1
02203    2C7E  60                     RTS		;AND RETURN
02204    
02205    2C7F  A9 08        NXTVAR    LDA #VARSIZ	;ADD IN SIZE OF NUMERIC VARIABLE
02206    2C81  18           UPDVAR    CLC		;SETUP FOR ADDITION
02207    2C82  65 37                  ADC VARADR	;TO 'VARADR'
02208    2C84  85 37                  STA VARADR
02209    2C86  A5 38                  LDA VARADR+1
02210    2C88  69 00                  ADC #$00
02211    2C8A  85 38                  STA VARADR+1
02212    2C8C  60                     RTS
02213    ;
02214    ; ROUTINE TO UPDATE THE END OF THE VARIABLE LIST
02215    ;
02216    2C8D  A9 08        UPDEND    LDA #VARSIZ	;ADD SIZE OF NUMERIC VARIABLE
02217    2C8F  18           UBDENV    CLC
02218    2C90  65 37                  ADC VARADR	;ADD NUMBER IN ACCUMULATOR 'VARADR'
02219    2C92  85 42                  STA VAREND	;AND STORE RESULT IN 'VAREND'
02220    2C94  A5 38                  LDA VARADR+1
02221    2C96  69 00                  ADC #$00	;ADD IN THE CARRY
02222    2C98  85 43                  STA VAREND+1
02223    2C9A  60           BOMSVR    RTS		;AND RETURN
02224    ;
02225    ;ROUTINE TO BOMB OUT IF THE VARIABLE IS A STRING VARIABLE
02226    ;
02227    2C9B  A5 3B        BOMSTV    LDA STRSWT	;GET A STRING FLAG
02228    2C9D  F0 FB                  BEQ BOMSVR	;RETURN IF NOT A STRING
02229    2C9F  00                     BRK		;TRAP
02230              .BYTE SVNA	;?STRING VARIABLE NOT ALLOWED HERE 
02231    ;
02232    ;          'VARIABLE MANIPULATION UTILITIES
02233    ;
02234    ;"PUTVAR" PUT NUMBER IN FAC1 INTO THE VARIABLE
02235    ;
02236    2CA1  A0 03        PUTVAR    LDY #$03	;POINT TO START OF VALUE
02237    2CA3  B9 7D 00     PUTV1     LDA X1-3,Y	;GET A BYTE FROM FAC1
02238    2CA6  91 37                  STA (VARADR),Y	;STORE IT INTO VARIABLE
02239    2CA8  C8                     INY		;POINT TO NEXT BYTE
02240    2CA9  C0 08                  CPY #VARSIZ	;REACHED END OF VARIABLE YET?          
02241    2CAB  D0 F6                  BNE PUTV1	;NO, THEN MOVE SOME MORE
02242    2CAD  60                     RTS		;*** MUST RETURN WITH Z BIT = ! ! ***
02243    
02244    ; "FETVAR" FETCH VARIABLE VALUE INTO FAC1
02245    
02246    2CAE  A0 03        FETVAR    LDY #$03	;POINT TO START OF VALUE
02247    2CB0  B1 37        FETV1     LDA (VARADR),Y	;GET A BYTE FROM VARIABLE
02248    2CB2  99 7D 00               STA X1-3,Y	;PUT IT INTO FAC1
02249    2CB5  C8                     INY		;POINT TO NEXT BATE
02250    2CB6  C0 08                  CPY #VARSIZ	;REACHED THE END OF VARIABLE YET?
02251    2CB8  D0 F6                  BNE FETV1	;NO, THEN MOVE ANOTHER BYTE
02252    2CBA  60                     RTS		;YES, RETURN
02253    
02254    ;"PUSHIV" PUSH INCREMENT AND VARIABLE ADDR ON STACK USED BY "FOR" COMMAND
02255    
02256    2CBB  A2 37        PUSHIV    LDX #VARADR	;POINT TO VARIABLE ADDR
02257    2CBD  20 69 28               JSR PUSHB2	;PUSH IT INTO STACK
02258    2CC0  4C 84 28               JMP PHFAC2	;* PJMP * PUSH FAC2 INTO STACK AND RETURN
02259    
02260    ;"POPIV" POP INCREMENT AND VARIABLE ADDR OFF STACK
02261    
02262    2CC3  20 9A 28     POPIV     JSR PLFAC2	;RESTORE INTO FAC2
02263    2CC6  A2 38                  LDX #VARADR+1	;POINT TO VARIABLE ADDR
02264    2CC8  4C 59 28               JMP POPB2	;* PJMP * RESTORE INTO VARIABLE ADDR AND RETURN
02265    
02266    ;ZERO THE FLOATING POINT ACCUMULATOR FACE1
02267    
02268    2CCB  A2 04        ZRFAC1    LDX #NUMBF-1	;POINT TO LAST BYTE
02269    2CCD  A9 00                  LDA #$00	;LOAD A ZERO
02270    2CCF  95 80        ZRFAC     STA X1,X	;ZERO THE BYTE
02271    2CD1  CA                     DEX		;POINT TO NEXT ONE
02272    2CD2  D0 FB                  BNE ZRFAC	;LOOP TILL ALL OF MANTISSA ZEROED
02273    2CD4  A9 80                  LDA #$80	;NOW SET EXPONENT
02274    2CD6  85 80                  STA X1
02275    2CD8  60                     RTS		;AND RETURN
02276    ;
02277    ;          'INTERRUPT HANDLERS'
02278    ;
02279    2CD9  48           NOTBRK    PHA		;SAVE THE PROCESSOR STATUS          
02280    2CDA  A9 ED                  LDA #UNKINT	;UNKNOWN INTERRUPT
02281    2CDC  48                     PHA		;SAVE CODE ON STACK
02282    2CDD  D0 22                  BNE BERROR	;AND PRINT ERROR CODE
02283    2CDF  EA           NMISRV    NOP		;CURRENTLY PUNT NMI'S AS UNKNOWNS
02284    2CE0  85 71        INTSRV    STA ACSAV	;SAVE ACCUMULATOR
02285    2CE2  68                     PLA		;GET THE PROCESSOR STATUS
02286    2CE3  24 70                  BIT MSKBRK	;IS B BIT ON?
02287    2CE5  F0 F2                  BEQ NOTBRK	;BRANCH TO INTERRUPT SERVICE CHAIN
02288    2CE7  85 72                  STA STATUS	;SAVE OLD PROCESSOR STATUS     
02289    2CE9  68                     PLA		;GET THE LOW ORDER RETURN ADDRESS
02290    2CEA  18                     CLC		;GET READY FOR ADD
02291    2CEB  69 FF                  ADC #$FF	;ADD IN A -1
02292    2CED  85 73                  STA ITEMP1	;STORE IT IN PAGE ZERO
02293    2CEF  68                     PLA		;GET HIGH ORDER RETURN ADDR
02294    2CF0  69 FF                  ADC #$FF	;ADD IN A -1
02295    2CF2  85 74                  STA ITEMP1+1	;STORE IN PAGE ZERO
02296    2CF4  98                     TYA		;GET Y REGISTER
02297    2CF5  48                     PHA		;SAVE ON STACK
02298    2CF6  A0 00                  LDY #$00	;OFFSET OF ZERO
02299    2CF8  B1 73                  LDA (ITEMP1),Y	;GET BRK CODE     
02300    2CFA  48                     PHA		;SAVE ON STACK
02301    2CFB  30 04                  BMI BERROR	;BRANCH IF A SOFTWARE DETECTED ERROR
02302    2CFD  68                     PLA		;POSITIVE ERROR CODE, GET IT BACK
02303    2CFE  A9 EE                  LDA #UNRBRK	;UNRECOGNIZABLE BREAK
02304    2D00  48                     PHA		;SAVE ON STACK
02305    ;
02306    ;          ERROR CODE OUTPUT ROUTINE
02307    ;
02308    2D01  A9 FF        BERROR    LDA #$FF	;GET -1
02309    2D03  85 81                  STA M1	;FOR HIGH ORDER
02310    2D05  68                     PLA		;GET THE NEG ERROR CODE
02311    2D06  85 82                  STA M1+1	;STORE INIC LOW ORDER
02312    2D08  20 4D 32               JSR FLT16	;FLOAT IT
02313    2D0B  20 0D 20               JSR SETUP	;RESET AND INITIALIZE IMPORTANT STUFF
02314    2D0E  20 99 2D               JSR CRLF	;ADVANCE A LINE
02315    2D11  A9 3F                  LDA #$3F	;'?' INDICATE AN ERROR
02316    2D13  20 02 29               JSR PRINTC	;
02317    2D16  20 5E 26               JSR OUTLN0	;OUTPUT IT
02318    2D19  A5 26                  LDA PC	;GET HIGH ORDER FOCAL STATEMENT COUNTER
02319    2D1B  10 04                  BPL BERR1	;BRANCH IF ERROR OCCURED IN A STORED STATEMENT
02320    2D1D  C9 FE                  CMP #STRLIN	;DID ERROR OCCUR WHILE EXECUTING A STRING?
02321    2D1F  D0 32                  BNE BERRC	;NO, THEN ERROR OCCURED IN DIRECT COMMAND
02322    2D21  A9 20        BERR1     LDA #$20	;SPACE FOR LOOKS
02323    2D23  20 02 29               JSR PRINTC	;
02324    2D26  A9 40                  LDA #$40	;NOW AN '@'
02325    2D28  20 02 29               JSR PRINTC          
02326    2D2B  A9 20                  LDA #$20	;ANOTHER SPACE FOR THE LOOKS
02327    2D2D  20 02 29               JSR PRINTC
02328    2D30  20 0A 27               JSR PUSHTP	;SAVE THE TEXTPOINTERS
02329    2D33  A5 26                  LDA PC	;EXECUTING A STRING WHEN ERROR OCCURED?
02330    2D35  10 0C                  BPL BERR2	;BRANCH IF NOT, PRINT STATEMENT NUMBER
02331    2D37  A5 27                  LDA PC+1	;YES, THEN GET THE STRING NAME
02332    2D39  20 E7 23               JSR PRTVNM	;AND PRINT IT
02333    2D3C  A9 24                  LDA #$24	;INDICATE IT'S A STRING
02334    2D3E  20 02 29               JSR PRINTC          
02335    2D41  D0 0D                  BNE BERR3	;AND UNCONDITIONALLY PRESS ON
02336    2D43  A9 26        BERR2     LDA #PC	;GET ADDR OF WHERE PROGRAM COUNTER IS STORED
02337    2D45  85 28                  STA TXTADR	;MAKE TEXT POINTER POINT TO IT
02338    2D47  A9 00                  LDA #$00
02339    2D49  85 29                  STA TXTADR+1	;HIGH ORDER IS ZERO
02340    2D4B  85 2A                  STA TEXTP
02341    2D4D  20 31 26               JSR PRNTLN	;OUTPUT THE LINE NUMBER
02342    2D50  20 11 27     BERR3     JSR POPTP	;RESTORE TEXT POINTERS
02343    			;FALL INTO 'BERRC'
02344    ;
02345    ;          'MORE INTERRUPT HANDLERS'
02346    ;
02347    2D53  20 96 2D     BERRC     JSR CRLF2	;ADVANCE TWO LINES
02348    2D56  A0 00                  LDY #$00	;POINT TO FIRST CHAR IN LINE
02349    2D58  A5 26                  LDA PC	;DIRECT COMMAND OR STRING?
02350    2D5A  30 02                  BMI OUTCMD	;BRANCH IF YES
02351    2D5C  A0 02                  LDY #$02	;NO, THEN POINT PAST LINE NUMBER
02352    2D5E  C4 2A        OUTCMD    CPY TEXTP	;ARE WE AT FRONT OF LINE?
02353    2D60  F0 31                  BEQ BERRET	;BRANCH IF YES, DON'T OUTPUT SPECIAL ERROR AID
02354    2D62  98           OUTCML    TYA		;SAVE Y OUTPUT ACROSS OUTPUT CALL
02355    2D63  48                     PHA
02356    2D64  B1 28                  LDA (TXTADR),Y	;OUTPUT CHAR FROM COMMAND LINE SO USER CAN SEE
02357    2D66  20 02 29               JSR PRINTC
02358    2D69  C9 0D                  CMP #$0D	;REACHED END OF LINE YET?
02359    2D6B  F0 05                  BEQ EREOL	;BRANCH IF YES,
02360    2D6D  68                     PLA		;RESTORE Y REG
02361    2D6E  A8                     TAY
02362    2D6F  C8                     INY		;POINT TO THE NEXT CHAR IN THE COMMAND LINE
02363    2D70  D0 F0                  BNE OUTCML	;AND LOOP TILL ALL OF THE COMMAND LINE HAS BEEN OUTPUT
02364    2D72  68           EREOL     PLA		;ADJUST STACK
02365    2D73  20 9E 2D               JSR OUTLF	;FOLLOW WITH A LINE FEED
02366    2D76  C6 2A        CHKERR    DEC TEXTP	;COUNT DOWN NUMBER OF BYTES TILL ERROR
02367    2D78  A0 00                  LDY #$00	;ASSUME WE COUNT BACK TO ZERO
02368    2D7A  A5 26                  LDA PC	;DIRECT COMMAND OR STRING
02369    2D7C  30 02                  BMI CHKERC	;BRANCH IF YES
02370    2D7E  A0 02                  LDY #$02	;NO, THEN WE ONLY COUNT BACK TO LINE NUMBER
02371    2D80  C4 2A        CHKERC    CPY TEXTP	;HAVE WE OUTPUT ENOUGH SPACES TO GET ERROR BYTE?
02372    2D82  F0 07                  BEQ EARROW	;BRANCH IF YES, OUTPUT UPARROW TO FLAG CHARACTER
02373    2D84  A9 20                  LDA #$20	;NO, THEN ADVANCE ONE SPACE
02374    2D86  20 02 29               JSR PRINTC          
02375    2D89  10 EB                  BPL CHKERR	;AND UNCONDITIONALLY CHECK AGAIN
02376    2D8B  A9 5E        EARROW    LDA #$5E	;OUTPUT UPARROW TO INDICATE WHERE ERROR IS
02377    2D8D  20 02 29               JSR PRINTC
02378    2D90  20 96 2D               JSR CRLF2	;AND ADVANCE FOR LOOKS
02379    2D93  4C 31 20     BERRET    JMP START	;AND RESTART
02380    ;
02381    ;
02382    2D96  20 99 2D     CRLF2     JSR CRLF          ;ADVANCE TWO LINES
02383    2D99  A9 0D        CRLF      LDA #$0D          ;A CARRIAGE RETURN
02384    2D9B  20 02 29               JSR PRINTC
02385    2D9E  A9 0A        OUTLF     LDA #$0A          ;AND A LF
02386    2DA0  4C 02 29               JMP PRINTC          ;* PJMP * TO PRINT ROUTINE
02387    ;
02388    ;          'INTEGER LINE NUMBER INPUT ROUTINE'
02389    ;
02390    ; 'GETLIN' THIS ROUTINE IS CALLED IF THE FIRST CHAR OF A LINE NUMBER
02391    ; IS 0-9 FOR ADDED SPEED, AS THE CALL TO 'EVAL' IS POWERFUL
02392    ; BUT SLOW (SEE 'GETLN').
02393    ;
02394    2DA3  20 C2 2D     GETILN    JSR GETIN	;GET A TWO-DIGIT INTEGER
02395    2DA6  85 2C                  STA GRPNO	;SAVE AS GROUP NUMBER
02396    2DA8  20 3E 2B               JSR TTERMS	;IS TERMINATOR ONE WE RECOGNIZE?
02397    2DAB  F0 31                  BEQ GETIR	;YES, THEN RETURN
02398    2DAD  C9 2E                  CMP #$2E	;NO, IS IT A PERIOD?
02399    2DAF  D0 29                  BNE GETBAD	;NO, THEN A BAD LINE NUMBER
02400    2DB1  20 BB 29               JSR TESTNS	;ANOTHER NUMBER?
02401    2DB4  B0 24                  BCS GETBAD	;NO, THEN ERROR
02402    2DB6  20 C2 2D               JSR GETIN	;YES, THEN GET NEXT NUMBER
02403    2DB9  90 04                  BCC LNOK	;BRANCH, IF TWO-DIGIT OUTPUT
02404    2DBB  AA                     TAX		;MOVE INTO X
02405    2DBC  BD DF 2D               LDA TENS,X	;YES, THEN ASSUME TRAILING ZERO
02406    2DBF  85 2D        LNOK      STA LINENO	;SAVE THE LINE (STEP) NUMBER
02407    2DC1  60                     RTS		;AND RETURN
02408    ;
02409    2DC2  29 0F        GETIN     AND #$0F	;MAKE 0-9
02410    2DC4  48                     PHA		;SAVE ON STACK
02411    2DC5  20 BB 29               JSR TESTNS	;TEST NEXT NON-BLANK
02412    2DC8  68                     PLA		;RESTORE SAVED NUMBER
02413    2DC9  B0 13                  BCS GETIR	;RETURN IF NOT A DIGIT
02414    2DCB  AA                     TAX		;PLACE SAVED NUMBERINTO X
02415    2DCC  A5 2B                  LDA CHAR	;GET NEW DIGIT
02416    2DCE  29 0F                  AND #$0F	;FORM 0-9
02417    2DD0  7D DF 2D               ADC TENS,X	;ADD IN PROPER HIGH ORDER
02418    2DD3  48                     PHA		;SAVE NUMBER ON STACK
02419    2DD4  20 BB 29               JSR TESTNS	;TEST NEXT NON-BLANK
02420    2DD7  68                     PLA		;GET SAVED NUMBER BACK
02421    2DD8  B0 03                  BCS GETIRC	;BRANCH IF NOT A NUMBER
02422    2DDA  4C 25 26     GETBAD    JMP BADLNO	;BAD LINE NUMBER BRANCH AID
02423    2DDD  18           GETIRC    CLC		;INDICATE TWO DIGITS INPUT
02424    2DDE  60           GETIR     RTS		;RETURN
02425    ;
02426    TENS      .BYTE 0
02427              .BYTE 10
02428              .BYTE 20
02429              .BYTE 30
02430              .BYTE 40
02431              .BYTE 50          ; Aresco code has a $15 here, clearly wrong
02432              .BYTE 60                 
02433              .BYTE 70
02434              .BYTE 80             
02435              .BYTE 90                  
02436    ;
02437    ;
02438    ;
02439    ;               FOCAL FUNCTIONS
02440    ;
02441    ;
02442    2DE9  A0 00        FUNC      LDY #$00	; SET OFFSET TO ZERO
02443    2DEB  8A                     TXA		;PLACE HASH CODE INTO ACCUMULATOR
02444    2DEC  BE F5 34     FUNC1     LDX FUNTAB,Y	;GET TABLE VALUE
02445    2DEF  F0 15                  BEQ BADFUN	;END OF TABLE AND NOT FOUND
02446    2DF1  D9 F5 34               CMP FUNTAB,Y	;MATCH YET?
02447    2DF4  F0 03                  BEQ GOTFUN	;YES, WE FOUND IT
02448    2DF6  C8                     INY		;NO, POINT TO NEXT ENTRY
02449    2DF7  D0 F3                  BNE FUNC1	;AND TRY IT
02450    2DF9  B9 2D 35     GOTFUN     LDA FUNADL,Y	;GET LOW ORDER ARRD OFROUTINE TO HANDLE
02451    2DFC  85 5F                  STA TEMP1	;FUNCTION
02452    2DFE  B9 11 35               LDA FUNADH,Y	;GET HIGH ORDER
02453    2E01  85 60                  STA TEMP1+1	;STORE IT
02454    2E03  6C 5F 00               JMP (TEMP1)	;AND GO TO IT (TEMP1)
02455    
02456    2E06  00           BADFUN    BRK		;TRAP
02457              .BYTE UNRFUN	;?UNRECOGNIZABLE FUNCTION NAME
02458    ;
02459    ;     FABS - ABS. VALUE FUNCTION
02460    ;
02461    2E08  20 F7 33     FABS      JSR ABSF1	;TAKE ABSOLUTE VALUE OF FAC1
02462    2E0B  4C 14 2E               JMP FPOPJ	;*PJMP* AND RETURN
02463    ;
02464    ;     FINT & FINR - RETURN INTEGER FUNCTIONS
02465    ;
02466    2E0E  20 A7 2F     FINT      JSR INTFIX	; MAKE FAC1 AN INTEGER
02467    2E11  20 39 32     FLPOPJ    JSR FLOAT	; FLOAT ALL BITS
02468    2E14  20 4B 28     FPOPJ     JSR POPJ	; *FJMP* AND RETURN
02469    ;
02470    ; 'FINR' INTEGERIZE AFTER ROUNDING
02471    ;
02472    2E17  20 93 2F     FINR      JSR INTGER	; FORM ROUNDED INTEGER
02473    2E1A  4C 11 2E               JMP FLPOPJ	;*PJMP*FLOAT AND RETURN
02474    ;
02475    ;              ROUTINES TO CHECK RANGE INPUT AND OUTPUT DEVICE NUMBERS
02476    ;
02477    2E1D  C9 03        CHKODV    CMP #ODEVM	;COMPARE AC AGAINST MAX ALLOWED
02478    2E1F  10 05                  BPL RNGDEV	;BRANCH IF ERROR
02479    2E21  60           CHKRTS    RTS		;RETURN IF OK
02480    2E22  C9 03        CHKIDV    CMP #IDEVM	;COMPARE AGAINST MAX
02481    2E24  30 FB                  BMI CHKRTS	;RETURN IF OK
02482    2E26  C9 FF        RNGDEV    CMP #$FF	;MINUS 1?
02483    2E28  F0 F7                  BEQ CHKRTS	;BRANCH IF YES, ALWAYS IN RANGE
02484    2E2A  00                     BRK		;TRAP
02485    	  .BYTE DEVRNG	;DEVICE NUMBER OUT OF RANGE
02486    ;
02487    ;              "FINI" INITIALIZE INPUT DEVICE 
02488    ;
02489    2E2C  20 93 2F     FINI      JSR INTGER	;MAKE ARGUMENT INTEGER
02490    2E2F  30 06                  BMI INIRET	;IGNORE IF NEGATIVE
02491    2E31  20 22 2E               JSR CHKIDV	;CHECK FOR VALIDITY
02492    2E34  20 8D 2E               JSR INI	;GO CALL APPROPRIATE ROUTINE     
02493    2E37  4C 11 2E     INIRET    JMP FLPOPJ	;NO ERRORS, RETURN
02494    ;
02495    ;            'FINO' INITIALIZE OUTPUT DEVICE
02496    ;
02497    2E3A  20 93 2F     FINO      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02498    2E3D  30 F8                  BMI INIRET	;IGNORE IF NEGATIVE
02499    2E3F  20 1D 2E               JSR CHKODV	;CHECK FOR VALIDITY
02500    2E42  20 A2 2E               JSR INO	;GO CALL APPROPRIATE ROUTINE
02501    2E45  4C 11 2E               JMP FLPOPJ	;NO ERRORS - RETURN
02502    ;
02503    ;            'FCLI' CLOSE INPUT DEVICE
02504    ;
02505    2E48  20 93 2F     FCLI      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02506    2E4B  30 06                  BMI CLIRET	;IGNORE IF NEGATIVE
02507    2E4D  20 22 2E               JSR CHKIDV	;RANGE CHECK THE DEVICE NUMBER
02508    2E50  20 B6 2E               JSR CLI_	;CALL DEVICE DEPENDENT CODE
02509    2E53  4C 11 2E     CLIRET    JMP FLPOPJ	;NO ERRORS - RETURN
02510    ;
02511    ;           "FCLO" CLOSE OUTPUT DEVICE
02512    ;
02513    2E56  20 93 2F     FCLO      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02514    2E59  30 F8                  BMI CLIRET	;IGNORE IF NEGATIVE
02515    2E5B  20 1D 2E               JSR CHKODV	;RANGE CHECK THE DEVICE NUMBER
02516    2E5E  20 C2 2E               JSR CLO	;CALL DEVICE DEPENDENT CODE
02517    2E61  4C 11 2E               JMP FLPOPJ	;NO ERRORS - RETURN
02518    ;
02519    ;           "FCON" SET CONSOLE DEVICE
02520    ;
02521    2E64  20 93 2F     FCON      JSR INTGER	;MAKE ARGUMENT AN INTEGER
02522    2E67  30 11                  BMI RETCON	;BRANCH IF NEGATIVE
02523    2E69  20 22 2E               JSR CHKIDV	;MAKE SURE DEVICE IS IN RANGE FOR BOTH INPUT
02524    2E6C  20 1D 2E               JSR CHKODV	;AND OUTPUT
02525    2E6F  85 6A                  STA CONDEV	;MAKE IT CURRENT CONSOLE     
02526    2E71  20 15 20               JSR CLRDEV	;MAKE CURRENT IO DEVICE
02527    2E74  20 27 20               JSR INIDEV	;INITIALIZE IT FOR INPUT AND OUTPUT
02528    2E77  4C 11 2E               JMP FLPOPJ	;*PJMP* NO ERRORS - RETURN
02529    2E7A  A5 6A        RETCON    LDA CONDEV	;GET THE DEVICE NUMBER OF CONSOLE
02530    2E7C  20 41 32               JSR FLT8	;FLOAT IT
02531    2E7F  4C 14 2E               JMP FPOPJ	;*PJMP* AND RETURN
02532    ;
02533    ;           "FCUR" CONSOLE CURSOR ADDRESSING FUNCTION
02534    ;          NOTE:     THIS FUNCTION IS DEVICE DEPENDENT, AND IS HERE
02535    ;                    PRIMARILY BY POPULAR DEMAND. THE FUNCTION HAS
02536    ;                    TWO ARGUMENTS. THE FIRST IS THE ROW, THE SECOND     
02537    ;                    IS THE COLUMN, OF THE PLACE TO POSITION ON THE CONSOLE
02538    ;                    DEVICE (USUALLY ASSUMED TO BE CRT).
02539    ;
02540      2940             CONCUR = RTS1 ; Device dependant routine location - currently disabled
02541    2E82  20 79 2F     FCUR      JSR FI2ARG	;PICK UP TWO INTEGER ARGS
02542    2E85  20 40 29               JSR CONCUR	;*** CALL THE DEVICE DEPENDENT CODE ***
02543    2E88  B0 29                  BCS JOERRO	;BRANCH IF ERROR HAS OCCURED
02544    2E8A  4C 11 2E               JMP FLPOPJ	;* PJMP * AND RETURN
02545    ;
02546    ;ROUTINES TO DISPATCH TO DEVICE DEPENDENT INITIALIZATION ROUTINE
02547    ;ENTER EACH WITH THE DEVICE NUMBER IN THE ACCUMULATOR
02548    ;THEY WILL RETURN ONLY IF NO ERRORS WERRE ENCOUNTERED
02549    ;
02550    2E8D  AA           INI       TAX		;USE AS OFFSET TO ADDR TABLE
02551    2E8E  BD C3 35               LDA INIAH,X	;GET HIGH ORDER ADDR OF THE ROUTINE TO HANDLE
02552    2E91  85 60                  STA TEMP1+1	;SAVE IT
02553    2E93  BD C8 35               LDA INIAL,X	;GET LOW ORDER ADDR
02554    2E96  85 5F        INIC      STA TEMP1	;SAVE IT
02555    2E98  18                     CLC		;ASSUME SUCCESSS
02556    2E99  20 5E 00               JSR JSRIND	;CALL THE PROPER ROUTINE FOR THIS DEVICE
02557    2E9C  90 03                  BCC IRTS	;RETURN IF NO ERRORS
02558    2E9E  4C D6 28               JMP IERRI	;ERROR, GO COMPLAIN
02559    2EA1  60           IRTS      RTS
02560    
02561    2EA2  AA           INO       TAX		;USE AS OFFSET
02562    2EA3  BD CD 35               LDA INOAH,X	;GET HIGH ORDER OF THE ROUTINE TO HANDLE
02563    2EA6  85 60                  STA TEMP1+1	;SAVE IT
02564    2EA8  BD D2 35               LDA INOAL,X	;GET LOW ORDER OF THE ROUTINE TO HANDLE
02565    2EAB  85 5F        INOC      STA TEMP1	;SAVE IT
02566    2EAD  18                     CLC		;ASSUME SUCCESS
02567    2EAE  20 5E 00               JSR JSRIND	;CALL PROPER ROUTINE FOR THIS DEVICE
02568    2EB1  90 EE                  BCC IRTS	;RETURN IF NO ERRORS
02569    2EB3  4C 24 29     JOERRO    JMP OERRO	;COMPLAIN IF ERRORS
02570    
02571    2EB6  AA           CLI_      TAX		;USE AS OFFSET TO TABLE
02572    2EB7  BD D7 35               LDA CLIAH,X	;GET HIGH ORDER ADDR OF THE DEVICE DEPENDENT CODE
02573    2EBA  85 60                  STA TEMP1+1
02574    2EBC  BD DC 35               LDA CLIAL,X	;GET LOW ORDER ADDR
02575    2EBF  4C 96 2E               JMP INIC	;*PJMP* CALL DEVICE DEPENDENT CODE AND RETURN
02576    
02577    
02578    2EC2  AA           CLO       TAX		;USE AS OFFSET TO TABLE
02579    2EC3  BD E1 35               LDA CLOAH,X	;GET HIGH ORDER ADDR OF THE DEVICE DEPENDENT CODE
02580    2EC6  85 60                  STA TEMP1+1
02581    2EC8  BD E6 35               LDA CLOAL,X	;GET LOW ODER
02582    2ECB  4C AB 2E               JMP INOC	;*PJMP* CALL DEVICE DEPENDENT CODE AND RETURN
02583    ;
02584    ;           "FMEM"  MEMORY EXAMINE-DEPOSIT FUNCTION
02585    ;
02586    2ECE  20 79 2F     FMEM      JSR FI2ARG	;PICK UP TWO INTEGER ARGS
02587    2ED1  A4 2B                  LDY CHAR	;GET THE TERMINATOR
02588    2ED3  C0 2C                  CPY #$2C	;ANOTHER ARG?
02589    2ED5  F0 12                  BEQ FMEMD	;YES, THEN IT'S THE DEPCSIT FUNCTION
02590    2ED7  85 56                  STA ITMP1H	;SAVE HIGH ORDER ARRD TO EXAMINE
02591    2ED9  86 55                  STX ITMP1L	;SAVE THE LOW ORDER ADDR TO EXAMINE               
02592    2EDB  A0 00                  LDY #$00	;FORM OFFSET OF ZERO
02593    2EDD  B1 55                  LDA (ITMP1L),Y	;GET DATA STORED IN THE LOCATION
02594    2EDF  85 82        ST16PJ    STA M1+1	;SAVE IN INTEGER
02595    2EE1  84 81                  STY M1	;HIGH ORDER OF ZERO
02596    2EE3  20 4D 32     FL16PJ    JSR FLT16	;FLOAT A 16 BIT INTEGER
02597    2EE6  4C 14 2E               JMP FPOPJ	;*PJMP* AND RETURN
02598    
02599    2EE9  48           FMEMD     PHA		;SAVE HIGH ORDER
02600    2EEA  8A                     TXA		;
02601    2EEB  48                     PHA		;AND LOW ORDER 
02602    2EEC  20 89 2F               JSR NXIARG	;PICK UP THE NEXT INTEGER ARG
02603    2EEF  A8                     TAY		;SAVE IN Y REGISTER FOR A MOMENT
02604    2EF0  68                     PLA		;GET LOW ORDER ADDR BACK
02605    2EF1  85 55                  STA ITMP1L                         
02606    2EF3  68                     PLA		;GET HIGH ORDER ADDR BACK
02607    2EF4  85 56                  STA ITMP1H     
02608    2EF6  98                     TYA		;GET DATA TO DEPOSIT BACK
02609    2EF7  A0 00                  LDY #$00	;SET OFFSET OF ZERO
02610    2EF9  48                     PHA		;SAVE DATA TO DEPOSIT
02611    2EFA  B1 55                  LDA (ITMP1L),Y	;READ THE LOCATION
02612    2EFC  85 82                  STA M1+1	;SAVE AS INTEGER
02613    2EFE  84 81                  STY M1	;HIGH ORDER OF ZERO
02614    2F00  68                     PLA		;GET DATA TO DEPOSIT BACK AGAIN
02615    2F01  91 55                  STA (ITMP1L),Y	;STORE IN THE ADDR     
02616    2F03  A5 2B                  LDA CHAR	;GET TERMINATOR
02617    2F05  C9 2C                  CMP #$2C	; ',' MORE ARGS?
02618    2F07  D0 DA                  BNE FL16PJ	;* PJMP * NO, FLOAT AND RETURN
02619    2F09  20 1C 28               JSR PUSHJ	;MOVE PAST COMMA,
02620              .WORD EVALM1	;EVALUATE NEXT ARG
02621    2F0E  4C CE 2E               JMP FMEM	;AND TRY AGAIN
02622    ;
02623    ;          "FOUT" OUTPUT ASCII EQUIVALENT
02624    ;
02625    2F11  20 93 2F     FOUT      JSR INTGER	;FORM INTEGER
02626    2F14  20 02 29               JSR PRINTC	;OUTPUT THE CHARACTER
02627    2F17  4C 11 2E               JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02628    ;
02629    ;           "FCHR" RETUNR DECIMAL EQUIVALIENT CF ASCII CHAR INPUT
02630    ;
02631    2F1A  20 20 2F     FCHR      JSR GICHR	;GET A CHAR FROM INPUT DEVICE 
02632    2F1D  4C E3 2E               JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02633    ;
02634    ; ROUTINE TO INPUT ONE CHAR FROM INPUT DEVICE INTO FAC1
02635    ;
02636    2F20  A9 00        GICHR     LDA #$00	;ZERO HIGH ORDER
02637    2F22  85 81                  STA M1	;               
02638    2F24  A5 2B                  LDA CHAR	;SAVE CURRENT HAR
02639    2F26  48                     PHA
02640    2F27  20 C0 28               JSR READC	;NEXT CHAR FROM INPUT DEVICE
02641    2F2A  85 82                  STA M1+1	;STORE IN LOW ORDER
02642    2F2C  68                     PLA		;RESTORE SAVED CHAR
02643    2F2D  85 2B                  STA CHAR          
02644    2F2F  A5 82                  LDA M1+1	;GET CHAR INPUT INTO ACCUMULATOR
02645    2F31  60                     RTS		;AND RETURN
02646    ;
02647    ;           "FECH" SET CHAR ECHO CONTROL
02648    ;
02649    2F32  20 93 2F     FECH      JSR INTGER	;FORM INTEGER
02650    2F35  85 6B                  STA ECHFLG	;SAVE IN FLAG FOR LATER REFERENCE
02651    2F37  4C 11 2E               JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02652        ;
02653    ;           "FIDV" SET INPUT DEVICE FUNCTION
02654    ;
02655    2F3A  A2 44        FIDV      LDX #STIADR	;GET ADDR TO STORE INTO STRING INFORMATION
02656    2F3C  20 5F 2F               JSR GTDEVN	;GET DEVICE NUMBER (POSSIBLY A STRING)
02657    2F3F  20 22 2E               JSR CHKIDV	;RANGE CHECK IT
02658    2F42  A6 66                  LDX IDEV	;SAVE PREVIOUS VALUE FOR POSSIBLE RESTORE
02659    2F44  86 68                  STX IDVSAV	;
02660    2F46  85 66                  STA IDEV	;MAKE IT THE CURRENT INPUT DEVICE
02661    2F48  4C 59 2F               JMP FIODRT	;* PJMP * SET FAC1 TO ZERO, THEN RETURN
02662    ;
02663    ;           "FODV" SET OUTPUT DEVICE FUNCTION
02664    ;
02665    2F4B  A2 48        FODV      LDX #STOADR	;GET SDDR TO STORE STRING INFORMATION
02666    2F4D  20 5F 2F               JSR GTDEVN	;GET DEVICE NUMBER (POSSIBLY A STRING)
02667    2F50  20 1D 2E               JSR CHKODV	;RANGE CHECK IT
02668    2F53  A6 67                  LDX ODEV	;SAVE PREVIOUS VALUE FOR POSSIBLE RESTORE
02669    2F55  86 69                  STX ODVSAV
02670    2F57  85 67                  STA ODEV	;SET AS OUTPUT DEVICE
02671    2F59  20 CB 2C     FIODRT    JSR ZRFAC1	;RETURN A VALUE OF ZERO FOR THE FUNCTION 
02672    2F5C  4C 11 2E               JMP FLPOPJ	;* PJMP * FLOAT AND RETURN
02673    ;
02674    ; ROUTINE TO GET A DEVICE NUMBER (POSSIBLY A STRING)
02675    ;
02676    2F5F  A5 3B        GTDEVN    LDA STRSWT	;WAS ARGUMENT A STRING VARIABLE?
02677    2F61  D0 03                  BNE STRDEV	;BRANCH IF YES
02678    2F63  4C 93 2F               JMP INTGER	;* PJMP * NO, JUST TO INTEGRIZE ARG AND RETURN
02679    2F66  A5 37        STRDEV    LDA VARADR	;STORE BASE ADDR OF STRING
02680    2F68  95 00                  STA $00,X	;IN POINTER
02681    2F6A  A5 38                  LDA VARADR+1
02682    2F6C  95 01                  STA $01,X
02683    2F6E  A5 3A                  LDA VSUB+1	;GET SUBSCRIPT OF PLACE TO START
02684    2F70  95 02                  STA $02,X          
02685    2F72  A5 3C                  LDA VSIZE	;AND GET MAX SIZE OF STRING
02686    2F74  95 03                  STA $03,X
02687    2F76  A9 FF                  LDA #$FF	;RETURN DEVICE NUMBER OF -1
02688    2F78  60                     RTS		;AND RETURN
02689    
02690    2F79  A5 2B        FI2ARG    LDA CHAR	;GET TERMINATOR
02691    2F7B  C9 2C                  CMP #$2C	;',' ANOTHER ARG?
02692    2F7D  D0 12                  BNE FARGM	;BRANCH IF ARG IS MISSING
02693    2F7F  20 93 2F               JSR INTGER	;GET A SINGLE BYTE INTEGER
02694    2F82  48                     PHA		;SAVE ACROSS 'EVAL' CALL
02695    2F83  20 89 2F               JSR NXIARG	;GET ANOTHER ARG
02696    2F86  AA                     TAX		;SAVE THE SECOND ARGUMENT
02697    2F87  68                     PLA		;GET THE FIRST ARGUMENT 
02698    2F88  60                     RTS		;AND RETURN
02699    ;
02700    2F89  20 1C 28     NXIARG    JSR PUSHJ	;MOVE PAST COMMA, EVALUATE NEXT ARGUMENT
02701              .WORD EVALM1
02702    2F8E  4C 93 2F               JMP INTGER	;*PJMP* FORM SINGLE BYTE INTEGER AND RETRUN
02703    
02704    2F91  00           FARGM     BRK		;TRAP
02705              .BYTE ARGM	;?ARGUMENT MISSING IN FUNCTION
02706    ;
02707    ;     ROUTINE TO GENERATE A ROUNDED INTEGER
02708    ;
02709    2F93  A2 96        INTGER    LDX #FHALF	;MOVE CONSTANT .50
02710    2F95  A0 7B                  LDY #X2	;INTO FAC2
02711    2F97  20 FF 33               JSR MOVXY
02712    2F9A  20 29 32               JSR SWAP	;PUT .5 IN FAC1
02713    2F9D  A5 7C                  LDA M2	;GET SIGN OF FAC2
02714    2F9F  10 03                  BPL INTG1	;OK IF POSITIVE
02715    2FA1  20 B8 32               JSR FCOMPL	;MAKE -.50
02716    2FA4  20 79 32     INTG1     JSR FADD	;ADD IT IN AS ROUNDING
02717    2FA7  20 18 33     INTFIX    JSR FIX	;AND FORM 23 BIT INTEGER
02718    2FAA  A5 83                  LDA M1+2	;GET LOW ORDER IF CALLER NEEDS IT               
02719    2FAC  60                     RTS		;AND RETURN
02720    ;
02721    ;           "FPIC" SOFTWARE PRIORITY INTERRUPT CONTROL FUNCTION
02722    ;
02723    2FAD  20 1C 28     FPICC     JSR PUSHJ	;CALL 'EVAL' TO PICK UP NEXT ARG
02724              .WORD EVALM1
02725    2FB2  A5 2B        FPIC      LDA CHAR	;GET CHAR WHICH TERMINATED ARGUMENT
02726    2FB4  C9 2C                  CMP #$2C	;IS THERE ANOTHER ARGUMENT TO FOLLOW
02727    2FB6  D0 D9                  BNE FARGM	;BRANCH IF NOT, GO COMPLAIN
02728    2FB8  20 93 2F               JSR INTGER	;YES, PICK UP VALUE OF FIRST
02729    2FBB  F0 27                  BEQ PISET	;BRANCH IF LEVEL TO ENABLE IS 0
02730    2FBD  48                     PHA		;SAVE LEVEL TO ENABLE
02731    2FBE  20 92 29               JSR GETC	;MOVE PAST COMMA
02732    2FC1  20 BC 25               JSR GETLNS	;AND PICK UP THE LINE NUMBER TO 'DO'
02733    2FC4  68                     PLA		;GET LEVEL BACK
02734    2FC5  AA                     TAX		;INTO X REGISTER
02735    2FC6  A5 2C                  LDA GRPNO	;GET GROUP NUMBER OF LINE TO 'DO'
02736    2FC8  9D 8B 35               STA INTGRP,X	;SAVE FOR LATER USE
02737    2FCB  A5 2D                  LDA LINENO	;GET STEP NUMBER OF LINE TO 'DO'
02738    2FCD  9D 94 35               STA INTLIN,X	;SAVE FOR LATER USE
02739    2FD0  A5 6D                  LDA ACTMSK	;GET MASK WHICH INDICATES WITH CHANNELS
02740    2FD2  1D A6 35               ORA BITTAB,X	;SET THE BIT FOR SPECIFIED CHANNELS
02741    2FD5  85 6D                  STA ACTMSK	;MAKING IT ACTIVE NOW
02742    2FD7  A5 2B        ENDPIC    LDA CHAR	;GET CHAR WHICH TERMINATES SECOND ARG
02743    2FD9  C9 2C                  CMP #$2C	;',' ANY MORE ARGS?
02744    2FDB  F0 D0                  BEQ FPICC	;BRANCH IF YES, PICK THEM UP
02745    2FDD  A0 00                  LDY #$00	;NO GET A ZERO
02746    2FDF  A5 6D                  LDA ACTMSK	;AND THE CURRENT ACTIVE MASK
02747    2FE1  4C DF 2E               JMP ST16PJ	;* PJMP * STORE, FLOAT AND RETURN IT AS VALUE
02748    
02749    2FE4  20 89 2F     PISET     JSR NXIARG	;GET NEXT ARG AS NUMBER
02750    2FE7  A5 82                  LDA M1+1	;IS IT NEGATIVE
02751    2FE9  30 EC                  BMI ENDPIC	;YES, THEN THIS CALL IS A NO-OP
02752    2FEB  A5 83                  LDA M1+2	;NO, GET THE INTEGER VALUE (0-255)
02753    2FED  85 6D                  STA ACTMSK	;AND STORE THAT AS NEW ACTIVE MASK
02754    2FEF  4C D7 2F               JMP ENDPIC	;AND CHECK FOR MORE ARGUMENTS BEFORE RETURNING
02755    ;
02756    ;                    'FOCAL STRING FUNCTIONS'
02757    ;
02758    ;           "FISL" INITIALIZE STRING LENGTH
02759    ;
02760    2FF2  20 1C 28     FISLNX    JSR PUSHJ	;PICK UP NEXT ARGUMENT
02761             .WORD EVALM1     
02762    2FF7  A5 64        FISL      LDA STRSIZ	;SAVE DEFAULT STRING SIZE
02763    2FF9  48                     PHA          
02764    2FFA  20 93 2F               JSR INTGER	;GET FIRST ARGUMENT WHICH IS SIZE TO SET
02765    2FFD  85 64                  STA STRSIZ
02766    2FFF  20 0E 30               JSR FGTSV	;GET NEXT ARGUMENT WHICH IS A STRING VARIABLE
02767                ;IF NOT PREVIOUSLY DEFINED IT WILL BE DEFINED
02768                ;WITH SUPPLIED LENGTH.
02769    3002  68                     PLA		;RESTORE WITH LENGTH
02770    3003  85 64                  STA STRSIZ
02771    3005  A5 2B                  LDA CHAR
02772    3007  C9 2C                  CMP #$2C	;',' ANY MORE ARGS?
02773    3009  F0 E7                  BEQ FISLNX	;BRANCH IF YES, PROCESS THEM
02774    300B  4C 14 2E               JMP FPOPJ	;* PJMP * NO, THEN RETURN
02775    ;
02776    ; ROUTINE TO GET A STRING VARIABLE FROM PROGRAM TEXT
02777    ;
02778    300E  A5 2B        FGTSV     LDA CHAR	;ANY MORE ARGUMENTS IN FUNCTION CALL?
02779    3010  C9 2C                  CMP #$2C
02780    3012  D0 15                  BNE FSTRBA	;BRANCH IF NOT, ERROR
02781    3014  20 92 29               JSR GETC	;YES, MOVE PAST COMMA
02782    3017  20 1C 28     FGTSV1    JSR PUSHJ	;CALL 'GETVAR' TO GET A VARIABLE
02783              .WORD GETVAR
02784    301C  A5 3B                  LDA STRSWT	;WAS IT A STRING VARIABLE?
02785    301E  D0 02                  BNE SVOK	;BRANCH IF IT WAS 
02786    3020  00                     BRK		;TRAP
02787              .BYTE SVRQ	;?STRING VARIABLE REQUIRED HERE
02788    3022  A4 3A        SVOK      LDY VSUB+1	;GET ELEMENT POSITION
02789    3024  A5 37                  LDA VARADR	;AND LOW AND
02790    3026  A6 38                  LDX VARADR+1	;HIGH ORDER BASE ADDR OF STRING
02791    3028  60                     RTS		;AND RETURN
02792    
02793    3029  00           FSTRBA    BRK		;TRAP
02794              .BYTE BASTRF	;?BAD OR MISSING ARGUMENT IN STRING FUNCTION
02795    ;
02796    ;           "FSTI" INPUT A STRING FROM INPUT DEVICE
02797    ;
02798    302B  20 8D 30     FSTI      JSR SETSIO	;PICK UP ARGS
02799    302E  20 20 2F     FSTINX    JSR GICHR	;GET A CHARACTER FROM INPUT DEVICE
02800    3031  C5 3D                  CMP VCHAR	;IS THIS THE TERMINATOR?
02801    3033  F0 10                  BEQ SENDIO	;YES, THEN THAT'S ALL FOLKS
02802    3035  A4 3A                  LDY VSUB+1	;GET SUBSCRIPT TO PLACE CHAR
02803    3037  C9 7F                  CMP #RUBCHR	;IS THE CHARACTER A RUBOUT?
02804    3039  F0 15                  BEQ RUBSTI	;BRANCH IF YES, SEE IF WE DO SOMETHING
02805    303B  91 37        FSTOC     STA (VARADR),Y	;STORE CHAR THERE
02806    303D  E6 3A                  INC VSUB+1	;POINT TO NEXT
02807    303F  E6 55                  INC STRCNT	;COUNT THIS CHARACTER
02808    3041  C6 59                  DEC STRMAX	;REACH MAX ALLOWED?
02809    3043  D0 E9                  BNE FSTINX	;BRANCH IF NOT, INPUT MORE
02810    3045  A9 00        SENDIO    LDA #$00	;STORE A ZERO IN HIGH ORDER
02811    3047  85 81                  STA M1               
02812    3049  A5 55                  LDA STRCNT	;GET NUMBER ACTUALLY MOVED
02813    304B  85 82                  STA M1+1          
02814    304D  4C E3 2E               JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02815    ;
02816    ;HERE IF RUBOUT SEEN DURING A STRING INPUT
02817    ;
02818    3050  A6 66        RUBSTI    LDX IDEV	;IS THE INPUT DEVICE
02819    3052  E4 6A                  CPX CONDEV	;THE CONSOLE?
02820    3054  D0 E5                  BNE FSTOC	;BRANCH IF NOT, DON'T DO ANYTHING SPECIAL
02821    3056  C4 5D                  CPY STBSAV	;YES, ARE WE TRYING TO RUBOUT PAST STARTING SUBSCRIPT?
02822    3058  F0 D4                  BEQ FSTINX	;BRANCH IF SO, DON'T DO ANYTHING, IGNORE RUBOUT
02823    305A  A4 6B                  LDY ECHFLG	;DOES USER WANT CHARACTER ECHOING?
02824    305C  D0 0E                  BNE RUBSC	;BRANCH IF ECHOING DISABLED
02825    305E  A4 6C                  LDY DELSPL	;DO WE DO FANCY CRT STYLE RUBOUTS?
02826    3060  F0 05                  BEQ RUBS1	;BRANCH IF NOT
02827    3062  20 7D 29               JSR EATTVC	;YES, THEN EAT THE CHAR OFF CRT SCREEN
02828    3065  10 05                  BPL RUBSC	;AND DO COMMON THINGS
02829    3067  A9 5C        RUBS1     LDA #RUBECH	;ECHO PLAIN CHAR TO INDICATE A RUBOUT
02830    3069  20 02 29               JSR PRINTC
02831    306C  C6 3A        RUBSC     DEC VSUB+1	;PACK UP ONE BYTE IN THE STRING
02832    306E  C6 55                  DEC STRCNT	;DON'T COUNT THE CHARACTER RUBBED OUT
02833    3070  E6 59                  INC STRMAX
02834    3072  4C 2E 30               JMP FSTINX	;AND GET NEXT CHARACTER
02835    ;
02836    ;           "FSTO" OUTPUT A STRING TO OUTPUT DEVICE
02837    ;
02838    3075  20 8D 30     FSTO      JSR SETSIO	;GET ARGS
02839    3078  A4 3A        FSTONX    LDY VSUB+1	;GET SUBSCRIPT OF BYTE IN STRING
02840    307A  B1 37                  LDA(VARADR),Y	;GET THE BYTE
02841    307C  C5 3D                  CMP VCHAR	;TERMINATOR?
02842    307E  F0 C5                  BEQ SENDIO	;BRANCH IF YES
02843    3080  20 02 29               JSR PRINTC	;OUTPUT IT
02844    3083  E6 3A                  INC VSUB+1	;POINT TO NEXT BATE
02845    3085  E6 55                  INC STRCNT	;COUNT THIS ONE OUTPUR
02846    3087  C6 59                  DEC STRMAX	;OUTPUT MAX YET?
02847    3089  D0 ED                  BNE FSTONX	;BRANCH IF MORE TO OUTPUT
02848    308B  F0 B8                  BEQ SENDIO	;BRANCH IF WE HAVE HIT LIMIT
02849    ;
02850    ; ROUTINE TO GET ARGS FOR 'FSTI' AND 'FSTD'
02851    ;
02852    308D  A9 00        SETSIO    LDA #$00	;GET A ZERO
02853    308F  85 55                  STA STRCNT	;INIT BYTE COUNT TO ZERO
02854    3091  20 93 2F               JSR INTGER	;GET MAX NUMBER OF CHARACTER TO MOVE
02855    3094  85 59                  STA STRMAX
02856    3096  20 0E 30               JSR FGTSV	;GET THE STRING VARIABLE
02857    3099  48                     PHA		;SAVE NEAT STUFF RETURNED
02858    309A  8A                     TXA
02859    309B  48                     PHA
02860    309C  98                     TYA
02861    309D  48                     PHA
02862    309E  A5 2B                  LDA CHAR	;IS THE OPTIONAL TERMINATOR ARG SUPPLIED?
02863    30A0  C9 2C                  CMP #$2C      
02864    30A2  F0 04                  BEQ SETS1	;YES, THEN PICK IT UP
02865    30A4  A9 FF                  LDA #$FF	;NO, THEN SET IT TO $FF
02866    30A6  D0 08                  BNE SETS2	;AND ENTER COMMON CODE
02867    30A8  20 1C 28     SETS1     JSR PUSHJ	;MOVE PAST COMMA, PICK UP NEXT ARG
02868              .WORD EVALM1
02869    30AD  20 93 2F               JSR INTGER	;FORM INTEGER
02870    30B0  85 3D        SETS2     STA VCHAR	;SAVE TERMINATION CHARACTER
02871    30B2  68                     PLA		;RESTORE GOOD STUFF
02872    30B3  85 3A                  STA VSUB+1	;
02873    30B5  85 5D                  STA STBSAV	;REMEMBER SUBSCRIPT TO BEGIN I-O TO/FROM
02874    30B7  68                     PLA                    
02875    30B8  85 38                  STA VARADR+1
02876    30BA  68                     PLA
02877    30BB  85 37                  STA VARADR
02878    30BD  60                     RTS		;AND RETURN
02879    ;
02880    ; ROUTINE TO WRITE A STRING
02881    ;
02882    30BE  A4 4A        WSTRNG    LDY STOPNT	;new line - not in the 6502 Grp original
02883    
02884                ;original code  	(appears to be a patch
02885                ;WSTRNG CPY STOMAX    in ProgExch code)
02886                ;     BEQ WSRET
02887                ;     STA (STOADR),Y
02888                ;     INC STOPNT
02889                ;WSRET      PLA
02890                ;     RTS
02891    ;                    ; then go on with IOSRET
02892    ;
02893    30C0  C4 4B                  CPY STOMAX	;BEYOND END OF STRING
02894    30C2  F0 04                  BEQ IOSRET	;BRANCH IF YES, IGNORE
02895    30C4  91 48                  STA (STOADR),Y	;NO, STORE CHAR IN STRING
02896    30C6  E6 4A                  INC STOPNT	;POINT TO NEXT BYTE
02897    
02898    30C8  A9 0D        IOSRET    LDA #$0D	;RETURN A CR   
02899                ;additional line in original: 
02900                        ;STA CHAR ;also in char
02901    30CA  60                     RTS		;AND RETURN 
02902    ;
02903    ; ROUTINE TO INPUT FROM A STRING
02904    ;
02905    30CB  A4 46        RSTRNG    LDY STIPNT	;GET POINTER TO NEXT BYTE
02906    30CD  C4 47                  CPY STIMAX	;BEYOND END OF STRING?
02907    30CF  F0 F7                  BEQ IOSRET	;BRANCH IF YES, RETURN A CARRIAGE RETURN
02908    30D1  B1 44                  LDA (STIADR),Y	;NO, GET BYTE FROM STRING
02909    30D3  85 2B                  STA CHAR	;SAVE FOR THOSE WHO NEED IT
02910    30D5  E6 46                  INC STIPNT	;AND POINT TO NEXT
02911    30D7  60                     RTS		;AND RETURN
02912    ;
02913    ;           FSLK - STRING "LOOK" FUNCTION
02914    ;
02915    30D8  A5 3B        FSLK      LDA STRSWT	;WAS ARG A STRING VARIABLE
02916    30DA  D0 02                  BNE FSLK1	;YES, THEN PROCEED
02917    30DC  00                     BRK		;TRAP
02918              .BYTE BASTRF	;?BAD OR MISSING ARGUMENT IN STRING
02919    30DE  A5 37        FSLK1     LDA VARADR	;COPY POINTERS INTO STRING1 POINTERS
02920    30E0  85 55                  STA STRAD1
02921    30E2  A5 38                  LDA VARADR+1
02922    30E4  85 56                  STA STRAD1+1
02923    30E6  A5 3A                  LDA VSUB+1
02924    30E8  85 57                  STA SBEG1	;STORE BEGINNING POSITION
02925    30EA  20 0E 30               JSR FGTSV	;GET NEXT STRING PARAMETER
02926    30ED  84 58                  STY SEND1	;STORE ENDING POSITION
02927    30EF  20 0E 30               JSR FGTSV	;GET STRING 2 POINTERS
02928    30F2  85 59                  STA STRAD2	;
02929    30F4  86 5A                  STX STRAD2+1
02930    30F6  84 5B                  STY SBEG2
02931    30F8  20 0E 30               JSR FGTSV	;GET ENDING POSITION 
02932    30FB  84 5C                  STY SEND2	;STORE IT
02933    30FD  A9 FF                  LDA #$FF	;ASSUME -1 (STRING NOT FOUND)
02934    30FF  85 81                  STA M1
02935    3101  85 82                  STA M1+1
02936    ;
02937    ;SEARCH ROUTINE
02938    ;
02939    3103  20 41 31     LKFCHR    JSR CMPCHR	;FIRST CHAR MATCH?
02940    3106  F0 09                  BEQ FCMAT	;BRANCH IF YES
02941    3108  C4 5C        CHKEOS    CPY SEND2	;NO, REACHES END OF STRING2?
02942    310A  F0 32                  BEQ SNOTF	;BRANCH IF YES, STRING1 NOT FOUND IN STRING2
02943    310C  E6 5B                  INC SBEG2	;NO, POINT TO NEXT CHAR IN STRING2
02944    310E  4C 03 31               JMP LKFCHR	;AND TRY TO FIND CHAR MATCH
02945    ;
02946    ;  HERE IF FIRST CHAR IN STRING1 MATCHES A CHAR IN STRING2
02947    ;
02948    3111  20 4A 31     FCMAT     JSR PUSHSP	;SAVE CURRENT POSITION IN BOTH STRINGS
02949    3114  A5 57        NXCMAT    LDA SBEG1	;REACHED END OF  FIRST STRING?
02950    3116  C5 58                  CMP SEND1                              
02951    3118  F0 13                  BEQ SFOUND	;BRANCH IF YES, THEN STRING1 WAS FOUND IN STRING2
02952    311A  C4 5C                  CPY SEND2	;NO, REACHED END OF STRING2?     
02953    311C  F0 1D                  BEQ SNOTFP	;BRANCH IF YES, THEN STRING 1 CAN'T BE FOUND IN STRING2
02954    311E  E6 57                  INC SBEG1	;POINT TO NEXT CHAR IN EACH STRING
02955    3120  E6 5B                  INC SBEG2
02956    3122  20 41 31               JSR CMPCHR	;MATCH?
02957    3125  F0 ED                  BEQ NXCMAT	;BRANCH IF YES, KEEP CHECKING AS LONG AS THEY MATCH
02958    3127  20 56 31               JSR POPSP	;NO, THEN RETURN TO THE POINT OF FIRST CHAR MATCH
02959    312A  4C 08 31               JMP CHKEOS	;AND TRY AGAIN FOR FIRST CHAR MATCH
02960    312D  20 56 31     SFOUND    JSR POPSP	;RESTORE POINTERS TO POSITION OF FIRST CHAR MATCH
02961    3130  A9 00                  LDA #$00	;STORE 0 IN HIGH ORDER
02962    3132  85 81                  STA M1                    
02963    3134  A5 5B                  LDA SBEG2	;RETURN SUBSCRIPT WHERE FIRST CHAR MATCHED
02964    3136  85 82                  STA M1+1               
02965    3138  4C E3 2E               JMP FL16PJ	;* PJMP * FLOAT AND RETURN
02966    313B  20 56 31     SNOTFP    JSR POPSP	;POP OFF SAVED POINTERS
02967    313E  4C E3 2E     SNOTF     JMP FL16PJ	;FLOAT -1 AND RETURN STRING1 WAS NOT FOUND IN STRING2
02968    ;
02969    ; ROUTINES USED BY 'FSLK'
02970    ;
02971    3141  A4 57        CMPCHR    LDY SBEG1	;GET CHAR FROM STRING1
02972    3143  B1 55                  LDA (STRAD1),Y
02973    3145  A4 5B                  LDY SBEG2	;GET CHAR FROM STRING2
02974    3147  D1 59                  CMP (STRAD2),Y	;COMPARE THEM
02975    3149  60                     RTS		;RETURN WITH Z=1 IF THEY ARE THE SAME
02976    ;
02977    314A  98           PUSHSP    TYA		;PRESERVE Y REGISTER
02978    314B  48                     PHA          
02979    314C  A6 55                  LDX STRAD1	;SAVE STRING POINTERS ON STACK
02980    314E  A0 08                  LDY #$08
02981    3150  20 6B 28               JSR PUSHB0
02982    3153  68                     PLA		;RESTORE Y REGISTER
02983    3154  A8                     TAY
02984    3155  60                     RTS		;AND RETURN
02985    ;
02986    3156  98           POPSP     TYA		;PRESERVE Y REGISTER
02987    3157  48                     PHA
02988    3158  A6 5C                  LDX STRAD1+7	;RESTORE STRING POINTERS
02989    315A  A0 08                  LDY #$08
02990    315C  20 5B 28               JSR POPB0
02991    315F  68                     PLA		;RESTORE Y REGISTER
02992    3160  A8                     TAY
02993    3161  60                     RTS		;AND RETURN
02994    ;
02995    ;            'FSBR' SINGLE VALUED SUBROUTINE CALL
02996    ;
02997    3162  20 DF 25     FSBR      JSR GETLN1	;FINISH EVALUATING GROUP OR LINE TO "DO"
02998    3165  08                     PHP		;SAVE STATUS FLAGS ON STACK
02999    3166  A9 30                  LDA #$30	;GET CODE NAME FOR VARIABLE '&0'
03000    3168  85 3D                  STA VCHAR	;SAVE AS VARIABLE NAME TO LOOK FOR
03001    316A  A9 00                  LDA #$00	;ALSO SET SUBSCRIPT TO ZERO
03002    316C  85 39                  STA VSUB
03003    316E  85 3A                  STA VSUB+1
03004    3170  85 3B                  STA STRSWT	;MAKE SURE STRING VARIABLE FLAG IS OFF
03005    3172  20 1C 28               JSR PUSHJ	;CALL 'FNDVAR' TO LOCATE '&0(0)'
03006              .WORD FNDVAR
03007    3177  20 29 32               JSR SWAP	;PUT CURRENT VALUE OF '&0' INTO FAC2
03008    317A  20 BB 2C               JSR PUSHIV	;SAVE IT'S VALUE AND ADDR ON STACK
03009    317D  A5 2B                  LDA CHAR	;GET TERMINATOR
03010    317F  C9 2C                  CMP #$2C	;',' IS THERE ANOTHER ARGUMENT
03011    3181  F0 02                  BEQ FSBR1	;BRANCH IF YES, PRESS ON
03012    3183  00                     BRK		;NO, TRAP
03013              .BYTE ARGM	;?ARGUMENT MISSING IN FUNCTION
03014    3185  68           FSBR1     PLA		;GET FLAGS FROM 'GETLN' INTO ACCUMULATOR
03015    3186  20 31 28               JSR PUSHA	;SAVE ON STACK
03016    3189  A2 2C                  LDX #GRPNO	;SAVE LINE OR GROUP TO 'DO'
03017    318B  20 69 28               JSR PUSHB2
03018    318E  20 1C 28               JSR PUSHJ	;MOVE PAST COMMA, EVALUATE NEXT ARGUMENT
03019              .WORD EVALM1  
03020    3193  A2 2D                  LDX #LINENO	;GET LINE OR GROUP TO 'DO' BACK
03021    3195  20 59 28               JSR POPB2               
03022    3198  20 3F 28               JSR POPA	;GET 'GETLN'FLAGS BACK
03023    319B  48                     PHA		;SAVE ON STACK FOR LATER 
03024    319C  20 C3 2C               JSR POPIV	;GET VALUE OF '&0' AND POINTER TO IT
03025    319F  20 BB 2C               JSR PUSHIV	;SAVE FOR LATER (VALUE IS IN FAC2)
03026    31A2  20 A1 2C               JSR PUTVAR	;NOW SET '&0' TO ARG VALUE (IN FAC1)
03027    
03028    ; SamCoVT - These next 4 instructions do not appear to be in the original .PTP version          
03029    ;          LDA INSW	;SAVE WHERE INPUT IS COMING FROM
03030    ;          JSR PUSHA	;(PROGRAM OR INPUT DEVICE)
03031    ;          LDA #$00	;AND FORCE IT TO BE PROGRAM
03032    ;          STA INSW          
03033    
03034    31A5  68                     PLA		;GET STATUS FLAGS RETURNED BY 'GETLN'
03035    31A6  AA                     TAX		;SAVE IN X REGISTER
03036    31A7  20 1C 28               JSR PUSHJ	;NOW PERFORM THE 'DO' OF THE LINE OR GROUP
03037              .WORD DO1
03038    31AC  20 C3 2C               JSR POPIV	;RESTORE WHERE INPUT IS COMMING FROM
03039                     ;AND OLD VALUE IS IN FAC2
03040    31AF  20 AE 2C               JSR FETVAR	;GET CURRENT VALUE IN FAC1
03041    31B2  20 29 32               JSR SWAP	;OLD VALUE IN FAC1, CURRENT VALUE IN FAC2
03042    31B5  20 A1 2C               JSR PUTVAR	;REPLACE OLD VALUE OF '&0' BEFORE CALL
03043    31B8  20 29 32               JSR SWAP	;GET CURRENT VALUE OF '&0' INTO FAC1
03044    31BB  4C 14 2E               JMP FPOPJ	;RETURN IT AS THE VALUE OF THE 'FSBR'
03045    ;
03046    ;          "FRAN" RANDOM NUMBER GENERATOR, 
03047    ;          RETURNS A FRACTION BETWEEN 0.00 AND 1.00
03048    ;
03049    31BE  20 93 2F     FRAN      JSR INTGER	;INTEGRIZE ARGUMENT
03050    31C1  F0 0F                  BEQ FRANC	;BRANCH IF =0, RETURN NEXT RANDOM NUMBER
03051    31C3  10 04                  BPL FRSET	;BRANCH IF >0, SET TO REPEATABILITY
03052    31C5  A5 76                  LDA HASH	;GET THE RANDOM NUMBER HASH VALUE
03053    31C7  D0 02                  BNE FRNINI	;AND RANDOMITE
03054    31C9  A9 55        FRSET     LDA #$55	;SET TO ALTERNATING ZEROS AND ONES
03055    31CB  A2 02        FRNINI    LDX #$02	;SETUP LOOP COUNTER
03056    31CD  95 77        FRNILP    STA SEED,X	;STORE IN SEED
03057    31CF  CA                     DEX	;POINT TO NEXT
03058    31D0  10 FB                  BPL FRNILP	;AND LOOP TILL DONE
03059    31D2  A9 7F        FRANC     LDA #$7F	;SET EXPONENT OF FAC1
03060    31D4  85 80                  STA X1
03061    31D6  18                     CLC		;ADD K TO SEED
03062    31D7  A5 77                  LDA SEED
03063    31D9  69 B1                  ADC #$B1
03064    31DB  85 83                  STA M1+2	;PUT RESULT IN LOW ORDER
03065    31DD  85 77                  STA SEED	;ALSO THIS PART IN SEED
03066    31DF  A5 78                  LDA SEED+1
03067    31E1  69 0C                  ADC #$0C
03068    31E3  85 82                  STA M1+1	;INTO MIDDLE ORDER
03069    31E5  A5 79                  LDA SEED+2
03070    31E7  69 1B                  ADC #$1B
03071    31E9  29 7F                  AND #$7F	;KILL SIGN BIT
03072    31EB  85 81                  STA M1
03073    31ED  A5 83                  LDA M1+2
03074    31EF  0A                     ASL  	;2^17
03075    31F0  18                     CLC
03076    31F1  65 83                  ADC M1+2	;2^16
03077    31F3  18                     CLC
03078    31F4  65 81                  ADC M1	;PLUS HIGH ORDER
03079    31F6  85 79                  STA SEED+2	;NEW SEED
03080    31F8  18                     CLC
03081    31F9  A5 83                  LDA M1+2	;2^8 ADDED
03082    31FB  65 82                  ADC M1+1
03083    31FD  85 78                  STA SEED+1
03084    31FF  A5 82                  LDA M1+1
03085    3201  65 79                  ADC SEED+2
03086    3203  85 79                  STA SEED+2	;SEED NOW READY FOR NEXT TIME
03087    3205  A9 00                  LDA #$00	;GET A ZERO
03088    3207  20 55 32               JSR NORM0	;NORMALIZE THE FRACTION
03089    320A  4C 14 2E               JMP FPOPJ	;* PJMP * and return
03090    
03091    
03092    ; *** BEGIN SamCoVT SECTION
03093       
03094    ;
03095    ;            CENTRAL ROUTINES
03096    ;
03097    320D  18           ADD       CLC
03098    320E  A2 03                  LDX #$03	;*INDEX FOR 4 BYTE ADD
03099    3210  B5 81        ADD1      LDA M1,X               
03100    3212  75 7C                  ADC M2,X	;ADD NEXT BYTE
03101    3214  95 81                  STA M1,X
03102    3216  CA                     DEX		;TO NEXT MORE SIG BYTE
03103    3217  10 F7                  BPL ADD1	;DO ALL THREE
03104    3219  60                     RTS
03105    
03106    321A  06 7A        MD1       ASL SIGN	;CLEAR LSB OF SIGN
03107    321C  20 1F 32               JSR ABSWAP	;ABS VAL M1, THEN SWAP
03108    321F  24 81        ABSWAP    BIT M1	;M1 NEG?
03109    3221  10 05                  BPL ABSWP1	;NO JUST SWAP
03110    3223  20 B8 32               JSR FCOMPL	;YES, NEGATE IT
03111    3226  E6 7A                  INC SIGN	;COMPLEMENT SIGN
03112    3228  38           ABSWP1    SEC		;FOR RETURN TO MUL/DIV
03113    ;
03114    ; SWAP FAC1 WITH FAC2
03115    ;
03116    3229  A2 05        SWAP      LDX #$05	;*FIVE BYTES TOTAL
03117    322B  94 84        SWAP1     STY EM1,X               
03118    322D  B5 7F                  LDA X1M1,X	;SWAP A BYTE OF FAC1 WITH
03119    322F  B4 7A                  LDY SIGN,X	;FAC2 AND LEAVE COPY OF
03120    			;$7A is X2M1 and SIGN. 
03121    			;used SIGN, because it is defined!!!
03122    3231  94 7F                  STY X1M1,X	;M1 IN E, E+3 USED
03123    3233  95 7A                  STA SIGN,X
03124    3235  CA                     DEX		;NEXT BYTE
03125    3236  D0 F3                  BNE SWAP1	;UNTIL DONE
03126    3238  60                     RTS
03127    ;
03128    ; ROUTINE TO FLOAT 23 BITS OF MANTISSA
03129    ;
03130    3239  A9 96        FLOAT     LDA #FHALF	;SET EXPONENT TO 22 DECIMAL
03131    323B  85 80                  STA X1                    
03132    323D  A9 00                  LDA #$00	;ZERO INTO LOW BYTES
03133    323F  F0 14                  BEQ NORM0	;* PBE Q* NORMALIZE IT AND RETURN
03134    ;
03135    ; DO A FAST FLOAT OF A 1-BYTE QUANTITY 
03136    ;
03137    3241  85 81        FLT8      STA M1	;STORE THE BYTE
03138    3243  A9 86                  LDA #$86	;ASSUME ALREADY SHIFTED 8 BLACES
03139    3245  85 80                  STA X1                    
03140    3247  A9 00                  LDA #$00	;GET A ZERO
03141    3249  85 82                  STA M1+1	;ZERO OUT BYTE OF MANTISSA
03142    324B  F0 06                  BEQ FLOATC	;*P BEQ * CLEAR THIRD BYTE, NORMALIZE AND RETURN
03143    ;
03144    ; FLOAT A 16-BUT INTEGER IN M1 & M1+1 TO FAC1
03145    ; FAC2 UNAFFECTED
03146    ;
03147    324D  A9 8E        FLT16     LDA #$8E
03148    324F  85 80                  STA X1	;SET EXP TO 14 DEC
03149    3251  A9 00                  LDA #$00	;CLEAR LOW BYTES
03150    3253  85 83        FLOATC    STA M1+2
03151    3255  85 84        NORM0     STA M1+3	;*
03152    			;* PFALL * NORMALIZE IT AND RETURN
03153    3257  20 1E 34     NORM      JSR CHKZER	;* IS MANTISSA ZERO?
03154    325A  D0 0F                  BNE NORML	;BRANCH IF NOT, THEN DO THE NORMALIZE SHIFTING
03155    325C  A9 80                  LDA #$80	;YES, THEN AVOID MUCH SHIFTING BY SETTING
03156    325E  85 80                  STA X1	;THE EXPONENT
03157    3260  60                     RTS		;AND RETURN
03158    3261  C6 80        NORM1     DEC X1
03159    3263  06 84                  ASL M1+3	;* SHIFT 4 BYTES LEFT
03160    3265  26 83                  ROL M1+2
03161    3267  26 82                  ROL M1+1
03162    3269  26 81                  ROL M1
03163    326B  A5 81        NORML     LDA M1	;NORMALISED CHECK
03164    326D  0A                     ASL 		;UPPER TWO BYTES UNEQUAL?
03165    326E  45 81                  EOR M1
03166    3270  10 EF                  BPL NORM1	;NO, LOOP TILL THEY ARE
03167    3272  60           RTSN      RTS
03168    ;
03169    ;FAC2-FAC1 INTO FAC1
03170    ;
03171    3273  20 B8 32     FSUB      JSR FCOMPL	;WILL CLEAR CARRY UNLESS ZERO
03172    3276  20 86 32     SWPALG    JSR ALGNSW	;RIGHT SHIFT M1 OR SWAP ON CARRY
03173    ;
03174    ;FAC1 + FAC2 INTO FAC1
03175    ;
03176    3279  A5 7B        FADD      LDA X2                    
03177    327B  C5 80                  CMP X1	;EXPONENTS EQUAL?
03178    327D  D0 F7                  BNE SWPALG	;IF NOT SWAP OR ALIGN
03179    327F  20 0D 32               JSR ADD	;ADD MANTISSAS
03180    3282  50 D3        ADDEND    BVC NORM	;IF COOL, NORMALIZE
03181    3284  70 05                  BVS RTLOG	;DV: SHIFT RIGHT-CARRY IS COOL
03182    			;SWAP IF CARRY CLEAR, ELSE SHIFT RIGHT ARITHMETICALLY
03183    3286  90 A1        ALGNSW    BCC SWAP
03184    3288  A5 81        RTAR      LDA M1	;SIGN INTO CARRY
03185    328A  0A                     ASL 		;ARITH SHIFT
03186    328B  E6 80        RTLOG     INC X1	;COMPENSATE FOR SHIFT
03187    328D  F0 39                  BEQ OVFL	;EXP OUT OF RANGE
03188    328F  A2 F8        RTLOG1    LDX #$F8	;* INDEX FOR 8 BYTE RT SHIFT
03189    3291  A9 80        ROR1      LDA #$80
03190    3293  B0 01                  BCS ROR2
03191    3295  0A                     ASL 
03192    3296  56 89        ROR2      LSR E+4,X	;*FAKE RORX E+4
03193    3298  15 89                  ORA E+4,X
03194    329A  95 89                  STA E+4,X
03195    329C  E8                     INX		;NEXT BYTE
03196    329D  D0 F2                  BNE ROR1	;UNTIL DONE
03197    329F  60                     RTS
03198    ;
03199    ;  FAC1 * FAC2 INTO FAC1
03200    ;
03201    32A0  20 1A 32     FMUL      JSR MD1	;ABS VAL OF M1,M2
03202    32A3  65 80                  ADC X1	;ADD EXPONENTS
03203    32A5  20 FE 32               JSR MD2	;CHECK & PREP FOR NUL
03204    32A8  18                     CLC
03205    32A9  20 8F 32     MUL1      JSR RTLOG1	;SHIFT PROD AND MFYR(?) RIGHT
03206    32AC  90 03                  BCC MUL2	;SKIP PARTIAL PROD
03207    32AE  20 0D 32               JSR ADD	;ADD IN MCAND
03208    32B1  88           MUL2      DEY		;NEXT ITERATION
03209    32B2  10 F5                  BPL MUL1	;LOOP UNTIL DONE
03210    32B4  46 7A        MDEND     LSR SIGN	;SIGN EVEN OR ODD?
03211    32B6  90 9F        NORMX     BCC NORM	;IF EVEN NORMALIZE, ELSE COMPARE
03212    32B8  38           FCOMPL    SEC                    
03213    32B9  A2 04                  LDX #$04	;*4 BYTE SUBTRACT
03214    32BB  A9 00        COMPL1    LDA #$00
03215    32BD  F5 80                  SBC X1,X
03216    32BF  95 80                  STA X1,X
03217    32C1  CA                     DEX		;TO MORE SIG BYTE
03218    32C2  D0 F7                  BNE COMPL1	;UNTIL DONE
03219    32C4  F0 BC                  BEQ ADDEND	;FIX UP
03220    ;                              
03221    32C6  10 46        OVCHK     BPL MD3	;IF POSITIVE EXPONENT NO CVF     
03222    32C8  00           OVFL      BRK		;TRAP
03223              .BYTE FOVFL	;FLOATING POINT OVERFLOW
03224    ;
03225    ; DIVIDE FAC2 BY FAC1 INTO FAC1
03226    ;
03227    32CA  20 1A 32     FDIV      JSR MD1	;ABS VALUE OF M1, M2
03228    32CD  E5 80                  SBC X1	;SUBTRACT EXPONENTS
03229    32CF  20 FE 32               JSR MD2	;SAVE AS RES EXP
03230    32D2  38           DIV1      SEC
03231    32D3  A2 03                  LDX #$03	;* FOR 4 BYTES
03232    32D5  B5 7C        DIV2      LDA M2,X               
03233    32D7  F5 85                  SBC E,X	;SUBTRACT BYTE OF E FROM M2
03234    32D9  48                     PHA     
03235    32DA  CA                     DEX		;NEXT MORE SIG BYTE
03236    32DB  10 F8                  BPL DIV2	;UNTIL DONE
03237    32DD  A2 FC                  LDX #$FC	;* FOR 4 BYTE COND MOVE
03238    32DF  68           DIV3      PLA		;DIFF WAS ON STACK
03239    32E0  90 02                  BCC DIV4	;IF M2<E DON'T RESTORE
03240    32E2  95 80                  STA X1,X	;*
03241    32E4  E8           DIV4      INX		;NEXT LESS SIG BYTE
03242    32E5  D0 F8                  BNE DIV3	;UNTIL DONE
03243    32E7  26 84                  ROL M1+3	;*
03244    32E9  26 83                  ROL M1+2               
03245    32EB  26 82                  ROL M1+1	;ROLL QUOTIENT LEFT
03246    32ED  26 81                  ROL M1	;CARRY INTO LSB
03247    32EF  06 7F                  ASL M2+3	;*
03248    32F1  26 7E                  ROL M2+2
03249    32F3  26 7D                  ROL M2+1	;DIVIDEND LEFT
03250    32F5  26 7C                  ROL M2
03251    32F7  B0 CF                  BCS OVFL	;OVF IS DUE TO UNNORM DIVISOR
03252    32F9  88                     DEY		;NEXT ITERATION
03253    32FA  D0 D6                  BNE DIV1	;UNTIL DONE (23 ITERATIONS)
03254    32FC  F0 B6                  BEQ MDEND	;NORM QUOTIENT AND FIX SIGN
03255    32FE  86 84        MD2       STX M1+3	;*
03256    3300  86 83                  STX M1+2
03257    3302  86 82                  STX M1+1	;CLEAR M1
03258    3304  86 81                  STX M1                    
03259    3306  B0 BE                  BCS OVCHK	;CHECK FOR OVFL
03260    3308  30 04                  BMI MD3	;IF NEG NO UNDERFLOW
03261    330A  68                     PLA		;POP ONE RETURN
03262    330B  68                     PLA
03263    330C  90 A8                  BCC NORMX	;CLEAR X1 AND RETURN
03264    330E  49 80        MD3       EOR #$80	;COMPL. SIGN OF EXPONENT
03265    3310  85 80                  STA X1                    
03266    3312  A0 1F                  LDY #$1F	;COUNT FOR 31 (/), 32 (*) ITERATIONS
03267    3314  60                     RTS
03268    ;
03269    ; FAC1 TO 23 BIT SIGNED INTEGER IN M1 (HIGH), M1+1 (MIDDLE), M1+2 (LOW) 
03270    ;
03271    3315  20 88 32     FIX1      JSR RTAR	;SHIFT MANTISSA, INC EXPONENT
03272    3318  A5 80        FIX       LDA X1	;CHECK EXP
03273    331A  C9 96                  CMP #FHALF	;IS EXP #22?
03274    331C  D0 F7                  BNE FIX1	;NO, SHIFT MORE
03275    331E  60                     RTS	;DONE
03276    ;
03277    ;            FLOATING POINT OUTPUT ROUTINE
03278    ;
03279    331F  A5 81        FPRNT     LDA M1	;SAVE THE SIGN OF THE NUMBER
03280    3321  85 8A                  STA SIGNP	;FOR LATER REFERENCE
03281    3323  20 F7 33               JSR ABSF1	;DEAL ONLY WITH ABSOLUTE VALUE
03282    3326  20 1E 34               JSR CHKZER	;IS NUMBER = 0?
03283    3329  D0 05                  BNE FPR0	;BRANCH IF NOT, THEN TRY TO DIVIDE DOWN
03284    332B  85 8D                  STA K		;YES, SOME FLAVOR OF ZERO. INDICATE THAT WE
03285    332D  48                     PHA		;DID NOT HAVE TO DIVIDE AS ALREADY <1
03286    332E  F0 43                  BEQ FPR4A	;AND PUNT DIVIDE DOWN AND ROUNDING CODE
03287    3330  A5 80        FPR0      LDA X1	;GET THE EXPONENT
03288    3332  48                     PHA		;SAVE FOR LATER REFERENCE
03289    3333  A9 00                  LDA #$00	;ZERO COUNTER WHICH COUNTS HOW MANY TIMES
03290    3335  85 8D                  STA K		;WE HAD TO DIVIDE TO GET NUMBER <1
03291    3337  24 80        FPR1      BIT X1	;IS NUMBER <1?
03292    3339  10 07                  BPL FPR2	;BRANCH IF YES
03293    333B  20 11 34               JSR DIV10	;NO, THEN DIVIDE BY 10
03294    333E  E6 8D                  INC K		;COUNT THE FACT WE DID
03295    3340  10 F5                  BPL FPR1	;AND CHECK AGAIN
03296    3342  20 79 28     FPR2      JSR PHFAC1	;SAVE NUMBER (NOW <1) ON STACK
03297    3345  A2 96                  LDX #FHALF	;GET THE CONSTANT .5
03298    3347  A0 80                  LDY #X1	;INTO FAC1
03299    3349  20 FF 33               JSR MOVXY
03300    334C  18                     CLC
03301    334D  A5 8D                  LDA K		;ROUNDING FACTOR IS .5*10^-(K+N)
03302    334F  65 90                  ADC N
03303    3351  85 8E                  STA L
03304    3353  F0 0F                  BEQ FPR4	;BRANCH IF WE NEED .5*10^0
03305    3355  A9 09                  LDA #$09	;* IS FACTOR BEYOND OUR PRECISSION?
03306    3357  C5 8E                  CMP L
03307    3359  10 02                  BPL FPR3	;BRANCH IF NOT, THEN ROUNDING FACTOR IS OK
03308    335B  85 8E                  STA L		;YES, THEN APPLY ROUNDING TO LEAST SIG FIG
03309    335D  20 11 34     FPR3      JSR DIV10	;NOW SHIFT .5 INTO PROPER POSITION
03310    3360  C6 8E                  DEC L
03311    3362  D0 F9                  BNE FPR3
03312    3364  20 9A 28     FPR4      JSR PLFAC2	;GET NUMBER INTO FAC2
03313    3367  20 79 32               JSR FADD	;ADD THE ROUNDING FACTOR
03314    336A  24 80                  BIT X1	;IS IT STILL <1?
03315    336C  10 05                  BPL FPR4A	;BRANCH IF IT IS
03316    ;
03317    ;original ProgExch/6502Grp code has more lines here:
03318    ;          pla          ;no then get original exponent
03319    ;          bmi fpr4a    ;branch if original number >1 do nothing
03320    ;          lda x1       ;we gained a sig fig in rounding, get new exp
03321    ;fpr41     pha          ;save exponent for later
03322    ;
03323    336E  20 11 34               JSR DIV10	;SCALE NUMBER BACK DOWN
03324    3371  E6 8D                  INC K		;AND INDICATE WE HAD TO
03325    3373  38           FPR4A     SEC
03326    3374  A5 8F                  LDA M		;NOW CONSULATE NUMBER OF LEADING BLANKS NEEDED
03327    3376  E5 8D                  SBC K
03328    3378  85 8E                  STA L		;INTO L
03329    337A  68                     PLA		;GET EXPONENT OF ORIGINAL NUMBER BACK
03330    337B  48                     PHA		;SAVE AGAIN FOR LATER
03331    337C  30 02                  BMI FPR4B	;BRANCH IF ORIGINAL NUMBER IS <1?
03332    337E  C6 8E                  DEC L		;IT WAS <1. LEAVE ROOM FOR LEADINF 0
03333    3380  24 8A        FPR4B     BIT SIGNP	;WAS NUMBER NEGATIVE
03334    3382  10 02                  BPL FPR5	;BRANCH IF NOT
03335    3384  C6 8E                  DEC L		;YES, THEN LEAVE ROOM FOR A MINUS SIGN
03336    3386  A5 8E        FPR5      LDA L		;ANY BLANKS TO OUTPUT?
03337    3388  30 09                  BMI FPR7	;BRANCH IF NOT
03338    338A  F0 07                  BEQ FPR7	;BRANCH IF NOT
03339    338C  20 00 29     FPR6      JSR PSPACE	;OUTPUT A BLANK
03340    338F  C6 8E                  DEC L		;COUNT IT
03341    3391  D0 F9                  BNE FPR6	;AND LOOP TILL ALL HAVE BENN OUTPUT
03342    3393  24 8A        FPR7      BIT SIGNP	;WAS NUMBER NEGATIVE?
03343    3395  10 05                  BPL FPR7A	;BRANCH IF NOT
03344    3397  A9 2D                  LDA #$2D	;YES, OUTPUT A LEADING "-"
03345    3399  20 02 29               JSR PRINTC	;AND FALL INTO NEXT PAGE
03346    339C  68           FPR7A     PLA		;GET EXPONENT OF THE ORIGINAL NUM BACK AGAIN
03347    339D  30 03                  BMI FPR8	;BRANCH IF NOT <1
03348    339F  20 C8 33               JSR PZERO	;YES, THEN GIVE A LEADING ZERO
03349    			;(PEOPLE LIKE IT!)
03350    			;(IT'S ALSO A PAIN TO CHECK FOR!)
03351    ;                                        
03352    ; NOW FOR THE MEAT OF IT
03353    ;
03354    33A2  A9 09        FPR8      LDA #$09	;* GET MAX NUMBER OF SIG FIGS
03355    33A4  85 8E                  STA L		;INTO L
03356    33A6  A5 8D        FPR9      LDA K		;ANY OUTPUT BEFORE DECIMAL?
03357    33A8  F0 07                  BEQ FPR11	;BRANCH IF NO MORE
03358    33AA  20 C4 33     FPR10     JSR MDO	;OUTPUT A DIGIT BEFORE DECIMAL
03359    33AD  C6 8D                  DEC K
03360    33AF  D0 F9                  BNE FPR10	;AND LOOK TILL ALL DONE
03361    33B1  A5 90        FPR11     LDA N		;GET NUMBER AFTER DECIMAL POINT
03362    33B3  85 8D                  STA K		;INTO K
03363    33B5  F0 0C                  BEQ FPRET	;BRANCH IF NONE TO OUTPUT
03364    33B7  A9 2E                  LDA #$2E	;THERE ARE SOME TO OUTPUT,
03365    33B9  20 02 29               JSR PRINTC	;PRINT THE DECIMAL POINT
03366    33BC  20 C4 33     FPR12     JSR MDO	;OUTPUT A DIGIT AFTER DECIMAL
03367    33BF  C6 8D                  DEC K		;AND LOOP
03368    33C1  D0 F9                  BNE FPR12	;TILL ALL OUTPUT
03369    33C3  60           FPRET     RTS		;RETURN FROM 'FPRNT' FAC1 IS DESTROYED!
03370    ;
03371    ; MPY BY 10, PRINT INTEGER AND SUBTRACT IT
03372    ;
03373    33C4  C6 8E        MDO       DEC L		;HAVE WE OUTPUT ALL DIGITS OF SIGNIFICANCE?
03374    33C6  10 05                  BPL MDO1	;BRANCH IF NOT, OUTPUT THIS ONE
03375    33C8  A9 30        PZERO     LDA #$30	;YES, THEN OUTPUT A ZERO
03376    33CA  4C 02 29               JMP PRINTC	;* PJMP * AND RETURN
03377    33CD  A6 91        MDO1      LDX FTEN               
03378    33CF  A4 7B                  LDY X2
03379    33D1  20 FF 33               JSR MOVXY
03380    33D4  20 A0 32               JSR FMUL
03381    33D7  A6 80        FDONE     LDX X1	;SAVE FAC1
03382    33D9  A4 A0                  LDY T
03383    33DB  20 FF 33               JSR MOVXY
03384    33DE  20 18 33               JSR FIX
03385    33E1  A5 83                  LDA M1+2	;MAKE ASCII
03386    33E3  29 0F                  AND #$0F
03387    33E5  09 30                  ORA #$30
03388    33E7  20 02 29               JSR PRINTC
03389    33EA  20 39 32               JSR FLOAT	;NOW SUBTRACT IT
03390    33ED  A6 A0                  LDX T		;RESTORE TO FAC2
03391    33EF  A4 7B                  LDY X2
03392    33F1  20 FF 33               JSR MOVXY
03393    33F4  4C 73 32               JMP FSUB	;PJUMP
03394    
03395    ;
03396    ;   UTILITIES FOR FPRNT
03397    ;
03398    33F7  24 81        ABSF1     BIT M1
03399    33F9  10 03                  BPL ABSFE
03400    33FB  20 B8 32               JSR FCOMPL
03401    33FE  60           ABSFE     RTS
03402    33FF  CA           MOVXY     DEX
03403    3400  8E 0A 34               STX MOV1+1
03404    3403  88                     DEY
03405    3404  8C 0B 34               STY MOV1+2
03406    3407  A2 05                  LDX #$05	;*
03407    3409  B5 00        MOV1      LDA $00,X
03408    340B  95 00        MOV2      STA $00,X
03409    340D  CA                     DEX
03410    340E  D0 F9                  BNE MOV1
03411    3410  60                     RTS
03412    ;
03413    3411  20 29 32     DIV10     JSR SWAP
03414    3414  A6 91                  LDX FTEN
03415    3416  A4 80                  LDY X1
03416    3418  20 FF 33               JSR MOVXY
03417    341B  4C CA 32               JMP FDIV	;*PJMP*
03418    ;
03419    341E  A5 81        CHKZER    LDA M1	;GET HIGH ORDER MANTISSA
03420    3420  05 82                  ORA M1+1	;'OR' ALL BYTES OF MANTISSA TOGETHER
03421    3422  05 83                  ORA M1+2
03422    3424  05 84                  ORA M1+3	;*
03423    3426  60                     RTS		;RETURN WITH Z=1 IF MANTISSA IS =0.
03424    ;
03425    ;   'FLOATING POINT INPUT ROUTINE'
03426    ;
03427    3427  A9 00        FINP      LDA #$00
03428    3429  85 8A                  STA SIGNP	;SET SIGN +
03429    342B  85 8B                  STA DPFLG	;RESET DP FLAG
03430    342D  85 8C                  STA GOTFLG	;NO INPUT YET
03431    342F  85 8D                  STA K		;NO DIGITS AFTER DECIMAL POINT
03432    3431  85 7B                  STA X2	;ZERO RESULT
03433    3433  85 7C                  STA M2
03434    3435  85 7D                  STA M2+1
03435    3437  85 7E                  STA M2+2
03436    3439  85 7F                  STA M2+3	;*
03437    343B  A5 2B                  LDA CHAR	;GET CHARACTER
03438    343D  C9 2B                  CMP #$2B	;IGNORE +'S
03439    343F  F0 06                  BEQ FINP3               
03440    3441  C9 2D                  CMP #$2D	;'-' FLAG IF NEGATIVE
03441    3443  D0 05                  BNE FINP2
03442    3445  E6 8A                  INC SIGNP
03443    3447  20 92 29     FINP3     JSR GETC	;ANOTHER CHAR
03444    344A  C9 30        FINP2     CMP #$30	;'0' IS IT A DIGIT?
03445    344C  90 24                  BCC FINP4	;NO
03446    344E  C9 3A                  CMP #$3A	;':' MAYBE...
03447    3450  B0 20                  BCS FINP4	;NO
03448    3452  A6 91                  LDX FTEN
03449    3454  A4 80                  LDY X1
03450    3456  20 FF 33               JSR MOVXY	;FAC2*10.0=FAC1
03451    3459  20 A0 32               JSR FMUL
03452    345C  20 29 32               JSR SWAP	;INTO FAC2
03453    345F  E6 8C                  INC GOTFLG	;YES, WE HAVE INPUT
03454    3461  A5 2B                  LDA CHAR
03455    3463  29 0F                  AND #$0F	;MAKE NUMERIC
03456    3465  20 41 32               JSR FLT8	;AND FLOAT IT
03457    3468  20 79 32               JSR FADD	;ADD TO PARTIAL RESULT
03458    346B  20 29 32               JSR SWAP	;BACK INTO FAC2
03459    346E  E6 8D                  INC K		;COUNT DIGITS AFTER DECIMAL POINT
03460    3470  D0 D5                  BNE FINP3	;GET MORE
03461    3472  C9 2E        FINP4     CMP #$2E	;DECIMAL POINT?
03462    3474  D0 0C                  BNE FINP5	;NO, END OF #
03463    3476  A5 8B                  LDA DPFLG	;YES, ALREADY GOT ONE?
03464    3478  D0 08                  BNE FINP5	;THEN END OF #
03465    347A  E6 8B                  INC DPFLG	;ELSE FLAG GOT ONE
03466    347C  A9 00                  LDA #$00
03467    347E  85 8D                  STA K		;RESET K
03468    3480  F0 C5                  BEQ FINP3	;AND GET FRACTION
03469    ;
03470    ; HERE ON END OF NUMBER
03471    ;
03472    3482  20 29 32     FINP5     JSR SWAP	;RESULT TO FAC1
03473    3485  A5 8B                  LDA DPFLG	;ANY DECIMAL POINTS?
03474    3487  F0 0B                  BEQ FINP6	;NO, ITS OK
03475    3489  A5 8D        FINP7     LDA K		;ELSE ADJUST
03476    348B  F0 07                  BEQ FINP6	;ADJUST DONE
03477    348D  20 11 34               JSR DIV10	;RESULT/10
03478    3490  C6 8D                  DEC K		;K TIMES
03479    3492  D0 F5                  BNE FINP7
03480    3494  A5 8A        FINP6     LDA SIGNP	;NOW ADD SIGN
03481    3496  F0 03                  BEQ FINP8	;WAS POS
03482    3498  20 B8 32               JSR FCOMPL	;WAS NEG
03483    349B  4C 57 32     FINP8     JMP NORM	;PJUMP TO NORMALIZE
03484    ;
03485    ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
03486    ;
03487    ;     Here begins (again) code restoration by dhh
03488    ;
03489    ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
03490    ;
03491    ; from here, the Aresco version of V3D code (TTY) completely differs from
03492    ; the ProgramExchange/6502 Group TIM-monitor code upon which it is based.
03493    ; PE code occupies $24A6 to $24D0 (here $349E to $34E7), and seems to be
03494    ; related to video terminal output.  What follows here are KIM-1-specific
03495    ; initialization and I/O routines from the Aresco version of V3D.  -dhh 
03496    ;
03497    349E  A9 E0        CONINI    LDA #$E0	; init BRK vector as $2CE0
03498    34A0  8D FE 17               STA $17FE
03499    34A3  A9 2C                  LDA #$2C
03500    34A5  8D FF 17               STA $17FF
03501    34A8  18                     CLC
03502    34A9  60                     RTS
03503    34AA  20 A0 1E     TVOUT     JSR $1EA0	; TTY OUTCH in KIM-1 ROM
03504    34AD  18                     CLC
03505    34AE  60                     RTS
03506    34AF  E6 76        KEYIN     INC $76	; label HASH
03507    34B1  2C 40 17               BIT $1740     ; (R)RIOT I/O register A
03508    34B4  30 F9                  BMI KEYIN
03509    34B6  AD 42 17               LDA $1742     ; (R)RIOT I/O register B
03510    34B9  29 FE                  AND #$FE
03511    34BB  8D 42 17               STA $1742
03512    34BE  20 5A 1E               JSR $1E5A     ; GETCH in KIM-1 ROM
03513    34C1  48                     PHA
03514    34C2  AD 42 17               LDA $1742     ; the echo defeat
03515    34C5  29 FE                  AND #$FE
03516    34C7  09 01                  ORA #$01
03517    34C9  8D 42 17               STA $1742
03518    34CC  68                     PLA
03519    34CD  18                     CLC
03520    34CE  60                     RTS          ; 
03521    ;
03522    ;  The next bytes do not appear to be used for anything.
03523    ;  Perhaps leftover from Aresco conversion of Prog/Exch
03524    ;  version for KIM-1 (???).
03525    ;
03526    ;        .BYTE $00,$43,$11,$51,$11,$11,$17,$01,$01,$11,$41
03527    
03528    ; Papertape version has these 12 bytes first instead - SamCoVT
03529            .BYTE $17,$09,$01,$8D,$42,$17,$A9,$00,$20,$A0,$1E
03530    
03531    ; Both versions agree on these bytes
03532            .BYTE $53,$01,$51,$51,$11,$53,$EE,$CE,$FE,$EE,$EA
03533            .BYTE $EE,$06,$FE
03534    ;          BRK
03535    ;          ???                ;01000011 'C'
03536    ;          ORA ($51),Y
03537    ;          ORA ($11),Y
03538    ;          ???                ;00010111
03539    ;          ORA ($01,X)
03540    ;          ORA ($41),Y
03541    ;          ???                ;01010011 'S'
03542    ;          ORA ($51,X)
03543    ;          EOR ($11),Y
03544    ;          ???                ;01010011 'S'
03545    ;          INC $FECE
03546    ;          INC $EEEA
03547    ;          ASL $FE
03548    ;
03549    
03550    ;     SPECIAL TERMINATOR CHAR TABLE (see P/E code at $2401)
03551    ;
03552    TRMTAB   .BYTE ' '     ; LEVEL 0 (SPACE)
03553             .BYTE '+'     ; LEVEL 1 '+'
03554             .BYTE '-'     ; LEVEL 2 '-'
03555             .BYTE '/'     ; LEVEL 3 '/'
03556             .BYTE '*'     ; LEVEL 4 '*'
03557             .BYTE '^'     ; LEVEL 5 '^'
03558             .BYTE '('     ; LEVEL 6 '('
03559             .BYTE ')'     ; LEVEL 7 ')'  (START OF DELIMITERS)
03560             .BYTE ','     ; LEVEL 8 ','
03561             .BYTE ';'     ; LEVEL 9 ';'
03562             .BYTE $0D     ; LEVEL 10 'CR'
03563             .BYTE '='     ; LEVEL 11 '=' (TERMINATOR FOR 'SET')
03564             .BYTE LINCHR  ; LEVEL 1 '_'  ('LINE-DELETE IS HERE SO
03565                           ;             'ASK' CAN ALLOW RE-TYPEIN)
03566    ;
03567    ; here TRMAX=12 is defined in the ProgExch code
03568    ;
03569    ;      THESE FUNCTION DISPATCH TABLES MAY BE PATCHED BY A USER
03570    ;      TO CALL HIS OWN FUNCTIONS.
03571    ;
03572    ;      TABLE OF 'HASH CODES' FOR FUNCTION NAMES
03573    ;
03574    FUNTAB    .BYTE HFABS     ; ABSOLUTE VALUE FUNCTION
03575              .BYTE HFOUT     ; CHARACTER OUTPUT FUNCTION
03576              .BYTE HFRAN     ; RANDOM NUMBER FUNCTION
03577              .BYTE HFINT     ; INTEGERIZE FUNCTION
03578              .BYTE HFINR     ; INTEGERIZE WITH ROUNDING FUNCTION
03579              .BYTE HFIDV     ; INPUT DEVICE FUNCTION
03580              .BYTE HFODV     ; OUTPUT DEVICE FUNCTION
03581              .BYTE HFCHR     ; CHARACTER INPUT FUNCTION
03582              .BYTE HFCUR     ; CONSOLE CURSOR ADDRESSING FUNCTION
03583              .BYTE HFECH     ; ECHO CONTROL FUNCTION
03584              .BYTE HFPIC     ; SOFTWARE PRIORITY INTERRUPT FUNCTION
03585              .BYTE HFMEM     ; MEMORY EXAMINE-DEPOSIT FUNCTION
03586              .BYTE HFINI     ; INITIALIZE INPUT DEVICE FUNCTION
03587              .BYTE HFINO     ; INITIALIZE OUTPUT DEVICE FUNCTION
03588              .BYTE HFCLI     ; CLOSE INPUT DEVICE FUNCTION
03589              .BYTE HFCLO     ; CLOSE OUTPUT DEVICE FUNCTION
03590              .BYTE HFCON     ; SET CONSOLE DEVICE FUNCTION
03591              .BYTE HFSBR     ; 'SUBROUTINE' CALL FUNCTION
03592              .BYTE HFISL     ; INITIALIZE STRING LENGTH FUNCTION
03593              .BYTE HFSTI     ; STRING INPUT FUNCTION
03594              .BYTE HFSTO     ; STRING OUTPUT FUNCTION
03595              .BYTE HFSLK     ; STRING "LOOK" FUNCTION
03596              .BYTE 0	  ; SPARE LOCS FOR HACKERS
03597              .BYTE 0
03598              .BYTE 0
03599              .BYTE 0
03600              .BYTE 0
03601              .BYTE 0          ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03602    ;
03603    ;     FUNCTION DISPATCH TABLES - HIGH BYTE
03604    ;
03605    FUNADH     .BYTE >FABS     ; FABS
03606               .BYTE >FOUT     ; FOUT
03607               .BYTE >FRAN     ; FRAN
03608               .BYTE >FINT     ; FINT
03609               .BYTE >FINR     ; FINR
03610               .BYTE >FIDV     ; FIDV
03611               .BYTE >FODV     ; FODV
03612               .BYTE >FCHR     ; FCHR
03613               .BYTE >FCUR     ; FCUR
03614               .BYTE >FECH     ; FECH
03615               .BYTE >FPIC     ; FPIC
03616               .BYTE >FMEM     ; FMEM
03617               .BYTE >FINI     ; FINI
03618               .BYTE >FINO     ; FINO
03619               .BYTE >FCLI     ; FCLI
03620               .BYTE >FCLO     ; FCLO
03621               .BYTE >FCON     ; FCON
03622               .BYTE >FSBR     ; FSBR
03623               .BYTE >FISL     ; FISL
03624               .BYTE >FSTI     ; FSTI
03625               .BYTE >FSTO     ; FSTO
03626               .BYTE >FSLK     ; FSLK
03627               .BYTE $00       ; SPACE FOR HACKERS
03628    L3528      .BYTE 0
03629               .BYTE 0
03630               .BYTE 0
03631               .BYTE 0
03632               .BYTE 0          ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03633    ;
03634    ;     FUNCTION DISPATCH TABLES - LOW ORDER ADDR BYTE
03635    ;
03636    FUNADL     .BYTE <FABS     ; FABS
03637               .BYTE <FOUT     ; FOUT
03638               .BYTE <FRAN     ; FRAN
03639               .BYTE <FINT     ; FINT
03640               .BYTE <FINR     ; FINR
03641               .BYTE <FIDV     ; FIDV
03642               .BYTE <FODV     ; FODV
03643               .BYTE <FCHR     ; FCHR
03644               .BYTE <FCUR     ; FCUR
03645               .BYTE <FECH     ; FECH
03646               .BYTE <FPIC     ; FPIC
03647               .BYTE <FMEM     ; FMEM
03648               .BYTE <FINI     ; FINI
03649               .BYTE <FINO     ; FINO
03650               .BYTE <FCLI     ; FCLI
03651               .BYTE <FCLO     ; FCLO
03652               .BYTE <FCON     ; FCON
03653               .BYTE <FSBR     ; FSBR
03654               .BYTE <FISL     ; FISL
03655               .BYTE <FSTI     ; FSTI
03656               .BYTE <FSTO     ; FSTO
03657               .BYTE <FSLK     ; FSLK
03658    L3543      .BYTE 0             ; SPACE FOR HACKERS
03659               .BYTE 0
03660               .BYTE 0
03661               .BYTE 0
03662               .BYTE 0
03663               .BYTE 0               ; MUST HAVE AT LEAST ONE ZERO TO END TABLE!
03664    ;
03665    ;     COMMAND DISPATCH TABLES
03666    ;
03667    ;     THESE COMMAND DISPATCH TABLES MAY BE PATCHED BY USER
03668    ;     TO ADD HIS OWN SPECIAL COMMAND HANDLERS
03669    ;
03670    ;     COMMAND CHARACTER TABLE
03671    ;
03672    
03673    COMTAB     .BYTE 'S'     ; 'S' SAVE COMMAND
03674               .BYTE 'I'     ; 'I' IF COMMAND
03675               .BYTE 'D'     ; 'D' DO COMMAND
03676               .BYTE 'O'     ; 'O' ON COMMAND
03677               .BYTE 'G'     ; 'G' GOTO COMMAND
03678               .BYTE 'F'     ; 'F' FOR COMMAND
03679               .BYTE 'R'     ; 'R' RETURN COMMAND
03680               .BYTE 'T'     ; 'T' TYPE COMMAND
03681               .BYTE 'A'     ; 'A' ASK COMMAND
03682               .BYTE 'C'     ; 'C' COMMENT COMMAND
03683               .BYTE 'E'     ; 'E' ERASE COMMAND
03684               .BYTE 'W'     ; 'W' WRITE COMMAND
03685               .BYTE 'M'     ; 'M' MODIFY COMMAND
03686               .BYTE 'Q'     ; 'Q' QUIT COMMAND
03687               .BYTE 0       ; SPACE FOR HACKERS
03688               .BYTE 0
03689               .BYTE 0
03690               .BYTE 0
03691               .BYTE 0
03692               .BYTE 0          ; MUST HAVE ONE ZERO TO END TABLE!
03693    ; 
03694    ;     HIGH ORDER ADDR OF COMMAND HANDLING ROUTINE
03695    ;
03696    COMADH     .BYTE >SET         ; SET    
03697               .BYTE >IF          ; IF     
03698               .BYTE >DO          ; DO     
03699               .BYTE >ON          ; ON     
03700               .BYTE >GOTO        ; GOTO   
03701               .BYTE >FOR         ; FOR    
03702               .BYTE >RETURN      ; RETURN 
03703               .BYTE >TYPE        ; TYPE   
03704               .BYTE >ASK         ; ASK    
03705               .BYTE >COMMNT      ; COMMENT
03706               .BYTE >ERASE       ; ERASE  
03707               .BYTE >WRITE       ; WRITE  
03708               .BYTE >MODIFY      ; MODIFY 
03709               .BYTE >QUIT        ; QUIT   
03710               .BYTE 0            ; SPACE FOR HACKERS
03711               .BYTE 0
03712               .BYTE 0
03713               .BYTE 0          ; MUST HAVE ZERO TO END TABLE!
03714    ;
03715    ;     LOW ORDER ADDR OF COMMAND HANDLING ROUTINE
03716    ;
03717    COMADL     .BYTE <SET         ; SET
03718               .BYTE <IF          ; IF
03719               .BYTE <DO          ; DO
03720               .BYTE <ON          ; ON
03721               .BYTE <GOTO        ; GOTO
03722               .BYTE <FOR         ; FOR
03723               .BYTE <RETURN      ; RETURN
03724               .BYTE <TYPE        ; TYPE
03725               .BYTE <ASK         ; ASK
03726               .BYTE <COMMNT      ; COMMENT
03727               .BYTE <ERASE       ; ERASE
03728               .BYTE <WRITE       ; WRITE
03729               .BYTE <MODIFY      ; MODIFY
03730               .BYTE <QUIT        ; QUIT
03731               .BYTE 0               ; SPACE FOR HACKERS
03732               .BYTE 0
03733               .BYTE 0
03734               .BYTE 0          ; MUST HAVE A ZERO TO END TABLE!
03735    ;
03736    ;     DISPATCH TABLE FOR 'EVBOP' ROUTINE
03737    ;
03738    ; two definitions here in the Prog/Exch code:
03739    ; at $2569 (3580 here) .DEF EVDSPH=.-1  and
03740    ; $256E (3585) .DEF EVDSPL=.-1
03741    ;
03742      3580             EVDSPH = * - 1
03743               .BYTE >FADD       ; FADD  
03744               .BYTE >FSUB       ; FSUB  
03745               .BYTE >FDIV       ; FDIV  
03746               .BYTE >FMUL       ; FMUL  
03747               .BYTE >EVPOWR     ; EVPOWR
03748    ;
03749      3585             EVDSPL = * - 1
03750               .BYTE <FADD       ; FADD
03751               .BYTE <FSUB       ; FSUB
03752               .BYTE <FDIV       ; FDIV
03753               .BYTE <FMUL       ; FMUL
03754               .BYTE <EVPOWR     ; EVPOWR
03755    ;
03756    ;          TABLES USED BY SOFTWARE INTERRUPT SYSTEM
03757    ;
03758    ; TABLE OF GROUP NUMBERS OF LINES TO 'DO' WHEN EVENT HAPPENS
03759    ; ONE ENTRY FOR EACH OF THE 8 PRIORITY CHANNELS
03760    ;
03761    INTGRP     .BYTE 0
03762               .BYTE 0
03763               .BYTE 0
03764               .BYTE 0
03765               .BYTE 0
03766               .BYTE 0
03767               .BYTE 0
03768               .BYTE 0
03769               .BYTE 0
03770    ;
03771    ; TABLE OF STEP NUMBERS OF LINES TO 'DO' WHEN AN EVENT HAPPENS
03772    ;
03773    INTLIN     .BYTE 0
03774               .BYTE 0
03775               .BYTE 0
03776               .BYTE 0
03777               .BYTE 0
03778               .BYTE 0
03779               .BYTE 0
03780               .BYTE 0
03781               .BYTE 0
03782    ;
03783    ; 'AND' MASKS USED TO DISABLE ALL BUT HIGHER PRIO CHANNELS.
03784    ; INDEXED BY CURRENT CHANNEL NUMBER
03785    ;
03786    INTTAB    .BYTE $FF     ; CHANNEL 0 ENABLES THEM ALL
03787              .BYTE $FE
03788              .BYTE $FC
03789              .BYTE $F8
03790              .BYTE $F0
03791              .BYTE $E0
03792              .BYTE $C0
03793              .BYTE $80
03794              .BYTE $00     ; CHANNEL 8 ENABLES NONE
03795    ;
03796    ; BIT TABLE CONTAINING A SINGLE BIT FOR EACH CHANNEL POSITION
03797    ;
03798    BITTAB    .BYTE $00
03799              .BYTE $01
03800              .BYTE $02
03801              .BYTE $04
03802              .BYTE $08
03803              .BYTE $10
03804              .BYTE $20
03805              .BYTE $40
03806              .BYTE $80
03807    ;
03808    ;     DISPATCH TABLE FOR I/O DEVICE NUMBERS
03809    ;
03810    ; handwritten note in P/E source: "READ/WRITE"
03811    ; Two definitions made here:
03812    ;     .DEF IDEWVM=3     .DEF ODEVM=3  ; MAX # OF I/O DEVICES
03813      0003             IDEVM = 3                  ; Original was IDEWVM - changed to IDEVM (Input DEVice Max)
03814      0003             ODEVM = 3
03815        
03816    ;
03817    IDSPH     .BYTE >KEYIN     ; DEVICE 0 - KEYBOARD INPUT ROUTINE
03818              .BYTE 0          ; DEVICE 1 - CASSETTE #0 INPUT ROUTINE
03819              .BYTE 0          ; DEVICE 2 - CASSETTE #1 INPUT ROUTINE
03820              .BYTE 0          ; SPACE FOR HACKERS
03821              .BYTE 0
03822    IDSPL     .BYTE <KEYIN
03823              .BYTE 0
03824              .BYTE 0
03825              .BYTE 0
03826              .BYTE 0
03827    ODSPH     .BYTE >TVOUT     ; DEVICE 0 - TV OUTPUT ROUTINE
03828              .BYTE 0          ; DEVICE 1 - CASSETTE #0 OUTPUT ROUTINE
03829              .BYTE 0          ; DEVICE 2 - CASSETTE #1 OUTPUT ROUTINE
03830              .BYTE 0          ; SPACE FOR HACKERS
03831              .BYTE 0
03832    ODSPL     .BYTE >TVOUT
03833              .BYTE 0
03834              .BYTE 0
03835              .BYTE 0
03836              .BYTE 0
03837    ;
03838    ; handwritten note in P/E source: "INITIALIZE IN/OUT"
03839    ;
03840    INIAH      .BYTE >RTS1     ; DON'T NEED TO INTIALIZE KEYBOARD
03841               .BYTE >RTS1     ; USER MUST PROVIDE ROUTINE
03842               .BYTE >RTS1     ;
03843               .BYTE $00       ; SPACE FOR HACKERS
03844               .BYTE $00
03845    ;
03846    INIAL      .BYTE <RTS1
03847               .BYTE <RTS1
03848               .BYTE <RTS1
03849               .BYTE 0
03850               .BYTE 0
03851    ;
03852    INOAH      .BYTE >CONINI	; USE TO STUFF VECTORS WITH BREAK HANDLERS
03853               .BYTE $29		; USER PROVIDES ROUTINES
03854               .BYTE $29
03855               .BYTE 0
03856               .BYTE 0
03857    ;
03858    INOAL      .BYTE <CONINI
03859               .BYTE $40
03860               .BYTE $40
03861               .BYTE 0
03862               .BYTE 0
03863    ;
03864    ; handwritten note in P/E source: "CLOSE IN/OUT"
03865    ;
03866    CLIAH     .BYTE >RTS1   ; KEYBOARD DOESN'T NEED A CLOSE ROUTINE
03867              .BYTE >RTS1   ; USER PROVIDES ROUTINE
03868              .BYTE >RTS1   ;
03869              .BYTE $00     ; SPACE FOR HACKERS
03870              .BYTE $00     ; SPACE FOR HACKERS
03871    ;
03872    CLIAL     .BYTE <RTS1
03873              .BYTE <RTS1
03874              .BYTE <RTS1
03875              .BYTE 0
03876              .BYTE 0
03877    ;
03878    CLOAH     .BYTE >RTS1	; TV DOESN'T NEED A CLOSE ROUTINE
03879              .BYTE >RTS1	; USER PROVIDES ROUTINE
03880              .BYTE >RTS1	;
03881              .BYTE $00	; SPACE FOR HACKERS
03882              .BYTE $00  
03883    ;                    
03884    CLOAL     .BYTE <RTS1
03885              .BYTE <RTS1
03886              .BYTE <RTS1
03887              .BYTE 0
03888              .BYTE 0
03889    ;
03890    ;      FOCEND - TEXT AREAS AND THE LIKE
03891    ;
03892    PRGBEG    .BYTE 0	; LINE NUMBER OF 00.00
03893              .BYTE 0     
03894              .ASCII  " C FOCAL-65 (V3D) 26-AUG-77"
03895              .BYTE $0D	; 'CR'
03896    
03897    
03898    PBEG     .BYTE EOP     ; START OF PROGRAM TEXT AREA
03899    VEND     .BYTE EOV     ; END OF VARIABLE LIST
03900    
03901             .END     
